{"ast":null,"code":"\"use strict\";\n/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar util_1 = require(\"./util\");\n\nvar util_2 = require(\"@firebase/util\");\n/**\n * An immutable object representing a parsed path.  It's immutable so that you\n * can pass them around to other functions without worrying about them changing\n * it.\n */\n\n\nvar Path =\n/** @class */\nfunction () {\n  /**\n   * @param {string|Array.<string>} pathOrString Path string to parse,\n   *      or another path, or the raw tokens array\n   * @param {number=} pieceNum\n   */\n  function Path(pathOrString, pieceNum) {\n    if (pieceNum === void 0) {\n      this.pieces_ = pathOrString.split('/'); // Remove empty pieces.\n\n      var copyTo = 0;\n\n      for (var i = 0; i < this.pieces_.length; i++) {\n        if (this.pieces_[i].length > 0) {\n          this.pieces_[copyTo] = this.pieces_[i];\n          copyTo++;\n        }\n      }\n\n      this.pieces_.length = copyTo;\n      this.pieceNum_ = 0;\n    } else {\n      this.pieces_ = pathOrString;\n      this.pieceNum_ = pieceNum;\n    }\n  }\n\n  Object.defineProperty(Path, \"Empty\", {\n    /**\n     * Singleton to represent an empty path\n     *\n     * @const\n     */\n    get: function () {\n      return new Path('');\n    },\n    enumerable: true,\n    configurable: true\n  });\n\n  Path.prototype.getFront = function () {\n    if (this.pieceNum_ >= this.pieces_.length) return null;\n    return this.pieces_[this.pieceNum_];\n  };\n  /**\n   * @return {number} The number of segments in this path\n   */\n\n\n  Path.prototype.getLength = function () {\n    return this.pieces_.length - this.pieceNum_;\n  };\n  /**\n   * @return {!Path}\n   */\n\n\n  Path.prototype.popFront = function () {\n    var pieceNum = this.pieceNum_;\n\n    if (pieceNum < this.pieces_.length) {\n      pieceNum++;\n    }\n\n    return new Path(this.pieces_, pieceNum);\n  };\n  /**\n   * @return {?string}\n   */\n\n\n  Path.prototype.getBack = function () {\n    if (this.pieceNum_ < this.pieces_.length) return this.pieces_[this.pieces_.length - 1];\n    return null;\n  };\n\n  Path.prototype.toString = function () {\n    var pathString = '';\n\n    for (var i = this.pieceNum_; i < this.pieces_.length; i++) {\n      if (this.pieces_[i] !== '') pathString += '/' + this.pieces_[i];\n    }\n\n    return pathString || '/';\n  };\n\n  Path.prototype.toUrlEncodedString = function () {\n    var pathString = '';\n\n    for (var i = this.pieceNum_; i < this.pieces_.length; i++) {\n      if (this.pieces_[i] !== '') pathString += '/' + encodeURIComponent(String(this.pieces_[i]));\n    }\n\n    return pathString || '/';\n  };\n  /**\n   * Shallow copy of the parts of the path.\n   *\n   * @param {number=} begin\n   * @return {!Array<string>}\n   */\n\n\n  Path.prototype.slice = function (begin) {\n    if (begin === void 0) {\n      begin = 0;\n    }\n\n    return this.pieces_.slice(this.pieceNum_ + begin);\n  };\n  /**\n   * @return {?Path}\n   */\n\n\n  Path.prototype.parent = function () {\n    if (this.pieceNum_ >= this.pieces_.length) return null;\n    var pieces = [];\n\n    for (var i = this.pieceNum_; i < this.pieces_.length - 1; i++) pieces.push(this.pieces_[i]);\n\n    return new Path(pieces, 0);\n  };\n  /**\n   * @param {string|!Path} childPathObj\n   * @return {!Path}\n   */\n\n\n  Path.prototype.child = function (childPathObj) {\n    var pieces = [];\n\n    for (var i = this.pieceNum_; i < this.pieces_.length; i++) pieces.push(this.pieces_[i]);\n\n    if (childPathObj instanceof Path) {\n      for (var i = childPathObj.pieceNum_; i < childPathObj.pieces_.length; i++) {\n        pieces.push(childPathObj.pieces_[i]);\n      }\n    } else {\n      var childPieces = childPathObj.split('/');\n\n      for (var i = 0; i < childPieces.length; i++) {\n        if (childPieces[i].length > 0) pieces.push(childPieces[i]);\n      }\n    }\n\n    return new Path(pieces, 0);\n  };\n  /**\n   * @return {boolean} True if there are no segments in this path\n   */\n\n\n  Path.prototype.isEmpty = function () {\n    return this.pieceNum_ >= this.pieces_.length;\n  };\n  /**\n   * @param {!Path} outerPath\n   * @param {!Path} innerPath\n   * @return {!Path} The path from outerPath to innerPath\n   */\n\n\n  Path.relativePath = function (outerPath, innerPath) {\n    var outer = outerPath.getFront(),\n        inner = innerPath.getFront();\n\n    if (outer === null) {\n      return innerPath;\n    } else if (outer === inner) {\n      return Path.relativePath(outerPath.popFront(), innerPath.popFront());\n    } else {\n      throw new Error('INTERNAL ERROR: innerPath (' + innerPath + ') is not within ' + 'outerPath (' + outerPath + ')');\n    }\n  };\n  /**\n   * @param {!Path} left\n   * @param {!Path} right\n   * @return {number} -1, 0, 1 if left is less, equal, or greater than the right.\n   */\n\n\n  Path.comparePaths = function (left, right) {\n    var leftKeys = left.slice();\n    var rightKeys = right.slice();\n\n    for (var i = 0; i < leftKeys.length && i < rightKeys.length; i++) {\n      var cmp = util_1.nameCompare(leftKeys[i], rightKeys[i]);\n      if (cmp !== 0) return cmp;\n    }\n\n    if (leftKeys.length === rightKeys.length) return 0;\n    return leftKeys.length < rightKeys.length ? -1 : 1;\n  };\n  /**\n   *\n   * @param {Path} other\n   * @return {boolean} true if paths are the same.\n   */\n\n\n  Path.prototype.equals = function (other) {\n    if (this.getLength() !== other.getLength()) {\n      return false;\n    }\n\n    for (var i = this.pieceNum_, j = other.pieceNum_; i <= this.pieces_.length; i++, j++) {\n      if (this.pieces_[i] !== other.pieces_[j]) {\n        return false;\n      }\n    }\n\n    return true;\n  };\n  /**\n   *\n   * @param {!Path} other\n   * @return {boolean} True if this path is a parent (or the same as) other\n   */\n\n\n  Path.prototype.contains = function (other) {\n    var i = this.pieceNum_;\n    var j = other.pieceNum_;\n\n    if (this.getLength() > other.getLength()) {\n      return false;\n    }\n\n    while (i < this.pieces_.length) {\n      if (this.pieces_[i] !== other.pieces_[j]) {\n        return false;\n      }\n\n      ++i;\n      ++j;\n    }\n\n    return true;\n  };\n\n  return Path;\n}(); // end Path\n\n\nexports.Path = Path;\n/**\n * Dynamic (mutable) path used to count path lengths.\n *\n * This class is used to efficiently check paths for valid\n * length (in UTF8 bytes) and depth (used in path validation).\n *\n * Throws Error exception if path is ever invalid.\n *\n * The definition of a path always begins with '/'.\n */\n\nvar ValidationPath =\n/** @class */\nfunction () {\n  /**\n   * @param {!Path} path Initial Path.\n   * @param {string} errorPrefix_ Prefix for any error messages.\n   */\n  function ValidationPath(path, errorPrefix_) {\n    this.errorPrefix_ = errorPrefix_;\n    /** @type {!Array<string>} */\n\n    this.parts_ = path.slice();\n    /** @type {number} Initialize to number of '/' chars needed in path. */\n\n    this.byteLength_ = Math.max(1, this.parts_.length);\n\n    for (var i = 0; i < this.parts_.length; i++) {\n      this.byteLength_ += util_2.stringLength(this.parts_[i]);\n    }\n\n    this.checkValid_();\n  }\n\n  Object.defineProperty(ValidationPath, \"MAX_PATH_DEPTH\", {\n    /** @const {number} Maximum key depth. */\n    get: function () {\n      return 32;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(ValidationPath, \"MAX_PATH_LENGTH_BYTES\", {\n    /** @const {number} Maximum number of (UTF8) bytes in a Firebase path. */\n    get: function () {\n      return 768;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /** @param {string} child */\n\n  ValidationPath.prototype.push = function (child) {\n    // Count the needed '/'\n    if (this.parts_.length > 0) {\n      this.byteLength_ += 1;\n    }\n\n    this.parts_.push(child);\n    this.byteLength_ += util_2.stringLength(child);\n    this.checkValid_();\n  };\n\n  ValidationPath.prototype.pop = function () {\n    var last = this.parts_.pop();\n    this.byteLength_ -= util_2.stringLength(last); // Un-count the previous '/'\n\n    if (this.parts_.length > 0) {\n      this.byteLength_ -= 1;\n    }\n  };\n\n  ValidationPath.prototype.checkValid_ = function () {\n    if (this.byteLength_ > ValidationPath.MAX_PATH_LENGTH_BYTES) {\n      throw new Error(this.errorPrefix_ + 'has a key path longer than ' + ValidationPath.MAX_PATH_LENGTH_BYTES + ' bytes (' + this.byteLength_ + ').');\n    }\n\n    if (this.parts_.length > ValidationPath.MAX_PATH_DEPTH) {\n      throw new Error(this.errorPrefix_ + 'path specified exceeds the maximum depth that can be written (' + ValidationPath.MAX_PATH_DEPTH + ') or object contains a cycle ' + this.toErrorString());\n    }\n  };\n  /**\n   * String for use in error messages - uses '.' notation for path.\n   *\n   * @return {string}\n   */\n\n\n  ValidationPath.prototype.toErrorString = function () {\n    if (this.parts_.length == 0) {\n      return '';\n    }\n\n    return \"in property '\" + this.parts_.join('.') + \"'\";\n  };\n\n  return ValidationPath;\n}();\n\nexports.ValidationPath = ValidationPath;","map":{"version":3,"sources":["../src/core/util/Path.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { nameCompare } from './util';\nimport { stringLength } from '@firebase/util';\n/**\n * An immutable object representing a parsed path.  It's immutable so that you\n * can pass them around to other functions without worrying about them changing\n * it.\n */\n\nexport class Path {\n  private pieces_: string[];\n  private pieceNum_: number;\n\n  /**\n   * Singleton to represent an empty path\n   *\n   * @const\n   */\n  static get Empty() {\n    return new Path('');\n  }\n\n  /**\n   * @param {string|Array.<string>} pathOrString Path string to parse,\n   *      or another path, or the raw tokens array\n   * @param {number=} pieceNum\n   */\n  constructor(pathOrString: string | string[], pieceNum?: number) {\n    if (pieceNum === void 0) {\n      this.pieces_ = (pathOrString as string).split('/');\n\n      // Remove empty pieces.\n      let copyTo = 0;\n      for (let i = 0; i < this.pieces_.length; i++) {\n        if (this.pieces_[i].length > 0) {\n          this.pieces_[copyTo] = this.pieces_[i];\n          copyTo++;\n        }\n      }\n      this.pieces_.length = copyTo;\n\n      this.pieceNum_ = 0;\n    } else {\n      this.pieces_ = pathOrString as string[];\n      this.pieceNum_ = pieceNum;\n    }\n  }\n\n  getFront(): string | null {\n    if (this.pieceNum_ >= this.pieces_.length) return null;\n\n    return this.pieces_[this.pieceNum_];\n  }\n\n  /**\n   * @return {number} The number of segments in this path\n   */\n  getLength(): number {\n    return this.pieces_.length - this.pieceNum_;\n  }\n\n  /**\n   * @return {!Path}\n   */\n  popFront(): Path {\n    let pieceNum = this.pieceNum_;\n    if (pieceNum < this.pieces_.length) {\n      pieceNum++;\n    }\n    return new Path(this.pieces_, pieceNum);\n  }\n\n  /**\n   * @return {?string}\n   */\n  getBack(): string | null {\n    if (this.pieceNum_ < this.pieces_.length)\n      return this.pieces_[this.pieces_.length - 1];\n\n    return null;\n  }\n\n  toString(): string {\n    let pathString = '';\n    for (let i = this.pieceNum_; i < this.pieces_.length; i++) {\n      if (this.pieces_[i] !== '') pathString += '/' + this.pieces_[i];\n    }\n\n    return pathString || '/';\n  }\n\n  toUrlEncodedString(): string {\n    let pathString = '';\n    for (let i = this.pieceNum_; i < this.pieces_.length; i++) {\n      if (this.pieces_[i] !== '')\n        pathString += '/' + encodeURIComponent(String(this.pieces_[i]));\n    }\n\n    return pathString || '/';\n  }\n\n  /**\n   * Shallow copy of the parts of the path.\n   *\n   * @param {number=} begin\n   * @return {!Array<string>}\n   */\n  slice(begin: number = 0): string[] {\n    return this.pieces_.slice(this.pieceNum_ + begin);\n  }\n\n  /**\n   * @return {?Path}\n   */\n  parent(): Path | null {\n    if (this.pieceNum_ >= this.pieces_.length) return null;\n\n    const pieces = [];\n    for (let i = this.pieceNum_; i < this.pieces_.length - 1; i++)\n      pieces.push(this.pieces_[i]);\n\n    return new Path(pieces, 0);\n  }\n\n  /**\n   * @param {string|!Path} childPathObj\n   * @return {!Path}\n   */\n  child(childPathObj: string | Path): Path {\n    const pieces = [];\n    for (let i = this.pieceNum_; i < this.pieces_.length; i++)\n      pieces.push(this.pieces_[i]);\n\n    if (childPathObj instanceof Path) {\n      for (\n        let i = childPathObj.pieceNum_;\n        i < childPathObj.pieces_.length;\n        i++\n      ) {\n        pieces.push(childPathObj.pieces_[i]);\n      }\n    } else {\n      const childPieces = childPathObj.split('/');\n      for (let i = 0; i < childPieces.length; i++) {\n        if (childPieces[i].length > 0) pieces.push(childPieces[i]);\n      }\n    }\n\n    return new Path(pieces, 0);\n  }\n\n  /**\n   * @return {boolean} True if there are no segments in this path\n   */\n  isEmpty(): boolean {\n    return this.pieceNum_ >= this.pieces_.length;\n  }\n\n  /**\n   * @param {!Path} outerPath\n   * @param {!Path} innerPath\n   * @return {!Path} The path from outerPath to innerPath\n   */\n  static relativePath(outerPath: Path, innerPath: Path): Path {\n    const outer = outerPath.getFront(),\n      inner = innerPath.getFront();\n    if (outer === null) {\n      return innerPath;\n    } else if (outer === inner) {\n      return Path.relativePath(outerPath.popFront(), innerPath.popFront());\n    } else {\n      throw new Error(\n        'INTERNAL ERROR: innerPath (' +\n          innerPath +\n          ') is not within ' +\n          'outerPath (' +\n          outerPath +\n          ')'\n      );\n    }\n  }\n\n  /**\n   * @param {!Path} left\n   * @param {!Path} right\n   * @return {number} -1, 0, 1 if left is less, equal, or greater than the right.\n   */\n  static comparePaths(left: Path, right: Path): number {\n    const leftKeys = left.slice();\n    const rightKeys = right.slice();\n    for (let i = 0; i < leftKeys.length && i < rightKeys.length; i++) {\n      const cmp = nameCompare(leftKeys[i], rightKeys[i]);\n      if (cmp !== 0) return cmp;\n    }\n    if (leftKeys.length === rightKeys.length) return 0;\n    return leftKeys.length < rightKeys.length ? -1 : 1;\n  }\n\n  /**\n   *\n   * @param {Path} other\n   * @return {boolean} true if paths are the same.\n   */\n  equals(other: Path): boolean {\n    if (this.getLength() !== other.getLength()) {\n      return false;\n    }\n\n    for (\n      let i = this.pieceNum_, j = other.pieceNum_;\n      i <= this.pieces_.length;\n      i++, j++\n    ) {\n      if (this.pieces_[i] !== other.pieces_[j]) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  /**\n   *\n   * @param {!Path} other\n   * @return {boolean} True if this path is a parent (or the same as) other\n   */\n  contains(other: Path): boolean {\n    let i = this.pieceNum_;\n    let j = other.pieceNum_;\n    if (this.getLength() > other.getLength()) {\n      return false;\n    }\n    while (i < this.pieces_.length) {\n      if (this.pieces_[i] !== other.pieces_[j]) {\n        return false;\n      }\n      ++i;\n      ++j;\n    }\n    return true;\n  }\n} // end Path\n\n/**\n * Dynamic (mutable) path used to count path lengths.\n *\n * This class is used to efficiently check paths for valid\n * length (in UTF8 bytes) and depth (used in path validation).\n *\n * Throws Error exception if path is ever invalid.\n *\n * The definition of a path always begins with '/'.\n */\nexport class ValidationPath {\n  /** @type {!Array<string>} */\n  private parts_: string[];\n  /** @type {number} Initialize to number of '/' chars needed in path. */\n  private byteLength_: number;\n\n  /**\n   * @param {!Path} path Initial Path.\n   * @param {string} errorPrefix_ Prefix for any error messages.\n   */\n  constructor(path: Path, private errorPrefix_: string) {\n    /** @type {!Array<string>} */\n    this.parts_ = path.slice();\n    /** @type {number} Initialize to number of '/' chars needed in path. */\n    this.byteLength_ = Math.max(1, this.parts_.length);\n\n    for (let i = 0; i < this.parts_.length; i++) {\n      this.byteLength_ += stringLength(this.parts_[i]);\n    }\n    this.checkValid_();\n  }\n\n  /** @const {number} Maximum key depth. */\n  static get MAX_PATH_DEPTH() {\n    return 32;\n  }\n\n  /** @const {number} Maximum number of (UTF8) bytes in a Firebase path. */\n  static get MAX_PATH_LENGTH_BYTES() {\n    return 768;\n  }\n\n  /** @param {string} child */\n  push(child: string) {\n    // Count the needed '/'\n    if (this.parts_.length > 0) {\n      this.byteLength_ += 1;\n    }\n    this.parts_.push(child);\n    this.byteLength_ += stringLength(child);\n    this.checkValid_();\n  }\n\n  pop() {\n    const last = this.parts_.pop();\n    this.byteLength_ -= stringLength(last);\n    // Un-count the previous '/'\n    if (this.parts_.length > 0) {\n      this.byteLength_ -= 1;\n    }\n  }\n\n  private checkValid_() {\n    if (this.byteLength_ > ValidationPath.MAX_PATH_LENGTH_BYTES) {\n      throw new Error(\n        this.errorPrefix_ +\n          'has a key path longer than ' +\n          ValidationPath.MAX_PATH_LENGTH_BYTES +\n          ' bytes (' +\n          this.byteLength_ +\n          ').'\n      );\n    }\n    if (this.parts_.length > ValidationPath.MAX_PATH_DEPTH) {\n      throw new Error(\n        this.errorPrefix_ +\n          'path specified exceeds the maximum depth that can be written (' +\n          ValidationPath.MAX_PATH_DEPTH +\n          ') or object contains a cycle ' +\n          this.toErrorString()\n      );\n    }\n  }\n\n  /**\n   * String for use in error messages - uses '.' notation for path.\n   *\n   * @return {string}\n   */\n  toErrorString(): string {\n    if (this.parts_.length == 0) {\n      return '';\n    }\n    return \"in property '\" + this.parts_.join('.') + \"'\";\n  }\n}\n"]},"metadata":{},"sourceType":"script"}