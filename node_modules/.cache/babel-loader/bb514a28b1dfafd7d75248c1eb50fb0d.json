{"ast":null,"code":"\"use strict\";\n\nconst util_1 = require(\"util\");\n\nconst escodegen_1 = require(\"escodegen\");\n\nconst esprima_1 = require(\"esprima\");\n\nconst ast_types_1 = require(\"ast-types\");\n\nconst vm2_1 = require(\"vm2\");\n/**\n * Compiles sync JavaScript code into JavaScript with async Functions.\n *\n * @param {String} code JavaScript string to convert\n * @param {Array} names Array of function names to add `await` operators to\n * @return {String} Converted JavaScript string with async/await injected\n * @api public\n */\n\n\nfunction degenerator(code, _names) {\n  if (!Array.isArray(_names)) {\n    throw new TypeError('an array of async function \"names\" is required');\n  } // Duplicate the `names` array since it's rude to augment the user args\n\n\n  const names = _names.slice(0);\n\n  const ast = esprima_1.parseScript(code); // First pass is to find the `function` nodes and turn them into async or\n  // generator functions only if their body includes `CallExpressions` to\n  // function in `names`. We also add the names of the functions to the `names`\n  // array. We'll iterate several time, as every iteration might add new items\n  // to the `names` array, until no new names were added in the iteration.\n\n  let lastNamesLength = 0;\n\n  do {\n    lastNamesLength = names.length;\n    ast_types_1.visit(ast, {\n      visitVariableDeclaration(path) {\n        if (path.node.declarations) {\n          for (let i = 0; i < path.node.declarations.length; i++) {\n            const declaration = path.node.declarations[i];\n\n            if (ast_types_1.namedTypes.VariableDeclarator.check(declaration) && ast_types_1.namedTypes.Identifier.check(declaration.init) && ast_types_1.namedTypes.Identifier.check(declaration.id) && checkName(declaration.init.name, names) && !checkName(declaration.id.name, names)) {\n              names.push(declaration.id.name);\n            }\n          }\n        }\n\n        return false;\n      },\n\n      visitAssignmentExpression(path) {\n        if (ast_types_1.namedTypes.Identifier.check(path.node.left) && ast_types_1.namedTypes.Identifier.check(path.node.right) && checkName(path.node.right.name, names) && !checkName(path.node.left.name, names)) {\n          names.push(path.node.left.name);\n        }\n\n        return false;\n      },\n\n      visitFunction(path) {\n        if (path.node.id) {\n          let shouldDegenerate = false;\n          ast_types_1.visit(path.node, {\n            visitCallExpression(path) {\n              if (checkNames(path.node, names)) {\n                shouldDegenerate = true;\n              }\n\n              return false;\n            }\n\n          });\n\n          if (!shouldDegenerate) {\n            return false;\n          } // Got a \"function\" expression/statement,\n          // convert it into an async function\n\n\n          path.node.async = true; // Add function name to `names` array\n\n          if (!checkName(path.node.id.name, names)) {\n            names.push(path.node.id.name);\n          }\n        }\n\n        this.traverse(path);\n      }\n\n    });\n  } while (lastNamesLength !== names.length); // Second pass is for adding `await`/`yield` statements to any function\n  // invocations that match the given `names` array.\n\n\n  ast_types_1.visit(ast, {\n    visitCallExpression(path) {\n      if (checkNames(path.node, names)) {\n        // A \"function invocation\" expression,\n        // we need to inject a `AwaitExpression`/`YieldExpression`\n        const delegate = false;\n        const {\n          name,\n          parent: {\n            node: pNode\n          }\n        } = path;\n        const expr = ast_types_1.builders.awaitExpression(path.node, delegate);\n\n        if (ast_types_1.namedTypes.CallExpression.check(pNode)) {\n          pNode.arguments[name] = expr;\n        } else {\n          pNode[name] = expr;\n        }\n      }\n\n      this.traverse(path);\n    }\n\n  });\n  return escodegen_1.generate(ast);\n}\n\n(function (degenerator) {\n  function compile(code, returnName, names, options = {}) {\n    const compiled = degenerator(code, names);\n    const vm = new vm2_1.VM(options);\n    const script = new vm2_1.VMScript(`${compiled};${returnName}`, {\n      filename: options.filename\n    });\n    const fn = vm.run(script);\n\n    if (typeof fn !== 'function') {\n      throw new Error(`Expected a \"function\" to be returned for \\`${returnName}\\`, but got \"${typeof fn}\"`);\n    }\n\n    const r = function (...args) {\n      var _a;\n\n      try {\n        const p = fn.apply(this, args);\n\n        if (typeof ((_a = p) === null || _a === void 0 ? void 0 : _a.then) === 'function') {\n          return p;\n        }\n\n        return Promise.resolve(p);\n      } catch (err) {\n        return Promise.reject(err);\n      }\n    };\n\n    Object.defineProperty(r, 'toString', {\n      value: fn.toString.bind(fn),\n      enumerable: false\n    });\n    return r;\n  }\n\n  degenerator.compile = compile;\n})(degenerator || (degenerator = {}));\n/**\n * Returns `true` if `node` has a matching name to one of the entries in the\n * `names` array.\n *\n * @param {types.Node} node\n * @param {Array} names Array of function names to return true for\n * @return {Boolean}\n * @api private\n */\n\n\nfunction checkNames({\n  callee\n}, names) {\n  let name;\n\n  if (ast_types_1.namedTypes.Identifier.check(callee)) {\n    name = callee.name;\n  } else if (ast_types_1.namedTypes.MemberExpression.check(callee)) {\n    if (ast_types_1.namedTypes.Identifier.check(callee.object) && ast_types_1.namedTypes.Identifier.check(callee.property)) {\n      name = `${callee.object.name}.${callee.property.name}`;\n    } else {\n      return false;\n    }\n  } else if (ast_types_1.namedTypes.FunctionExpression.check(callee)) {\n    if (callee.id) {\n      name = callee.id.name;\n    } else {\n      return false;\n    }\n  } else {\n    throw new Error(`Don't know how to get name for: ${callee.type}`);\n  }\n\n  return checkName(name, names);\n}\n\nfunction checkName(name, names) {\n  // now that we have the `name`, check if any entries match in the `names` array\n  for (let i = 0; i < names.length; i++) {\n    const n = names[i];\n\n    if (util_1.isRegExp(n)) {\n      if (n.test(name)) {\n        return true;\n      }\n    } else if (name === n) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nmodule.exports = degenerator;","map":{"version":3,"sources":["../../src/index.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nconst util_1 = require(\"util\");\nconst escodegen_1 = require(\"escodegen\");\nconst esprima_1 = require(\"esprima\");\nconst ast_types_1 = require(\"ast-types\");\nconst vm2_1 = require(\"vm2\");\n/**\n * Compiles sync JavaScript code into JavaScript with async Functions.\n *\n * @param {String} code JavaScript string to convert\n * @param {Array} names Array of function names to add `await` operators to\n * @return {String} Converted JavaScript string with async/await injected\n * @api public\n */\nfunction degenerator(code, _names) {\n    if (!Array.isArray(_names)) {\n        throw new TypeError('an array of async function \"names\" is required');\n    }\n    // Duplicate the `names` array since it's rude to augment the user args\n    const names = _names.slice(0);\n    const ast = esprima_1.parseScript(code);\n    // First pass is to find the `function` nodes and turn them into async or\n    // generator functions only if their body includes `CallExpressions` to\n    // function in `names`. We also add the names of the functions to the `names`\n    // array. We'll iterate several time, as every iteration might add new items\n    // to the `names` array, until no new names were added in the iteration.\n    let lastNamesLength = 0;\n    do {\n        lastNamesLength = names.length;\n        ast_types_1.visit(ast, {\n            visitVariableDeclaration(path) {\n                if (path.node.declarations) {\n                    for (let i = 0; i < path.node.declarations.length; i++) {\n                        const declaration = path.node.declarations[i];\n                        if (ast_types_1.namedTypes.VariableDeclarator.check(declaration) &&\n                            ast_types_1.namedTypes.Identifier.check(declaration.init) &&\n                            ast_types_1.namedTypes.Identifier.check(declaration.id) &&\n                            checkName(declaration.init.name, names) &&\n                            !checkName(declaration.id.name, names)) {\n                            names.push(declaration.id.name);\n                        }\n                    }\n                }\n                return false;\n            },\n            visitAssignmentExpression(path) {\n                if (ast_types_1.namedTypes.Identifier.check(path.node.left) &&\n                    ast_types_1.namedTypes.Identifier.check(path.node.right) &&\n                    checkName(path.node.right.name, names) &&\n                    !checkName(path.node.left.name, names)) {\n                    names.push(path.node.left.name);\n                }\n                return false;\n            },\n            visitFunction(path) {\n                if (path.node.id) {\n                    let shouldDegenerate = false;\n                    ast_types_1.visit(path.node, {\n                        visitCallExpression(path) {\n                            if (checkNames(path.node, names)) {\n                                shouldDegenerate = true;\n                            }\n                            return false;\n                        },\n                    });\n                    if (!shouldDegenerate) {\n                        return false;\n                    }\n                    // Got a \"function\" expression/statement,\n                    // convert it into an async function\n                    path.node.async = true;\n                    // Add function name to `names` array\n                    if (!checkName(path.node.id.name, names)) {\n                        names.push(path.node.id.name);\n                    }\n                }\n                this.traverse(path);\n            },\n        });\n    } while (lastNamesLength !== names.length);\n    // Second pass is for adding `await`/`yield` statements to any function\n    // invocations that match the given `names` array.\n    ast_types_1.visit(ast, {\n        visitCallExpression(path) {\n            if (checkNames(path.node, names)) {\n                // A \"function invocation\" expression,\n                // we need to inject a `AwaitExpression`/`YieldExpression`\n                const delegate = false;\n                const { name, parent: { node: pNode }, } = path;\n                const expr = ast_types_1.builders.awaitExpression(path.node, delegate);\n                if (ast_types_1.namedTypes.CallExpression.check(pNode)) {\n                    pNode.arguments[name] = expr;\n                }\n                else {\n                    pNode[name] = expr;\n                }\n            }\n            this.traverse(path);\n        },\n    });\n    return escodegen_1.generate(ast);\n}\n(function (degenerator) {\n    function compile(code, returnName, names, options = {}) {\n        const compiled = degenerator(code, names);\n        const vm = new vm2_1.VM(options);\n        const script = new vm2_1.VMScript(`${compiled};${returnName}`, {\n            filename: options.filename,\n        });\n        const fn = vm.run(script);\n        if (typeof fn !== 'function') {\n            throw new Error(`Expected a \"function\" to be returned for \\`${returnName}\\`, but got \"${typeof fn}\"`);\n        }\n        const r = function (...args) {\n            var _a;\n            try {\n                const p = fn.apply(this, args);\n                if (typeof ((_a = p) === null || _a === void 0 ? void 0 : _a.then) === 'function') {\n                    return p;\n                }\n                return Promise.resolve(p);\n            }\n            catch (err) {\n                return Promise.reject(err);\n            }\n        };\n        Object.defineProperty(r, 'toString', {\n            value: fn.toString.bind(fn),\n            enumerable: false,\n        });\n        return r;\n    }\n    degenerator.compile = compile;\n})(degenerator || (degenerator = {}));\n/**\n * Returns `true` if `node` has a matching name to one of the entries in the\n * `names` array.\n *\n * @param {types.Node} node\n * @param {Array} names Array of function names to return true for\n * @return {Boolean}\n * @api private\n */\nfunction checkNames({ callee }, names) {\n    let name;\n    if (ast_types_1.namedTypes.Identifier.check(callee)) {\n        name = callee.name;\n    }\n    else if (ast_types_1.namedTypes.MemberExpression.check(callee)) {\n        if (ast_types_1.namedTypes.Identifier.check(callee.object) &&\n            ast_types_1.namedTypes.Identifier.check(callee.property)) {\n            name = `${callee.object.name}.${callee.property.name}`;\n        }\n        else {\n            return false;\n        }\n    }\n    else if (ast_types_1.namedTypes.FunctionExpression.check(callee)) {\n        if (callee.id) {\n            name = callee.id.name;\n        }\n        else {\n            return false;\n        }\n    }\n    else {\n        throw new Error(`Don't know how to get name for: ${callee.type}`);\n    }\n    return checkName(name, names);\n}\nfunction checkName(name, names) {\n    // now that we have the `name`, check if any entries match in the `names` array\n    for (let i = 0; i < names.length; i++) {\n        const n = names[i];\n        if (util_1.isRegExp(n)) {\n            if (n.test(name)) {\n                return true;\n            }\n        }\n        else if (name === n) {\n            return true;\n        }\n    }\n    return false;\n}\nmodule.exports = degenerator;\n//# sourceMappingURL=index.js.map"]},"metadata":{},"sourceType":"script"}