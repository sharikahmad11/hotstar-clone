{"ast":null,"code":"\"use strict\";\n/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar Path_1 = require(\"./Path\");\n\nvar util_1 = require(\"@firebase/util\");\n\nvar util_2 = require(\"./util\");\n\nvar util_3 = require(\"@firebase/util\");\n\nvar util_4 = require(\"@firebase/util\");\n/**\n * True for invalid Firebase keys\n * @type {RegExp}\n * @private\n */\n\n\nexports.INVALID_KEY_REGEX_ = /[\\[\\].#$\\/\\u0000-\\u001F\\u007F]/;\n/**\n * True for invalid Firebase paths.\n * Allows '/' in paths.\n * @type {RegExp}\n * @private\n */\n\nexports.INVALID_PATH_REGEX_ = /[\\[\\].#$\\u0000-\\u001F\\u007F]/;\n/**\n * Maximum number of characters to allow in leaf value\n * @type {number}\n * @private\n */\n\nexports.MAX_LEAF_SIZE_ = 10 * 1024 * 1024;\n/**\n * @param {*} key\n * @return {boolean}\n */\n\nexports.isValidKey = function (key) {\n  return typeof key === 'string' && key.length !== 0 && !exports.INVALID_KEY_REGEX_.test(key);\n};\n/**\n * @param {string} pathString\n * @return {boolean}\n */\n\n\nexports.isValidPathString = function (pathString) {\n  return typeof pathString === 'string' && pathString.length !== 0 && !exports.INVALID_PATH_REGEX_.test(pathString);\n};\n/**\n * @param {string} pathString\n * @return {boolean}\n */\n\n\nexports.isValidRootPathString = function (pathString) {\n  if (pathString) {\n    // Allow '/.info/' at the beginning.\n    pathString = pathString.replace(/^\\/*\\.info(\\/|$)/, '/');\n  }\n\n  return exports.isValidPathString(pathString);\n};\n/**\n * @param {*} priority\n * @return {boolean}\n */\n\n\nexports.isValidPriority = function (priority) {\n  return priority === null || typeof priority === 'string' || typeof priority === 'number' && !util_2.isInvalidJSONNumber(priority) || priority && typeof priority === 'object' && util_1.contains(priority, '.sv');\n};\n/**\n * Pre-validate a datum passed as an argument to Firebase function.\n *\n * @param {string} fnName\n * @param {number} argumentNumber\n * @param {*} data\n * @param {!Path} path\n * @param {boolean} optional\n */\n\n\nexports.validateFirebaseDataArg = function (fnName, argumentNumber, data, path, optional) {\n  if (optional && data === undefined) return;\n  exports.validateFirebaseData(util_3.errorPrefix(fnName, argumentNumber, optional), data, path);\n};\n/**\n * Validate a data object client-side before sending to server.\n *\n * @param {string} errorPrefix\n * @param {*} data\n * @param {!Path|!ValidationPath} path_\n */\n\n\nexports.validateFirebaseData = function (errorPrefix, data, path_) {\n  var path = path_ instanceof Path_1.Path ? new Path_1.ValidationPath(path_, errorPrefix) : path_;\n\n  if (data === undefined) {\n    throw new Error(errorPrefix + 'contains undefined ' + path.toErrorString());\n  }\n\n  if (typeof data === 'function') {\n    throw new Error(errorPrefix + 'contains a function ' + path.toErrorString() + ' with contents = ' + data.toString());\n  }\n\n  if (util_2.isInvalidJSONNumber(data)) {\n    throw new Error(errorPrefix + 'contains ' + data.toString() + ' ' + path.toErrorString());\n  } // Check max leaf size, but try to avoid the utf8 conversion if we can.\n\n\n  if (typeof data === 'string' && data.length > exports.MAX_LEAF_SIZE_ / 3 && util_4.stringLength(data) > exports.MAX_LEAF_SIZE_) {\n    throw new Error(errorPrefix + 'contains a string greater than ' + exports.MAX_LEAF_SIZE_ + ' utf8 bytes ' + path.toErrorString() + \" ('\" + data.substring(0, 50) + \"...')\");\n  } // TODO = Perf = Consider combining the recursive validation of keys into NodeFromJSON\n  // to save extra walking of large objects.\n\n\n  if (data && typeof data === 'object') {\n    var hasDotValue_1 = false,\n        hasActualChild_1 = false;\n    util_1.forEach(data, function (key, value) {\n      if (key === '.value') {\n        hasDotValue_1 = true;\n      } else if (key !== '.priority' && key !== '.sv') {\n        hasActualChild_1 = true;\n\n        if (!exports.isValidKey(key)) {\n          throw new Error(errorPrefix + ' contains an invalid key (' + key + ') ' + path.toErrorString() + '.  Keys must be non-empty strings ' + 'and can\\'t contain \".\", \"#\", \"$\", \"/\", \"[\", or \"]\"');\n        }\n      }\n\n      path.push(key);\n      exports.validateFirebaseData(errorPrefix, value, path);\n      path.pop();\n    });\n\n    if (hasDotValue_1 && hasActualChild_1) {\n      throw new Error(errorPrefix + ' contains \".value\" child ' + path.toErrorString() + ' in addition to actual children.');\n    }\n  }\n};\n/**\n * Pre-validate paths passed in the firebase function.\n *\n * @param {string} errorPrefix\n * @param {Array<!Path>} mergePaths\n */\n\n\nexports.validateFirebaseMergePaths = function (errorPrefix, mergePaths) {\n  var i, curPath;\n\n  for (i = 0; i < mergePaths.length; i++) {\n    curPath = mergePaths[i];\n    var keys = curPath.slice();\n\n    for (var j = 0; j < keys.length; j++) {\n      if (keys[j] === '.priority' && j === keys.length - 1) {// .priority is OK\n      } else if (!exports.isValidKey(keys[j])) {\n        throw new Error(errorPrefix + 'contains an invalid key (' + keys[j] + ') in path ' + curPath.toString() + '. Keys must be non-empty strings ' + 'and can\\'t contain \".\", \"#\", \"$\", \"/\", \"[\", or \"]\"');\n      }\n    }\n  } // Check that update keys are not descendants of each other.\n  // We rely on the property that sorting guarantees that ancestors come\n  // right before descendants.\n\n\n  mergePaths.sort(Path_1.Path.comparePaths);\n  var prevPath = null;\n\n  for (i = 0; i < mergePaths.length; i++) {\n    curPath = mergePaths[i];\n\n    if (prevPath !== null && prevPath.contains(curPath)) {\n      throw new Error(errorPrefix + 'contains a path ' + prevPath.toString() + ' that is ancestor of another path ' + curPath.toString());\n    }\n\n    prevPath = curPath;\n  }\n};\n/**\n * pre-validate an object passed as an argument to firebase function (\n * must be an object - e.g. for firebase.update()).\n *\n * @param {string} fnName\n * @param {number} argumentNumber\n * @param {*} data\n * @param {!Path} path\n * @param {boolean} optional\n */\n\n\nexports.validateFirebaseMergeDataArg = function (fnName, argumentNumber, data, path, optional) {\n  if (optional && data === undefined) return;\n  var errorPrefix = util_3.errorPrefix(fnName, argumentNumber, optional);\n\n  if (!(data && typeof data === 'object') || Array.isArray(data)) {\n    throw new Error(errorPrefix + ' must be an object containing the children to replace.');\n  }\n\n  var mergePaths = [];\n  util_1.forEach(data, function (key, value) {\n    var curPath = new Path_1.Path(key);\n    exports.validateFirebaseData(errorPrefix, value, path.child(curPath));\n\n    if (curPath.getBack() === '.priority') {\n      if (!exports.isValidPriority(value)) {\n        throw new Error(errorPrefix + \"contains an invalid value for '\" + curPath.toString() + \"', which must be a valid \" + 'Firebase priority (a string, finite number, server value, or null).');\n      }\n    }\n\n    mergePaths.push(curPath);\n  });\n  exports.validateFirebaseMergePaths(errorPrefix, mergePaths);\n};\n\nexports.validatePriority = function (fnName, argumentNumber, priority, optional) {\n  if (optional && priority === undefined) return;\n  if (util_2.isInvalidJSONNumber(priority)) throw new Error(util_3.errorPrefix(fnName, argumentNumber, optional) + 'is ' + priority.toString() + ', but must be a valid Firebase priority (a string, finite number, ' + 'server value, or null).'); // Special case to allow importing data with a .sv.\n\n  if (!exports.isValidPriority(priority)) throw new Error(util_3.errorPrefix(fnName, argumentNumber, optional) + 'must be a valid Firebase priority ' + '(a string, finite number, server value, or null).');\n};\n\nexports.validateEventType = function (fnName, argumentNumber, eventType, optional) {\n  if (optional && eventType === undefined) return;\n\n  switch (eventType) {\n    case 'value':\n    case 'child_added':\n    case 'child_removed':\n    case 'child_changed':\n    case 'child_moved':\n      break;\n\n    default:\n      throw new Error(util_3.errorPrefix(fnName, argumentNumber, optional) + 'must be a valid event type = \"value\", \"child_added\", \"child_removed\", ' + '\"child_changed\", or \"child_moved\".');\n  }\n};\n\nexports.validateKey = function (fnName, argumentNumber, key, optional) {\n  if (optional && key === undefined) return;\n  if (!exports.isValidKey(key)) throw new Error(util_3.errorPrefix(fnName, argumentNumber, optional) + 'was an invalid key = \"' + key + '\".  Firebase keys must be non-empty strings and ' + 'can\\'t contain \".\", \"#\", \"$\", \"/\", \"[\", or \"]\").');\n};\n\nexports.validatePathString = function (fnName, argumentNumber, pathString, optional) {\n  if (optional && pathString === undefined) return;\n  if (!exports.isValidPathString(pathString)) throw new Error(util_3.errorPrefix(fnName, argumentNumber, optional) + 'was an invalid path = \"' + pathString + '\". Paths must be non-empty strings and ' + 'can\\'t contain \".\", \"#\", \"$\", \"[\", or \"]\"');\n};\n\nexports.validateRootPathString = function (fnName, argumentNumber, pathString, optional) {\n  if (pathString) {\n    // Allow '/.info/' at the beginning.\n    pathString = pathString.replace(/^\\/*\\.info(\\/|$)/, '/');\n  }\n\n  exports.validatePathString(fnName, argumentNumber, pathString, optional);\n};\n\nexports.validateWritablePath = function (fnName, path) {\n  if (path.getFront() === '.info') {\n    throw new Error(fnName + \" failed = Can't modify data under /.info/\");\n  }\n};\n\nexports.validateUrl = function (fnName, argumentNumber, parsedUrl) {\n  // TODO = Validate server better.\n  var pathString = parsedUrl.path.toString();\n\n  if (!(typeof parsedUrl.repoInfo.host === 'string') || parsedUrl.repoInfo.host.length === 0 || !exports.isValidKey(parsedUrl.repoInfo.namespace) || pathString.length !== 0 && !exports.isValidRootPathString(pathString)) {\n    throw new Error(util_3.errorPrefix(fnName, argumentNumber, false) + 'must be a valid firebase URL and ' + 'the path can\\'t contain \".\", \"#\", \"$\", \"[\", or \"]\".');\n  }\n};\n\nexports.validateCredential = function (fnName, argumentNumber, cred, optional) {\n  if (optional && cred === undefined) return;\n  if (!(typeof cred === 'string')) throw new Error(util_3.errorPrefix(fnName, argumentNumber, optional) + 'must be a valid credential (a string).');\n};\n\nexports.validateBoolean = function (fnName, argumentNumber, bool, optional) {\n  if (optional && bool === undefined) return;\n  if (typeof bool !== 'boolean') throw new Error(util_3.errorPrefix(fnName, argumentNumber, optional) + 'must be a boolean.');\n};\n\nexports.validateString = function (fnName, argumentNumber, string, optional) {\n  if (optional && string === undefined) return;\n\n  if (!(typeof string === 'string')) {\n    throw new Error(util_3.errorPrefix(fnName, argumentNumber, optional) + 'must be a valid string.');\n  }\n};\n\nexports.validateObject = function (fnName, argumentNumber, obj, optional) {\n  if (optional && obj === undefined) return;\n\n  if (!(obj && typeof obj === 'object') || obj === null) {\n    throw new Error(util_3.errorPrefix(fnName, argumentNumber, optional) + 'must be a valid object.');\n  }\n};\n\nexports.validateObjectContainsKey = function (fnName, argumentNumber, obj, key, optional, opt_type) {\n  var objectContainsKey = obj && typeof obj === 'object' && util_1.contains(obj, key);\n\n  if (!objectContainsKey) {\n    if (optional) {\n      return;\n    } else {\n      throw new Error(util_3.errorPrefix(fnName, argumentNumber, optional) + 'must contain the key \"' + key + '\"');\n    }\n  }\n\n  if (opt_type) {\n    var val = util_1.safeGet(obj, key);\n\n    if (opt_type === 'number' && !(typeof val === 'number') || opt_type === 'string' && !(typeof val === 'string') || opt_type === 'boolean' && !(typeof val === 'boolean') || opt_type === 'function' && !(typeof val === 'function') || opt_type === 'object' && !(typeof val === 'object') && val) {\n      if (optional) {\n        throw new Error(util_3.errorPrefix(fnName, argumentNumber, optional) + 'contains invalid value for key \"' + key + '\" (must be of type \"' + opt_type + '\")');\n      } else {\n        throw new Error(util_3.errorPrefix(fnName, argumentNumber, optional) + 'must contain the key \"' + key + '\" with type \"' + opt_type + '\"');\n      }\n    }\n  }\n};","map":{"version":3,"sources":["../src/core/util/validation.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { Path, ValidationPath } from './Path';\nimport { forEach, contains, safeGet } from '@firebase/util';\nimport { isInvalidJSONNumber } from './util';\nimport { errorPrefix as errorPrefixFxn } from '@firebase/util';\nimport { stringLength } from '@firebase/util';\nimport { RepoInfo } from '../RepoInfo';\n\n/**\n * True for invalid Firebase keys\n * @type {RegExp}\n * @private\n */\nexport const INVALID_KEY_REGEX_ = /[\\[\\].#$\\/\\u0000-\\u001F\\u007F]/;\n\n/**\n * True for invalid Firebase paths.\n * Allows '/' in paths.\n * @type {RegExp}\n * @private\n */\nexport const INVALID_PATH_REGEX_ = /[\\[\\].#$\\u0000-\\u001F\\u007F]/;\n\n/**\n * Maximum number of characters to allow in leaf value\n * @type {number}\n * @private\n */\nexport const MAX_LEAF_SIZE_ = 10 * 1024 * 1024;\n\n/**\n * @param {*} key\n * @return {boolean}\n */\nexport const isValidKey = function(key: any): boolean {\n  return (\n    typeof key === 'string' && key.length !== 0 && !INVALID_KEY_REGEX_.test(key)\n  );\n};\n\n/**\n * @param {string} pathString\n * @return {boolean}\n */\nexport const isValidPathString = function(pathString: string): boolean {\n  return (\n    typeof pathString === 'string' &&\n    pathString.length !== 0 &&\n    !INVALID_PATH_REGEX_.test(pathString)\n  );\n};\n\n/**\n * @param {string} pathString\n * @return {boolean}\n */\nexport const isValidRootPathString = function(pathString: string): boolean {\n  if (pathString) {\n    // Allow '/.info/' at the beginning.\n    pathString = pathString.replace(/^\\/*\\.info(\\/|$)/, '/');\n  }\n\n  return isValidPathString(pathString);\n};\n\n/**\n * @param {*} priority\n * @return {boolean}\n */\nexport const isValidPriority = function(priority: any): boolean {\n  return (\n    priority === null ||\n    typeof priority === 'string' ||\n    (typeof priority === 'number' && !isInvalidJSONNumber(priority)) ||\n    (priority && typeof priority === 'object' && contains(priority, '.sv'))\n  );\n};\n\n/**\n * Pre-validate a datum passed as an argument to Firebase function.\n *\n * @param {string} fnName\n * @param {number} argumentNumber\n * @param {*} data\n * @param {!Path} path\n * @param {boolean} optional\n */\nexport const validateFirebaseDataArg = function(\n  fnName: string,\n  argumentNumber: number,\n  data: any,\n  path: Path,\n  optional: boolean\n) {\n  if (optional && data === undefined) return;\n\n  validateFirebaseData(\n    errorPrefixFxn(fnName, argumentNumber, optional),\n    data,\n    path\n  );\n};\n\n/**\n * Validate a data object client-side before sending to server.\n *\n * @param {string} errorPrefix\n * @param {*} data\n * @param {!Path|!ValidationPath} path_\n */\nexport const validateFirebaseData = function(\n  errorPrefix: string,\n  data: any,\n  path_: Path | ValidationPath\n) {\n  const path =\n    path_ instanceof Path ? new ValidationPath(path_, errorPrefix) : path_;\n\n  if (data === undefined) {\n    throw new Error(errorPrefix + 'contains undefined ' + path.toErrorString());\n  }\n  if (typeof data === 'function') {\n    throw new Error(\n      errorPrefix +\n        'contains a function ' +\n        path.toErrorString() +\n        ' with contents = ' +\n        data.toString()\n    );\n  }\n  if (isInvalidJSONNumber(data)) {\n    throw new Error(\n      errorPrefix + 'contains ' + data.toString() + ' ' + path.toErrorString()\n    );\n  }\n\n  // Check max leaf size, but try to avoid the utf8 conversion if we can.\n  if (\n    typeof data === 'string' &&\n    data.length > MAX_LEAF_SIZE_ / 3 &&\n    stringLength(data) > MAX_LEAF_SIZE_\n  ) {\n    throw new Error(\n      errorPrefix +\n        'contains a string greater than ' +\n        MAX_LEAF_SIZE_ +\n        ' utf8 bytes ' +\n        path.toErrorString() +\n        \" ('\" +\n        data.substring(0, 50) +\n        \"...')\"\n    );\n  }\n\n  // TODO = Perf = Consider combining the recursive validation of keys into NodeFromJSON\n  // to save extra walking of large objects.\n  if (data && typeof data === 'object') {\n    let hasDotValue = false,\n      hasActualChild = false;\n    forEach(data, function(key: string, value: any) {\n      if (key === '.value') {\n        hasDotValue = true;\n      } else if (key !== '.priority' && key !== '.sv') {\n        hasActualChild = true;\n        if (!isValidKey(key)) {\n          throw new Error(\n            errorPrefix +\n              ' contains an invalid key (' +\n              key +\n              ') ' +\n              path.toErrorString() +\n              '.  Keys must be non-empty strings ' +\n              'and can\\'t contain \".\", \"#\", \"$\", \"/\", \"[\", or \"]\"'\n          );\n        }\n      }\n\n      path.push(key);\n      validateFirebaseData(errorPrefix, value, path);\n      path.pop();\n    });\n\n    if (hasDotValue && hasActualChild) {\n      throw new Error(\n        errorPrefix +\n          ' contains \".value\" child ' +\n          path.toErrorString() +\n          ' in addition to actual children.'\n      );\n    }\n  }\n};\n\n/**\n * Pre-validate paths passed in the firebase function.\n *\n * @param {string} errorPrefix\n * @param {Array<!Path>} mergePaths\n */\nexport const validateFirebaseMergePaths = function(\n  errorPrefix: string,\n  mergePaths: Path[]\n) {\n  let i, curPath;\n  for (i = 0; i < mergePaths.length; i++) {\n    curPath = mergePaths[i];\n    const keys = curPath.slice();\n    for (let j = 0; j < keys.length; j++) {\n      if (keys[j] === '.priority' && j === keys.length - 1) {\n        // .priority is OK\n      } else if (!isValidKey(keys[j])) {\n        throw new Error(\n          errorPrefix +\n            'contains an invalid key (' +\n            keys[j] +\n            ') in path ' +\n            curPath.toString() +\n            '. Keys must be non-empty strings ' +\n            'and can\\'t contain \".\", \"#\", \"$\", \"/\", \"[\", or \"]\"'\n        );\n      }\n    }\n  }\n\n  // Check that update keys are not descendants of each other.\n  // We rely on the property that sorting guarantees that ancestors come\n  // right before descendants.\n  mergePaths.sort(Path.comparePaths);\n  let prevPath: Path | null = null;\n  for (i = 0; i < mergePaths.length; i++) {\n    curPath = mergePaths[i];\n    if (prevPath !== null && prevPath.contains(curPath)) {\n      throw new Error(\n        errorPrefix +\n          'contains a path ' +\n          prevPath.toString() +\n          ' that is ancestor of another path ' +\n          curPath.toString()\n      );\n    }\n    prevPath = curPath;\n  }\n};\n\n/**\n * pre-validate an object passed as an argument to firebase function (\n * must be an object - e.g. for firebase.update()).\n *\n * @param {string} fnName\n * @param {number} argumentNumber\n * @param {*} data\n * @param {!Path} path\n * @param {boolean} optional\n */\nexport const validateFirebaseMergeDataArg = function(\n  fnName: string,\n  argumentNumber: number,\n  data: any,\n  path: Path,\n  optional: boolean\n) {\n  if (optional && data === undefined) return;\n\n  const errorPrefix = errorPrefixFxn(fnName, argumentNumber, optional);\n\n  if (!(data && typeof data === 'object') || Array.isArray(data)) {\n    throw new Error(\n      errorPrefix + ' must be an object containing the children to replace.'\n    );\n  }\n\n  const mergePaths: Path[] = [];\n  forEach(data, function(key: string, value: any) {\n    const curPath = new Path(key);\n    validateFirebaseData(errorPrefix, value, path.child(curPath));\n    if (curPath.getBack() === '.priority') {\n      if (!isValidPriority(value)) {\n        throw new Error(\n          errorPrefix +\n            \"contains an invalid value for '\" +\n            curPath.toString() +\n            \"', which must be a valid \" +\n            'Firebase priority (a string, finite number, server value, or null).'\n        );\n      }\n    }\n    mergePaths.push(curPath);\n  });\n  validateFirebaseMergePaths(errorPrefix, mergePaths);\n};\n\nexport const validatePriority = function(\n  fnName: string,\n  argumentNumber: number,\n  priority: any,\n  optional: boolean\n) {\n  if (optional && priority === undefined) return;\n  if (isInvalidJSONNumber(priority))\n    throw new Error(\n      errorPrefixFxn(fnName, argumentNumber, optional) +\n        'is ' +\n        priority.toString() +\n        ', but must be a valid Firebase priority (a string, finite number, ' +\n        'server value, or null).'\n    );\n  // Special case to allow importing data with a .sv.\n  if (!isValidPriority(priority))\n    throw new Error(\n      errorPrefixFxn(fnName, argumentNumber, optional) +\n        'must be a valid Firebase priority ' +\n        '(a string, finite number, server value, or null).'\n    );\n};\n\nexport const validateEventType = function(\n  fnName: string,\n  argumentNumber: number,\n  eventType: string,\n  optional: boolean\n) {\n  if (optional && eventType === undefined) return;\n\n  switch (eventType) {\n    case 'value':\n    case 'child_added':\n    case 'child_removed':\n    case 'child_changed':\n    case 'child_moved':\n      break;\n    default:\n      throw new Error(\n        errorPrefixFxn(fnName, argumentNumber, optional) +\n          'must be a valid event type = \"value\", \"child_added\", \"child_removed\", ' +\n          '\"child_changed\", or \"child_moved\".'\n      );\n  }\n};\n\nexport const validateKey = function(\n  fnName: string,\n  argumentNumber: number,\n  key: string,\n  optional: boolean\n) {\n  if (optional && key === undefined) return;\n  if (!isValidKey(key))\n    throw new Error(\n      errorPrefixFxn(fnName, argumentNumber, optional) +\n        'was an invalid key = \"' +\n        key +\n        '\".  Firebase keys must be non-empty strings and ' +\n        'can\\'t contain \".\", \"#\", \"$\", \"/\", \"[\", or \"]\").'\n    );\n};\n\nexport const validatePathString = function(\n  fnName: string,\n  argumentNumber: number,\n  pathString: string,\n  optional: boolean\n) {\n  if (optional && pathString === undefined) return;\n\n  if (!isValidPathString(pathString))\n    throw new Error(\n      errorPrefixFxn(fnName, argumentNumber, optional) +\n        'was an invalid path = \"' +\n        pathString +\n        '\". Paths must be non-empty strings and ' +\n        'can\\'t contain \".\", \"#\", \"$\", \"[\", or \"]\"'\n    );\n};\n\nexport const validateRootPathString = function(\n  fnName: string,\n  argumentNumber: number,\n  pathString: string,\n  optional: boolean\n) {\n  if (pathString) {\n    // Allow '/.info/' at the beginning.\n    pathString = pathString.replace(/^\\/*\\.info(\\/|$)/, '/');\n  }\n\n  validatePathString(fnName, argumentNumber, pathString, optional);\n};\n\nexport const validateWritablePath = function(fnName: string, path: Path) {\n  if (path.getFront() === '.info') {\n    throw new Error(fnName + \" failed = Can't modify data under /.info/\");\n  }\n};\n\nexport const validateUrl = function(\n  fnName: string,\n  argumentNumber: number,\n  parsedUrl: { repoInfo: RepoInfo; path: Path }\n) {\n  // TODO = Validate server better.\n  const pathString = parsedUrl.path.toString();\n  if (\n    !(typeof parsedUrl.repoInfo.host === 'string') ||\n    parsedUrl.repoInfo.host.length === 0 ||\n    !isValidKey(parsedUrl.repoInfo.namespace) ||\n    (pathString.length !== 0 && !isValidRootPathString(pathString))\n  ) {\n    throw new Error(\n      errorPrefixFxn(fnName, argumentNumber, false) +\n        'must be a valid firebase URL and ' +\n        'the path can\\'t contain \".\", \"#\", \"$\", \"[\", or \"]\".'\n    );\n  }\n};\n\nexport const validateCredential = function(\n  fnName: string,\n  argumentNumber: number,\n  cred: any,\n  optional: boolean\n) {\n  if (optional && cred === undefined) return;\n  if (!(typeof cred === 'string'))\n    throw new Error(\n      errorPrefixFxn(fnName, argumentNumber, optional) +\n        'must be a valid credential (a string).'\n    );\n};\n\nexport const validateBoolean = function(\n  fnName: string,\n  argumentNumber: number,\n  bool: any,\n  optional: boolean\n) {\n  if (optional && bool === undefined) return;\n  if (typeof bool !== 'boolean')\n    throw new Error(\n      errorPrefixFxn(fnName, argumentNumber, optional) + 'must be a boolean.'\n    );\n};\n\nexport const validateString = function(\n  fnName: string,\n  argumentNumber: number,\n  string: any,\n  optional: boolean\n) {\n  if (optional && string === undefined) return;\n  if (!(typeof string === 'string')) {\n    throw new Error(\n      errorPrefixFxn(fnName, argumentNumber, optional) +\n        'must be a valid string.'\n    );\n  }\n};\n\nexport const validateObject = function(\n  fnName: string,\n  argumentNumber: number,\n  obj: any,\n  optional: boolean\n) {\n  if (optional && obj === undefined) return;\n  if (!(obj && typeof obj === 'object') || obj === null) {\n    throw new Error(\n      errorPrefixFxn(fnName, argumentNumber, optional) +\n        'must be a valid object.'\n    );\n  }\n};\n\nexport const validateObjectContainsKey = function(\n  fnName: string,\n  argumentNumber: number,\n  obj: any,\n  key: string,\n  optional: boolean,\n  opt_type?: string\n) {\n  const objectContainsKey =\n    obj && typeof obj === 'object' && contains(obj, key);\n\n  if (!objectContainsKey) {\n    if (optional) {\n      return;\n    } else {\n      throw new Error(\n        errorPrefixFxn(fnName, argumentNumber, optional) +\n          'must contain the key \"' +\n          key +\n          '\"'\n      );\n    }\n  }\n\n  if (opt_type) {\n    const val = safeGet(obj, key);\n    if (\n      (opt_type === 'number' && !(typeof val === 'number')) ||\n      (opt_type === 'string' && !(typeof val === 'string')) ||\n      (opt_type === 'boolean' && !(typeof val === 'boolean')) ||\n      (opt_type === 'function' && !(typeof val === 'function')) ||\n      (opt_type === 'object' && !(typeof val === 'object') && val)\n    ) {\n      if (optional) {\n        throw new Error(\n          errorPrefixFxn(fnName, argumentNumber, optional) +\n            'contains invalid value for key \"' +\n            key +\n            '\" (must be of type \"' +\n            opt_type +\n            '\")'\n        );\n      } else {\n        throw new Error(\n          errorPrefixFxn(fnName, argumentNumber, optional) +\n            'must contain the key \"' +\n            key +\n            '\" with type \"' +\n            opt_type +\n            '\"'\n        );\n      }\n    }\n  }\n};\n"]},"metadata":{},"sourceType":"script"}