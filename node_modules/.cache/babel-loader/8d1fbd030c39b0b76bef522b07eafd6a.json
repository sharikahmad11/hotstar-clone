{"ast":null,"code":"\"use strict\";\n/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar util_1 = require(\"@firebase/util\");\n/**\n * Base class to be used if you want to emit events. Call the constructor with\n * the set of allowed event names.\n */\n\n\nvar EventEmitter =\n/** @class */\nfunction () {\n  /**\n   * @param {!Array.<string>} allowedEvents_\n   */\n  function EventEmitter(allowedEvents_) {\n    this.allowedEvents_ = allowedEvents_;\n    this.listeners_ = {};\n    util_1.assert(Array.isArray(allowedEvents_) && allowedEvents_.length > 0, 'Requires a non-empty array');\n  }\n  /**\n   * To be called by derived classes to trigger events.\n   * @param {!string} eventType\n   * @param {...*} var_args\n   */\n\n\n  EventEmitter.prototype.trigger = function (eventType) {\n    var var_args = [];\n\n    for (var _i = 1; _i < arguments.length; _i++) {\n      var_args[_i - 1] = arguments[_i];\n    }\n\n    if (Array.isArray(this.listeners_[eventType])) {\n      // Clone the list, since callbacks could add/remove listeners.\n      var listeners = this.listeners_[eventType].slice();\n\n      for (var i = 0; i < listeners.length; i++) {\n        listeners[i].callback.apply(listeners[i].context, var_args);\n      }\n    }\n  };\n\n  EventEmitter.prototype.on = function (eventType, callback, context) {\n    this.validateEventType_(eventType);\n    this.listeners_[eventType] = this.listeners_[eventType] || [];\n    this.listeners_[eventType].push({\n      callback: callback,\n      context: context\n    });\n    var eventData = this.getInitialEvent(eventType);\n\n    if (eventData) {\n      callback.apply(context, eventData);\n    }\n  };\n\n  EventEmitter.prototype.off = function (eventType, callback, context) {\n    this.validateEventType_(eventType);\n    var listeners = this.listeners_[eventType] || [];\n\n    for (var i = 0; i < listeners.length; i++) {\n      if (listeners[i].callback === callback && (!context || context === listeners[i].context)) {\n        listeners.splice(i, 1);\n        return;\n      }\n    }\n  };\n\n  EventEmitter.prototype.validateEventType_ = function (eventType) {\n    util_1.assert(this.allowedEvents_.find(function (et) {\n      return et === eventType;\n    }), 'Unknown event: ' + eventType);\n  };\n\n  return EventEmitter;\n}();\n\nexports.EventEmitter = EventEmitter;","map":{"version":3,"sources":["../src/core/util/EventEmitter.ts"],"names":[],"mappings":";AAAA;;;;;;;;;;;;;;AAcG;;;;;;AAEH,IAAA,MAAA,GAAA,OAAA,CAAA,gBAAA,CAAA;AAEA;;;AAGG;;;AACH,IAAA,YAAA;AAAA;AAAA,YAAA;AAQE;;AAEG;AACH,WAAA,YAAA,CAAoB,cAApB,EAAiD;AAA7B,SAAA,cAAA,GAAA,cAAA;AAVZ,SAAA,UAAA,GAKJ,EALI;AAWN,IAAA,MAAA,CAAA,MAAA,CACE,KAAK,CAAC,OAAN,CAAc,cAAd,KAAiC,cAAc,CAAC,MAAf,GAAwB,CAD3D,EAEE,4BAFF;AAID;AAWD;;;;AAIG;;;AACO,EAAA,YAAA,CAAA,SAAA,CAAA,OAAA,GAAV,UAAkB,SAAlB,EAAmC;AAAE,QAAA,QAAA,GAAA,EAAA;;SAAA,IAAA,EAAA,GAAA,C,EAAA,EAAA,GAAA,SAAA,CAAA,M,EAAA,EAAA,E,EAAkB;AAAlB,MAAA,QAAA,CAAA,EAAA,GAAA,CAAA,CAAA,GAAA,SAAA,CAAA,EAAA,CAAA;;;AACnC,QAAI,KAAK,CAAC,OAAN,CAAc,KAAK,UAAL,CAAgB,SAAhB,CAAd,CAAJ,EAA+C;AAC7C;AACA,UAAM,SAAS,GAAO,KAAK,UAAL,CAAgB,SAAhB,EAA0B,KAA1B,EAAtB;;AAEA,WAAK,IAAI,CAAC,GAAG,CAAb,EAAgB,CAAC,GAAG,SAAS,CAAC,MAA9B,EAAsC,CAAC,EAAvC,EAA2C;AACzC,QAAA,SAAS,CAAC,CAAD,CAAT,CAAa,QAAb,CAAsB,KAAtB,CAA4B,SAAS,CAAC,CAAD,CAAT,CAAa,OAAzC,EAAkD,QAAlD;AACD;AACF;AACF,GATS;;AAWV,EAAA,YAAA,CAAA,SAAA,CAAA,EAAA,GAAA,UAAG,SAAH,EAAsB,QAAtB,EAAkD,OAAlD,EAA8D;AAC5D,SAAK,kBAAL,CAAwB,SAAxB;AACA,SAAK,UAAL,CAAgB,SAAhB,IAA6B,KAAK,UAAL,CAAgB,SAAhB,KAA8B,EAA3D;AACA,SAAK,UAAL,CAAgB,SAAhB,EAA2B,IAA3B,CAAgC;AAAE,MAAA,QAAQ,EAAA,QAAV;AAAY,MAAA,OAAO,EAAA;AAAnB,KAAhC;AAEA,QAAM,SAAS,GAAG,KAAK,eAAL,CAAqB,SAArB,CAAlB;;AACA,QAAI,SAAJ,EAAe;AACb,MAAA,QAAQ,CAAC,KAAT,CAAe,OAAf,EAAwB,SAAxB;AACD;AACF,GATD;;AAWA,EAAA,YAAA,CAAA,SAAA,CAAA,GAAA,GAAA,UAAI,SAAJ,EAAuB,QAAvB,EAAmD,OAAnD,EAA+D;AAC7D,SAAK,kBAAL,CAAwB,SAAxB;AACA,QAAM,SAAS,GAAG,KAAK,UAAL,CAAgB,SAAhB,KAA8B,EAAhD;;AACA,SAAK,IAAI,CAAC,GAAG,CAAb,EAAgB,CAAC,GAAG,SAAS,CAAC,MAA9B,EAAsC,CAAC,EAAvC,EAA2C;AACzC,UACE,SAAS,CAAC,CAAD,CAAT,CAAa,QAAb,KAA0B,QAA1B,KACC,CAAC,OAAD,IAAY,OAAO,KAAK,SAAS,CAAC,CAAD,CAAT,CAAa,OADtC,CADF,EAGE;AACA,QAAA,SAAS,CAAC,MAAV,CAAiB,CAAjB,EAAoB,CAApB;AACA;AACD;AACF;AACF,GAZD;;AAcQ,EAAA,YAAA,CAAA,SAAA,CAAA,kBAAA,GAAR,UAA2B,SAA3B,EAA4C;AAC1C,IAAA,MAAA,CAAA,MAAA,CACE,KAAK,cAAL,CAAoB,IAApB,CAAyB,UAAS,EAAT,EAAW;AAClC,aAAO,EAAE,KAAK,SAAd;AACD,KAFD,CADF,EAIE,oBAAoB,SAJtB;AAMD,GAPO;;AAQV,SAAA,YAAA;AAAC,CA5ED,EAAA;;AAAsB,OAAA,CAAA,YAAA,GAAA,YAAA","sourcesContent":["/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { assert } from '@firebase/util';\n\n/**\n * Base class to be used if you want to emit events. Call the constructor with\n * the set of allowed event names.\n */\nexport abstract class EventEmitter {\n  private listeners_: {\n    [eventType: string]: Array<{\n      callback(...args: any[]): void;\n      context: any;\n    }>;\n  } = {};\n\n  /**\n   * @param {!Array.<string>} allowedEvents_\n   */\n  constructor(private allowedEvents_: Array<string>) {\n    assert(\n      Array.isArray(allowedEvents_) && allowedEvents_.length > 0,\n      'Requires a non-empty array'\n    );\n  }\n\n  /**\n   * To be overridden by derived classes in order to fire an initial event when\n   * somebody subscribes for data.\n   *\n   * @param {!string} eventType\n   * @return {Array.<*>} Array of parameters to trigger initial event with.\n   */\n  abstract getInitialEvent(eventType: string): any[];\n\n  /**\n   * To be called by derived classes to trigger events.\n   * @param {!string} eventType\n   * @param {...*} var_args\n   */\n  protected trigger(eventType: string, ...var_args: any[]) {\n    if (Array.isArray(this.listeners_[eventType])) {\n      // Clone the list, since callbacks could add/remove listeners.\n      const listeners = [...this.listeners_[eventType]];\n\n      for (let i = 0; i < listeners.length; i++) {\n        listeners[i].callback.apply(listeners[i].context, var_args);\n      }\n    }\n  }\n\n  on(eventType: string, callback: (a: any) => void, context: any) {\n    this.validateEventType_(eventType);\n    this.listeners_[eventType] = this.listeners_[eventType] || [];\n    this.listeners_[eventType].push({ callback, context });\n\n    const eventData = this.getInitialEvent(eventType);\n    if (eventData) {\n      callback.apply(context, eventData);\n    }\n  }\n\n  off(eventType: string, callback: (a: any) => void, context: any) {\n    this.validateEventType_(eventType);\n    const listeners = this.listeners_[eventType] || [];\n    for (let i = 0; i < listeners.length; i++) {\n      if (\n        listeners[i].callback === callback &&\n        (!context || context === listeners[i].context)\n      ) {\n        listeners.splice(i, 1);\n        return;\n      }\n    }\n  }\n\n  private validateEventType_(eventType: string) {\n    assert(\n      this.allowedEvents_.find(function(et) {\n        return et === eventType;\n      }),\n      'Unknown event: ' + eventType\n    );\n  }\n}\n"]},"metadata":{},"sourceType":"script"}