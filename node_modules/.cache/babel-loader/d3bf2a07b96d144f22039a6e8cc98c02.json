{"ast":null,"code":"\"use strict\";\n/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar Operation_1 = require(\"../operation/Operation\");\n\nvar util_1 = require(\"@firebase/util\");\n\nvar ChildChangeAccumulator_1 = require(\"./ChildChangeAccumulator\");\n\nvar Change_1 = require(\"./Change\");\n\nvar ChildrenNode_1 = require(\"../snap/ChildrenNode\");\n\nvar KeyIndex_1 = require(\"../snap/indexes/KeyIndex\");\n\nvar ImmutableTree_1 = require(\"../util/ImmutableTree\");\n\nvar Path_1 = require(\"../util/Path\");\n\nvar CompleteChildSource_1 = require(\"./CompleteChildSource\");\n/**\n * @constructor\n * @struct\n */\n\n\nvar ProcessorResult =\n/** @class */\nfunction () {\n  /**\n   * @param {!ViewCache} viewCache\n   * @param {!Array.<!Change>} changes\n   */\n  function ProcessorResult(viewCache, changes) {\n    this.viewCache = viewCache;\n    this.changes = changes;\n  }\n\n  return ProcessorResult;\n}();\n\nexports.ProcessorResult = ProcessorResult;\n/**\n * @constructor\n */\n\nvar ViewProcessor =\n/** @class */\nfunction () {\n  /**\n   * @param {!NodeFilter} filter_\n   */\n  function ViewProcessor(filter_) {\n    this.filter_ = filter_;\n  }\n  /**\n   * @param {!ViewCache} viewCache\n   */\n\n\n  ViewProcessor.prototype.assertIndexed = function (viewCache) {\n    util_1.assert(viewCache.getEventCache().getNode().isIndexed(this.filter_.getIndex()), 'Event snap not indexed');\n    util_1.assert(viewCache.getServerCache().getNode().isIndexed(this.filter_.getIndex()), 'Server snap not indexed');\n  };\n  /**\n   * @param {!ViewCache} oldViewCache\n   * @param {!Operation} operation\n   * @param {!WriteTreeRef} writesCache\n   * @param {?Node} completeCache\n   * @return {!ProcessorResult}\n   */\n\n\n  ViewProcessor.prototype.applyOperation = function (oldViewCache, operation, writesCache, completeCache) {\n    var accumulator = new ChildChangeAccumulator_1.ChildChangeAccumulator();\n    var newViewCache, filterServerNode;\n\n    if (operation.type === Operation_1.OperationType.OVERWRITE) {\n      var overwrite = operation;\n\n      if (overwrite.source.fromUser) {\n        newViewCache = this.applyUserOverwrite_(oldViewCache, overwrite.path, overwrite.snap, writesCache, completeCache, accumulator);\n      } else {\n        util_1.assert(overwrite.source.fromServer, 'Unknown source.'); // We filter the node if it's a tagged update or the node has been previously filtered  and the\n        // update is not at the root in which case it is ok (and necessary) to mark the node unfiltered\n        // again\n\n        filterServerNode = overwrite.source.tagged || oldViewCache.getServerCache().isFiltered() && !overwrite.path.isEmpty();\n        newViewCache = this.applyServerOverwrite_(oldViewCache, overwrite.path, overwrite.snap, writesCache, completeCache, filterServerNode, accumulator);\n      }\n    } else if (operation.type === Operation_1.OperationType.MERGE) {\n      var merge = operation;\n\n      if (merge.source.fromUser) {\n        newViewCache = this.applyUserMerge_(oldViewCache, merge.path, merge.children, writesCache, completeCache, accumulator);\n      } else {\n        util_1.assert(merge.source.fromServer, 'Unknown source.'); // We filter the node if it's a tagged update or the node has been previously filtered\n\n        filterServerNode = merge.source.tagged || oldViewCache.getServerCache().isFiltered();\n        newViewCache = this.applyServerMerge_(oldViewCache, merge.path, merge.children, writesCache, completeCache, filterServerNode, accumulator);\n      }\n    } else if (operation.type === Operation_1.OperationType.ACK_USER_WRITE) {\n      var ackUserWrite = operation;\n\n      if (!ackUserWrite.revert) {\n        newViewCache = this.ackUserWrite_(oldViewCache, ackUserWrite.path, ackUserWrite.affectedTree, writesCache, completeCache, accumulator);\n      } else {\n        newViewCache = this.revertUserWrite_(oldViewCache, ackUserWrite.path, writesCache, completeCache, accumulator);\n      }\n    } else if (operation.type === Operation_1.OperationType.LISTEN_COMPLETE) {\n      newViewCache = this.listenComplete_(oldViewCache, operation.path, writesCache, accumulator);\n    } else {\n      throw util_1.assertionError('Unknown operation type: ' + operation.type);\n    }\n\n    var changes = accumulator.getChanges();\n    ViewProcessor.maybeAddValueEvent_(oldViewCache, newViewCache, changes);\n    return new ProcessorResult(newViewCache, changes);\n  };\n  /**\n   * @param {!ViewCache} oldViewCache\n   * @param {!ViewCache} newViewCache\n   * @param {!Array.<!Change>} accumulator\n   * @private\n   */\n\n\n  ViewProcessor.maybeAddValueEvent_ = function (oldViewCache, newViewCache, accumulator) {\n    var eventSnap = newViewCache.getEventCache();\n\n    if (eventSnap.isFullyInitialized()) {\n      var isLeafOrEmpty = eventSnap.getNode().isLeafNode() || eventSnap.getNode().isEmpty();\n      var oldCompleteSnap = oldViewCache.getCompleteEventSnap();\n\n      if (accumulator.length > 0 || !oldViewCache.getEventCache().isFullyInitialized() || isLeafOrEmpty && !eventSnap.getNode().equals(\n      /** @type {!Node} */\n      oldCompleteSnap) || !eventSnap.getNode().getPriority().equals(oldCompleteSnap.getPriority())) {\n        accumulator.push(Change_1.Change.valueChange(\n        /** @type {!Node} */\n        newViewCache.getCompleteEventSnap()));\n      }\n    }\n  };\n  /**\n   * @param {!ViewCache} viewCache\n   * @param {!Path} changePath\n   * @param {!WriteTreeRef} writesCache\n   * @param {!CompleteChildSource} source\n   * @param {!ChildChangeAccumulator} accumulator\n   * @return {!ViewCache}\n   * @private\n   */\n\n\n  ViewProcessor.prototype.generateEventCacheAfterServerEvent_ = function (viewCache, changePath, writesCache, source, accumulator) {\n    var oldEventSnap = viewCache.getEventCache();\n\n    if (writesCache.shadowingWrite(changePath) != null) {\n      // we have a shadowing write, ignore changes\n      return viewCache;\n    } else {\n      var newEventCache = void 0,\n          serverNode = void 0;\n\n      if (changePath.isEmpty()) {\n        // TODO: figure out how this plays with \"sliding ack windows\"\n        util_1.assert(viewCache.getServerCache().isFullyInitialized(), 'If change path is empty, we must have complete server data');\n\n        if (viewCache.getServerCache().isFiltered()) {\n          // We need to special case this, because we need to only apply writes to complete children, or\n          // we might end up raising events for incomplete children. If the server data is filtered deep\n          // writes cannot be guaranteed to be complete\n          var serverCache = viewCache.getCompleteServerSnap();\n          var completeChildren = serverCache instanceof ChildrenNode_1.ChildrenNode ? serverCache : ChildrenNode_1.ChildrenNode.EMPTY_NODE;\n          var completeEventChildren = writesCache.calcCompleteEventChildren(completeChildren);\n          newEventCache = this.filter_.updateFullNode(viewCache.getEventCache().getNode(), completeEventChildren, accumulator);\n        } else {\n          var completeNode = writesCache.calcCompleteEventCache(viewCache.getCompleteServerSnap());\n          newEventCache = this.filter_.updateFullNode(viewCache.getEventCache().getNode(), completeNode, accumulator);\n        }\n      } else {\n        var childKey = changePath.getFront();\n\n        if (childKey == '.priority') {\n          util_1.assert(changePath.getLength() == 1, \"Can't have a priority with additional path components\");\n          var oldEventNode = oldEventSnap.getNode();\n          serverNode = viewCache.getServerCache().getNode(); // we might have overwrites for this priority\n\n          var updatedPriority = writesCache.calcEventCacheAfterServerOverwrite(changePath, oldEventNode, serverNode);\n\n          if (updatedPriority != null) {\n            newEventCache = this.filter_.updatePriority(oldEventNode, updatedPriority);\n          } else {\n            // priority didn't change, keep old node\n            newEventCache = oldEventSnap.getNode();\n          }\n        } else {\n          var childChangePath = changePath.popFront(); // update child\n\n          var newEventChild = void 0;\n\n          if (oldEventSnap.isCompleteForChild(childKey)) {\n            serverNode = viewCache.getServerCache().getNode();\n            var eventChildUpdate = writesCache.calcEventCacheAfterServerOverwrite(changePath, oldEventSnap.getNode(), serverNode);\n\n            if (eventChildUpdate != null) {\n              newEventChild = oldEventSnap.getNode().getImmediateChild(childKey).updateChild(childChangePath, eventChildUpdate);\n            } else {\n              // Nothing changed, just keep the old child\n              newEventChild = oldEventSnap.getNode().getImmediateChild(childKey);\n            }\n          } else {\n            newEventChild = writesCache.calcCompleteChild(childKey, viewCache.getServerCache());\n          }\n\n          if (newEventChild != null) {\n            newEventCache = this.filter_.updateChild(oldEventSnap.getNode(), childKey, newEventChild, childChangePath, source, accumulator);\n          } else {\n            // no complete child available or no change\n            newEventCache = oldEventSnap.getNode();\n          }\n        }\n      }\n\n      return viewCache.updateEventSnap(newEventCache, oldEventSnap.isFullyInitialized() || changePath.isEmpty(), this.filter_.filtersNodes());\n    }\n  };\n  /**\n   * @param {!ViewCache} oldViewCache\n   * @param {!Path} changePath\n   * @param {!Node} changedSnap\n   * @param {!WriteTreeRef} writesCache\n   * @param {?Node} completeCache\n   * @param {boolean} filterServerNode\n   * @param {!ChildChangeAccumulator} accumulator\n   * @return {!ViewCache}\n   * @private\n   */\n\n\n  ViewProcessor.prototype.applyServerOverwrite_ = function (oldViewCache, changePath, changedSnap, writesCache, completeCache, filterServerNode, accumulator) {\n    var oldServerSnap = oldViewCache.getServerCache();\n    var newServerCache;\n    var serverFilter = filterServerNode ? this.filter_ : this.filter_.getIndexedFilter();\n\n    if (changePath.isEmpty()) {\n      newServerCache = serverFilter.updateFullNode(oldServerSnap.getNode(), changedSnap, null);\n    } else if (serverFilter.filtersNodes() && !oldServerSnap.isFiltered()) {\n      // we want to filter the server node, but we didn't filter the server node yet, so simulate a full update\n      var newServerNode = oldServerSnap.getNode().updateChild(changePath, changedSnap);\n      newServerCache = serverFilter.updateFullNode(oldServerSnap.getNode(), newServerNode, null);\n    } else {\n      var childKey = changePath.getFront();\n\n      if (!oldServerSnap.isCompleteForPath(changePath) && changePath.getLength() > 1) {\n        // We don't update incomplete nodes with updates intended for other listeners\n        return oldViewCache;\n      }\n\n      var childChangePath = changePath.popFront();\n      var childNode = oldServerSnap.getNode().getImmediateChild(childKey);\n      var newChildNode = childNode.updateChild(childChangePath, changedSnap);\n\n      if (childKey == '.priority') {\n        newServerCache = serverFilter.updatePriority(oldServerSnap.getNode(), newChildNode);\n      } else {\n        newServerCache = serverFilter.updateChild(oldServerSnap.getNode(), childKey, newChildNode, childChangePath, CompleteChildSource_1.NO_COMPLETE_CHILD_SOURCE, null);\n      }\n    }\n\n    var newViewCache = oldViewCache.updateServerSnap(newServerCache, oldServerSnap.isFullyInitialized() || changePath.isEmpty(), serverFilter.filtersNodes());\n    var source = new CompleteChildSource_1.WriteTreeCompleteChildSource(writesCache, newViewCache, completeCache);\n    return this.generateEventCacheAfterServerEvent_(newViewCache, changePath, writesCache, source, accumulator);\n  };\n  /**\n   * @param {!ViewCache} oldViewCache\n   * @param {!Path} changePath\n   * @param {!Node} changedSnap\n   * @param {!WriteTreeRef} writesCache\n   * @param {?Node} completeCache\n   * @param {!ChildChangeAccumulator} accumulator\n   * @return {!ViewCache}\n   * @private\n   */\n\n\n  ViewProcessor.prototype.applyUserOverwrite_ = function (oldViewCache, changePath, changedSnap, writesCache, completeCache, accumulator) {\n    var oldEventSnap = oldViewCache.getEventCache();\n    var newViewCache, newEventCache;\n    var source = new CompleteChildSource_1.WriteTreeCompleteChildSource(writesCache, oldViewCache, completeCache);\n\n    if (changePath.isEmpty()) {\n      newEventCache = this.filter_.updateFullNode(oldViewCache.getEventCache().getNode(), changedSnap, accumulator);\n      newViewCache = oldViewCache.updateEventSnap(newEventCache, true, this.filter_.filtersNodes());\n    } else {\n      var childKey = changePath.getFront();\n\n      if (childKey === '.priority') {\n        newEventCache = this.filter_.updatePriority(oldViewCache.getEventCache().getNode(), changedSnap);\n        newViewCache = oldViewCache.updateEventSnap(newEventCache, oldEventSnap.isFullyInitialized(), oldEventSnap.isFiltered());\n      } else {\n        var childChangePath = changePath.popFront();\n        var oldChild = oldEventSnap.getNode().getImmediateChild(childKey);\n        var newChild = void 0;\n\n        if (childChangePath.isEmpty()) {\n          // Child overwrite, we can replace the child\n          newChild = changedSnap;\n        } else {\n          var childNode = source.getCompleteChild(childKey);\n\n          if (childNode != null) {\n            if (childChangePath.getBack() === '.priority' && childNode.getChild(childChangePath.parent()).isEmpty()) {\n              // This is a priority update on an empty node. If this node exists on the server, the\n              // server will send down the priority in the update, so ignore for now\n              newChild = childNode;\n            } else {\n              newChild = childNode.updateChild(childChangePath, changedSnap);\n            }\n          } else {\n            // There is no complete child node available\n            newChild = ChildrenNode_1.ChildrenNode.EMPTY_NODE;\n          }\n        }\n\n        if (!oldChild.equals(newChild)) {\n          var newEventSnap = this.filter_.updateChild(oldEventSnap.getNode(), childKey, newChild, childChangePath, source, accumulator);\n          newViewCache = oldViewCache.updateEventSnap(newEventSnap, oldEventSnap.isFullyInitialized(), this.filter_.filtersNodes());\n        } else {\n          newViewCache = oldViewCache;\n        }\n      }\n    }\n\n    return newViewCache;\n  };\n  /**\n   * @param {!ViewCache} viewCache\n   * @param {string} childKey\n   * @return {boolean}\n   * @private\n   */\n\n\n  ViewProcessor.cacheHasChild_ = function (viewCache, childKey) {\n    return viewCache.getEventCache().isCompleteForChild(childKey);\n  };\n  /**\n   * @param {!ViewCache} viewCache\n   * @param {!Path} path\n   * @param {ImmutableTree.<!Node>} changedChildren\n   * @param {!WriteTreeRef} writesCache\n   * @param {?Node} serverCache\n   * @param {!ChildChangeAccumulator} accumulator\n   * @return {!ViewCache}\n   * @private\n   */\n\n\n  ViewProcessor.prototype.applyUserMerge_ = function (viewCache, path, changedChildren, writesCache, serverCache, accumulator) {\n    var _this = this; // HACK: In the case of a limit query, there may be some changes that bump things out of the\n    // window leaving room for new items.  It's important we process these changes first, so we\n    // iterate the changes twice, first processing any that affect items currently in view.\n    // TODO: I consider an item \"in view\" if cacheHasChild is true, which checks both the server\n    // and event snap.  I'm not sure if this will result in edge cases when a child is in one but\n    // not the other.\n\n\n    var curViewCache = viewCache;\n    changedChildren.foreach(function (relativePath, childNode) {\n      var writePath = path.child(relativePath);\n\n      if (ViewProcessor.cacheHasChild_(viewCache, writePath.getFront())) {\n        curViewCache = _this.applyUserOverwrite_(curViewCache, writePath, childNode, writesCache, serverCache, accumulator);\n      }\n    });\n    changedChildren.foreach(function (relativePath, childNode) {\n      var writePath = path.child(relativePath);\n\n      if (!ViewProcessor.cacheHasChild_(viewCache, writePath.getFront())) {\n        curViewCache = _this.applyUserOverwrite_(curViewCache, writePath, childNode, writesCache, serverCache, accumulator);\n      }\n    });\n    return curViewCache;\n  };\n  /**\n   * @param {!Node} node\n   * @param {ImmutableTree.<!Node>} merge\n   * @return {!Node}\n   * @private\n   */\n\n\n  ViewProcessor.prototype.applyMerge_ = function (node, merge) {\n    merge.foreach(function (relativePath, childNode) {\n      node = node.updateChild(relativePath, childNode);\n    });\n    return node;\n  };\n  /**\n   * @param {!ViewCache} viewCache\n   * @param {!Path} path\n   * @param {!ImmutableTree.<!Node>} changedChildren\n   * @param {!WriteTreeRef} writesCache\n   * @param {?Node} serverCache\n   * @param {boolean} filterServerNode\n   * @param {!ChildChangeAccumulator} accumulator\n   * @return {!ViewCache}\n   * @private\n   */\n\n\n  ViewProcessor.prototype.applyServerMerge_ = function (viewCache, path, changedChildren, writesCache, serverCache, filterServerNode, accumulator) {\n    var _this = this; // If we don't have a cache yet, this merge was intended for a previously listen in the same location. Ignore it and\n    // wait for the complete data update coming soon.\n\n\n    if (viewCache.getServerCache().getNode().isEmpty() && !viewCache.getServerCache().isFullyInitialized()) {\n      return viewCache;\n    } // HACK: In the case of a limit query, there may be some changes that bump things out of the\n    // window leaving room for new items.  It's important we process these changes first, so we\n    // iterate the changes twice, first processing any that affect items currently in view.\n    // TODO: I consider an item \"in view\" if cacheHasChild is true, which checks both the server\n    // and event snap.  I'm not sure if this will result in edge cases when a child is in one but\n    // not the other.\n\n\n    var curViewCache = viewCache;\n    var viewMergeTree;\n\n    if (path.isEmpty()) {\n      viewMergeTree = changedChildren;\n    } else {\n      viewMergeTree = ImmutableTree_1.ImmutableTree.Empty.setTree(path, changedChildren);\n    }\n\n    var serverNode = viewCache.getServerCache().getNode();\n    viewMergeTree.children.inorderTraversal(function (childKey, childTree) {\n      if (serverNode.hasChild(childKey)) {\n        var serverChild = viewCache.getServerCache().getNode().getImmediateChild(childKey);\n\n        var newChild = _this.applyMerge_(serverChild, childTree);\n\n        curViewCache = _this.applyServerOverwrite_(curViewCache, new Path_1.Path(childKey), newChild, writesCache, serverCache, filterServerNode, accumulator);\n      }\n    });\n    viewMergeTree.children.inorderTraversal(function (childKey, childMergeTree) {\n      var isUnknownDeepMerge = !viewCache.getServerCache().isCompleteForChild(childKey) && childMergeTree.value == null;\n\n      if (!serverNode.hasChild(childKey) && !isUnknownDeepMerge) {\n        var serverChild = viewCache.getServerCache().getNode().getImmediateChild(childKey);\n\n        var newChild = _this.applyMerge_(serverChild, childMergeTree);\n\n        curViewCache = _this.applyServerOverwrite_(curViewCache, new Path_1.Path(childKey), newChild, writesCache, serverCache, filterServerNode, accumulator);\n      }\n    });\n    return curViewCache;\n  };\n  /**\n   * @param {!ViewCache} viewCache\n   * @param {!Path} ackPath\n   * @param {!ImmutableTree<!boolean>} affectedTree\n   * @param {!WriteTreeRef} writesCache\n   * @param {?Node} completeCache\n   * @param {!ChildChangeAccumulator} accumulator\n   * @return {!ViewCache}\n   * @private\n   */\n\n\n  ViewProcessor.prototype.ackUserWrite_ = function (viewCache, ackPath, affectedTree, writesCache, completeCache, accumulator) {\n    if (writesCache.shadowingWrite(ackPath) != null) {\n      return viewCache;\n    } // Only filter server node if it is currently filtered\n\n\n    var filterServerNode = viewCache.getServerCache().isFiltered(); // Essentially we'll just get our existing server cache for the affected paths and re-apply it as a server update\n    // now that it won't be shadowed.\n\n    var serverCache = viewCache.getServerCache();\n\n    if (affectedTree.value != null) {\n      // This is an overwrite.\n      if (ackPath.isEmpty() && serverCache.isFullyInitialized() || serverCache.isCompleteForPath(ackPath)) {\n        return this.applyServerOverwrite_(viewCache, ackPath, serverCache.getNode().getChild(ackPath), writesCache, completeCache, filterServerNode, accumulator);\n      } else if (ackPath.isEmpty()) {\n        // This is a goofy edge case where we are acking data at this location but don't have full data.  We\n        // should just re-apply whatever we have in our cache as a merge.\n        var changedChildren_1 = ImmutableTree_1.ImmutableTree.Empty;\n        serverCache.getNode().forEachChild(KeyIndex_1.KEY_INDEX, function (name, node) {\n          changedChildren_1 = changedChildren_1.set(new Path_1.Path(name), node);\n        });\n        return this.applyServerMerge_(viewCache, ackPath, changedChildren_1, writesCache, completeCache, filterServerNode, accumulator);\n      } else {\n        return viewCache;\n      }\n    } else {\n      // This is a merge.\n      var changedChildren_2 = ImmutableTree_1.ImmutableTree.Empty;\n      affectedTree.foreach(function (mergePath, value) {\n        var serverCachePath = ackPath.child(mergePath);\n\n        if (serverCache.isCompleteForPath(serverCachePath)) {\n          changedChildren_2 = changedChildren_2.set(mergePath, serverCache.getNode().getChild(serverCachePath));\n        }\n      });\n      return this.applyServerMerge_(viewCache, ackPath, changedChildren_2, writesCache, completeCache, filterServerNode, accumulator);\n    }\n  };\n  /**\n   * @param {!ViewCache} viewCache\n   * @param {!Path} path\n   * @param {!WriteTreeRef} writesCache\n   * @param {!ChildChangeAccumulator} accumulator\n   * @return {!ViewCache}\n   * @private\n   */\n\n\n  ViewProcessor.prototype.listenComplete_ = function (viewCache, path, writesCache, accumulator) {\n    var oldServerNode = viewCache.getServerCache();\n    var newViewCache = viewCache.updateServerSnap(oldServerNode.getNode(), oldServerNode.isFullyInitialized() || path.isEmpty(), oldServerNode.isFiltered());\n    return this.generateEventCacheAfterServerEvent_(newViewCache, path, writesCache, CompleteChildSource_1.NO_COMPLETE_CHILD_SOURCE, accumulator);\n  };\n  /**\n   * @param {!ViewCache} viewCache\n   * @param {!Path} path\n   * @param {!WriteTreeRef} writesCache\n   * @param {?Node} completeServerCache\n   * @param {!ChildChangeAccumulator} accumulator\n   * @return {!ViewCache}\n   * @private\n   */\n\n\n  ViewProcessor.prototype.revertUserWrite_ = function (viewCache, path, writesCache, completeServerCache, accumulator) {\n    var complete;\n\n    if (writesCache.shadowingWrite(path) != null) {\n      return viewCache;\n    } else {\n      var source = new CompleteChildSource_1.WriteTreeCompleteChildSource(writesCache, viewCache, completeServerCache);\n      var oldEventCache = viewCache.getEventCache().getNode();\n      var newEventCache = void 0;\n\n      if (path.isEmpty() || path.getFront() === '.priority') {\n        var newNode = void 0;\n\n        if (viewCache.getServerCache().isFullyInitialized()) {\n          newNode = writesCache.calcCompleteEventCache(viewCache.getCompleteServerSnap());\n        } else {\n          var serverChildren = viewCache.getServerCache().getNode();\n          util_1.assert(serverChildren instanceof ChildrenNode_1.ChildrenNode, 'serverChildren would be complete if leaf node');\n          newNode = writesCache.calcCompleteEventChildren(serverChildren);\n        }\n\n        newNode = newNode;\n        newEventCache = this.filter_.updateFullNode(oldEventCache, newNode, accumulator);\n      } else {\n        var childKey = path.getFront();\n        var newChild = writesCache.calcCompleteChild(childKey, viewCache.getServerCache());\n\n        if (newChild == null && viewCache.getServerCache().isCompleteForChild(childKey)) {\n          newChild = oldEventCache.getImmediateChild(childKey);\n        }\n\n        if (newChild != null) {\n          newEventCache = this.filter_.updateChild(oldEventCache, childKey, newChild, path.popFront(), source, accumulator);\n        } else if (viewCache.getEventCache().getNode().hasChild(childKey)) {\n          // No complete child available, delete the existing one, if any\n          newEventCache = this.filter_.updateChild(oldEventCache, childKey, ChildrenNode_1.ChildrenNode.EMPTY_NODE, path.popFront(), source, accumulator);\n        } else {\n          newEventCache = oldEventCache;\n        }\n\n        if (newEventCache.isEmpty() && viewCache.getServerCache().isFullyInitialized()) {\n          // We might have reverted all child writes. Maybe the old event was a leaf node\n          complete = writesCache.calcCompleteEventCache(viewCache.getCompleteServerSnap());\n\n          if (complete.isLeafNode()) {\n            newEventCache = this.filter_.updateFullNode(newEventCache, complete, accumulator);\n          }\n        }\n      }\n\n      complete = viewCache.getServerCache().isFullyInitialized() || writesCache.shadowingWrite(Path_1.Path.Empty) != null;\n      return viewCache.updateEventSnap(newEventCache, complete, this.filter_.filtersNodes());\n    }\n  };\n\n  return ViewProcessor;\n}();\n\nexports.ViewProcessor = ViewProcessor;","map":{"version":3,"sources":["../src/core/view/ViewProcessor.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { Operation, OperationType } from '../operation/Operation';\nimport { assert, assertionError } from '@firebase/util';\nimport { ChildChangeAccumulator } from './ChildChangeAccumulator';\nimport { Change } from './Change';\nimport { ChildrenNode } from '../snap/ChildrenNode';\nimport { KEY_INDEX } from '../snap/indexes/KeyIndex';\nimport { ImmutableTree } from '../util/ImmutableTree';\nimport { Path } from '../util/Path';\nimport {\n  WriteTreeCompleteChildSource,\n  NO_COMPLETE_CHILD_SOURCE,\n  CompleteChildSource\n} from './CompleteChildSource';\nimport { ViewCache } from './ViewCache';\nimport { NodeFilter } from './filter/NodeFilter';\nimport { WriteTreeRef } from '../WriteTree';\nimport { Overwrite } from '../operation/Overwrite';\nimport { Merge } from '../operation/Merge';\nimport { AckUserWrite } from '../operation/AckUserWrite';\nimport { Node } from '../snap/Node';\n\n/**\n * @constructor\n * @struct\n */\nexport class ProcessorResult {\n  /**\n   * @param {!ViewCache} viewCache\n   * @param {!Array.<!Change>} changes\n   */\n  constructor(\n    public readonly viewCache: ViewCache,\n    public readonly changes: Change[]\n  ) {}\n}\n\n/**\n * @constructor\n */\nexport class ViewProcessor {\n  /**\n   * @param {!NodeFilter} filter_\n   */\n  constructor(private readonly filter_: NodeFilter) {}\n\n  /**\n   * @param {!ViewCache} viewCache\n   */\n  assertIndexed(viewCache: ViewCache) {\n    assert(\n      viewCache\n        .getEventCache()\n        .getNode()\n        .isIndexed(this.filter_.getIndex()),\n      'Event snap not indexed'\n    );\n    assert(\n      viewCache\n        .getServerCache()\n        .getNode()\n        .isIndexed(this.filter_.getIndex()),\n      'Server snap not indexed'\n    );\n  }\n\n  /**\n   * @param {!ViewCache} oldViewCache\n   * @param {!Operation} operation\n   * @param {!WriteTreeRef} writesCache\n   * @param {?Node} completeCache\n   * @return {!ProcessorResult}\n   */\n  applyOperation(\n    oldViewCache: ViewCache,\n    operation: Operation,\n    writesCache: WriteTreeRef,\n    completeCache: Node | null\n  ): ProcessorResult {\n    const accumulator = new ChildChangeAccumulator();\n    let newViewCache, filterServerNode;\n    if (operation.type === OperationType.OVERWRITE) {\n      const overwrite = operation as Overwrite;\n      if (overwrite.source.fromUser) {\n        newViewCache = this.applyUserOverwrite_(\n          oldViewCache,\n          overwrite.path,\n          overwrite.snap,\n          writesCache,\n          completeCache,\n          accumulator\n        );\n      } else {\n        assert(overwrite.source.fromServer, 'Unknown source.');\n        // We filter the node if it's a tagged update or the node has been previously filtered  and the\n        // update is not at the root in which case it is ok (and necessary) to mark the node unfiltered\n        // again\n        filterServerNode =\n          overwrite.source.tagged ||\n          (oldViewCache.getServerCache().isFiltered() &&\n            !overwrite.path.isEmpty());\n        newViewCache = this.applyServerOverwrite_(\n          oldViewCache,\n          overwrite.path,\n          overwrite.snap,\n          writesCache,\n          completeCache,\n          filterServerNode,\n          accumulator\n        );\n      }\n    } else if (operation.type === OperationType.MERGE) {\n      const merge = operation as Merge;\n      if (merge.source.fromUser) {\n        newViewCache = this.applyUserMerge_(\n          oldViewCache,\n          merge.path,\n          merge.children,\n          writesCache,\n          completeCache,\n          accumulator\n        );\n      } else {\n        assert(merge.source.fromServer, 'Unknown source.');\n        // We filter the node if it's a tagged update or the node has been previously filtered\n        filterServerNode =\n          merge.source.tagged || oldViewCache.getServerCache().isFiltered();\n        newViewCache = this.applyServerMerge_(\n          oldViewCache,\n          merge.path,\n          merge.children,\n          writesCache,\n          completeCache,\n          filterServerNode,\n          accumulator\n        );\n      }\n    } else if (operation.type === OperationType.ACK_USER_WRITE) {\n      const ackUserWrite = operation as AckUserWrite;\n      if (!ackUserWrite.revert) {\n        newViewCache = this.ackUserWrite_(\n          oldViewCache,\n          ackUserWrite.path,\n          ackUserWrite.affectedTree,\n          writesCache,\n          completeCache,\n          accumulator\n        );\n      } else {\n        newViewCache = this.revertUserWrite_(\n          oldViewCache,\n          ackUserWrite.path,\n          writesCache,\n          completeCache,\n          accumulator\n        );\n      }\n    } else if (operation.type === OperationType.LISTEN_COMPLETE) {\n      newViewCache = this.listenComplete_(\n        oldViewCache,\n        operation.path,\n        writesCache,\n        accumulator\n      );\n    } else {\n      throw assertionError('Unknown operation type: ' + operation.type);\n    }\n    const changes = accumulator.getChanges();\n    ViewProcessor.maybeAddValueEvent_(oldViewCache, newViewCache, changes);\n    return new ProcessorResult(newViewCache, changes);\n  }\n\n  /**\n   * @param {!ViewCache} oldViewCache\n   * @param {!ViewCache} newViewCache\n   * @param {!Array.<!Change>} accumulator\n   * @private\n   */\n  private static maybeAddValueEvent_(\n    oldViewCache: ViewCache,\n    newViewCache: ViewCache,\n    accumulator: Change[]\n  ) {\n    const eventSnap = newViewCache.getEventCache();\n    if (eventSnap.isFullyInitialized()) {\n      const isLeafOrEmpty =\n        eventSnap.getNode().isLeafNode() || eventSnap.getNode().isEmpty();\n      const oldCompleteSnap = oldViewCache.getCompleteEventSnap();\n      if (\n        accumulator.length > 0 ||\n        !oldViewCache.getEventCache().isFullyInitialized() ||\n        (isLeafOrEmpty &&\n          !eventSnap\n            .getNode()\n            .equals(/** @type {!Node} */ (oldCompleteSnap))) ||\n        !eventSnap\n          .getNode()\n          .getPriority()\n          .equals(oldCompleteSnap.getPriority())\n      ) {\n        accumulator.push(\n          Change.valueChange(\n            /** @type {!Node} */ newViewCache.getCompleteEventSnap()\n          )\n        );\n      }\n    }\n  }\n\n  /**\n   * @param {!ViewCache} viewCache\n   * @param {!Path} changePath\n   * @param {!WriteTreeRef} writesCache\n   * @param {!CompleteChildSource} source\n   * @param {!ChildChangeAccumulator} accumulator\n   * @return {!ViewCache}\n   * @private\n   */\n  private generateEventCacheAfterServerEvent_(\n    viewCache: ViewCache,\n    changePath: Path,\n    writesCache: WriteTreeRef,\n    source: CompleteChildSource,\n    accumulator: ChildChangeAccumulator\n  ): ViewCache {\n    const oldEventSnap = viewCache.getEventCache();\n    if (writesCache.shadowingWrite(changePath) != null) {\n      // we have a shadowing write, ignore changes\n      return viewCache;\n    } else {\n      let newEventCache, serverNode;\n      if (changePath.isEmpty()) {\n        // TODO: figure out how this plays with \"sliding ack windows\"\n        assert(\n          viewCache.getServerCache().isFullyInitialized(),\n          'If change path is empty, we must have complete server data'\n        );\n        if (viewCache.getServerCache().isFiltered()) {\n          // We need to special case this, because we need to only apply writes to complete children, or\n          // we might end up raising events for incomplete children. If the server data is filtered deep\n          // writes cannot be guaranteed to be complete\n          const serverCache = viewCache.getCompleteServerSnap();\n          const completeChildren =\n            serverCache instanceof ChildrenNode\n              ? serverCache\n              : ChildrenNode.EMPTY_NODE;\n          const completeEventChildren = writesCache.calcCompleteEventChildren(\n            completeChildren\n          );\n          newEventCache = this.filter_.updateFullNode(\n            viewCache.getEventCache().getNode(),\n            completeEventChildren,\n            accumulator\n          );\n        } else {\n          const completeNode = writesCache.calcCompleteEventCache(\n            viewCache.getCompleteServerSnap()\n          );\n          newEventCache = this.filter_.updateFullNode(\n            viewCache.getEventCache().getNode(),\n            completeNode,\n            accumulator\n          );\n        }\n      } else {\n        const childKey = changePath.getFront();\n        if (childKey == '.priority') {\n          assert(\n            changePath.getLength() == 1,\n            \"Can't have a priority with additional path components\"\n          );\n          const oldEventNode = oldEventSnap.getNode();\n          serverNode = viewCache.getServerCache().getNode();\n          // we might have overwrites for this priority\n          const updatedPriority = writesCache.calcEventCacheAfterServerOverwrite(\n            changePath,\n            oldEventNode,\n            serverNode\n          );\n          if (updatedPriority != null) {\n            newEventCache = this.filter_.updatePriority(\n              oldEventNode,\n              updatedPriority\n            );\n          } else {\n            // priority didn't change, keep old node\n            newEventCache = oldEventSnap.getNode();\n          }\n        } else {\n          const childChangePath = changePath.popFront();\n          // update child\n          let newEventChild;\n          if (oldEventSnap.isCompleteForChild(childKey)) {\n            serverNode = viewCache.getServerCache().getNode();\n            const eventChildUpdate = writesCache.calcEventCacheAfterServerOverwrite(\n              changePath,\n              oldEventSnap.getNode(),\n              serverNode\n            );\n            if (eventChildUpdate != null) {\n              newEventChild = oldEventSnap\n                .getNode()\n                .getImmediateChild(childKey)\n                .updateChild(childChangePath, eventChildUpdate);\n            } else {\n              // Nothing changed, just keep the old child\n              newEventChild = oldEventSnap\n                .getNode()\n                .getImmediateChild(childKey);\n            }\n          } else {\n            newEventChild = writesCache.calcCompleteChild(\n              childKey,\n              viewCache.getServerCache()\n            );\n          }\n          if (newEventChild != null) {\n            newEventCache = this.filter_.updateChild(\n              oldEventSnap.getNode(),\n              childKey,\n              newEventChild,\n              childChangePath,\n              source,\n              accumulator\n            );\n          } else {\n            // no complete child available or no change\n            newEventCache = oldEventSnap.getNode();\n          }\n        }\n      }\n      return viewCache.updateEventSnap(\n        newEventCache,\n        oldEventSnap.isFullyInitialized() || changePath.isEmpty(),\n        this.filter_.filtersNodes()\n      );\n    }\n  }\n\n  /**\n   * @param {!ViewCache} oldViewCache\n   * @param {!Path} changePath\n   * @param {!Node} changedSnap\n   * @param {!WriteTreeRef} writesCache\n   * @param {?Node} completeCache\n   * @param {boolean} filterServerNode\n   * @param {!ChildChangeAccumulator} accumulator\n   * @return {!ViewCache}\n   * @private\n   */\n  applyServerOverwrite_(\n    oldViewCache: ViewCache,\n    changePath: Path,\n    changedSnap: Node,\n    writesCache: WriteTreeRef,\n    completeCache: Node | null,\n    filterServerNode: boolean,\n    accumulator: ChildChangeAccumulator\n  ): ViewCache {\n    const oldServerSnap = oldViewCache.getServerCache();\n    let newServerCache;\n    const serverFilter = filterServerNode\n      ? this.filter_\n      : this.filter_.getIndexedFilter();\n    if (changePath.isEmpty()) {\n      newServerCache = serverFilter.updateFullNode(\n        oldServerSnap.getNode(),\n        changedSnap,\n        null\n      );\n    } else if (serverFilter.filtersNodes() && !oldServerSnap.isFiltered()) {\n      // we want to filter the server node, but we didn't filter the server node yet, so simulate a full update\n      const newServerNode = oldServerSnap\n        .getNode()\n        .updateChild(changePath, changedSnap);\n      newServerCache = serverFilter.updateFullNode(\n        oldServerSnap.getNode(),\n        newServerNode,\n        null\n      );\n    } else {\n      const childKey = changePath.getFront();\n      if (\n        !oldServerSnap.isCompleteForPath(changePath) &&\n        changePath.getLength() > 1\n      ) {\n        // We don't update incomplete nodes with updates intended for other listeners\n        return oldViewCache;\n      }\n      const childChangePath = changePath.popFront();\n      const childNode = oldServerSnap.getNode().getImmediateChild(childKey);\n      const newChildNode = childNode.updateChild(childChangePath, changedSnap);\n      if (childKey == '.priority') {\n        newServerCache = serverFilter.updatePriority(\n          oldServerSnap.getNode(),\n          newChildNode\n        );\n      } else {\n        newServerCache = serverFilter.updateChild(\n          oldServerSnap.getNode(),\n          childKey,\n          newChildNode,\n          childChangePath,\n          NO_COMPLETE_CHILD_SOURCE,\n          null\n        );\n      }\n    }\n    const newViewCache = oldViewCache.updateServerSnap(\n      newServerCache,\n      oldServerSnap.isFullyInitialized() || changePath.isEmpty(),\n      serverFilter.filtersNodes()\n    );\n    const source = new WriteTreeCompleteChildSource(\n      writesCache,\n      newViewCache,\n      completeCache\n    );\n    return this.generateEventCacheAfterServerEvent_(\n      newViewCache,\n      changePath,\n      writesCache,\n      source,\n      accumulator\n    );\n  }\n\n  /**\n   * @param {!ViewCache} oldViewCache\n   * @param {!Path} changePath\n   * @param {!Node} changedSnap\n   * @param {!WriteTreeRef} writesCache\n   * @param {?Node} completeCache\n   * @param {!ChildChangeAccumulator} accumulator\n   * @return {!ViewCache}\n   * @private\n   */\n  applyUserOverwrite_(\n    oldViewCache: ViewCache,\n    changePath: Path,\n    changedSnap: Node,\n    writesCache: WriteTreeRef,\n    completeCache: Node | null,\n    accumulator: ChildChangeAccumulator\n  ): ViewCache {\n    const oldEventSnap = oldViewCache.getEventCache();\n    let newViewCache, newEventCache;\n    const source = new WriteTreeCompleteChildSource(\n      writesCache,\n      oldViewCache,\n      completeCache\n    );\n    if (changePath.isEmpty()) {\n      newEventCache = this.filter_.updateFullNode(\n        oldViewCache.getEventCache().getNode(),\n        changedSnap,\n        accumulator\n      );\n      newViewCache = oldViewCache.updateEventSnap(\n        newEventCache,\n        true,\n        this.filter_.filtersNodes()\n      );\n    } else {\n      const childKey = changePath.getFront();\n      if (childKey === '.priority') {\n        newEventCache = this.filter_.updatePriority(\n          oldViewCache.getEventCache().getNode(),\n          changedSnap\n        );\n        newViewCache = oldViewCache.updateEventSnap(\n          newEventCache,\n          oldEventSnap.isFullyInitialized(),\n          oldEventSnap.isFiltered()\n        );\n      } else {\n        const childChangePath = changePath.popFront();\n        const oldChild = oldEventSnap.getNode().getImmediateChild(childKey);\n        let newChild;\n        if (childChangePath.isEmpty()) {\n          // Child overwrite, we can replace the child\n          newChild = changedSnap;\n        } else {\n          const childNode = source.getCompleteChild(childKey);\n          if (childNode != null) {\n            if (\n              childChangePath.getBack() === '.priority' &&\n              childNode.getChild(childChangePath.parent()).isEmpty()\n            ) {\n              // This is a priority update on an empty node. If this node exists on the server, the\n              // server will send down the priority in the update, so ignore for now\n              newChild = childNode;\n            } else {\n              newChild = childNode.updateChild(childChangePath, changedSnap);\n            }\n          } else {\n            // There is no complete child node available\n            newChild = ChildrenNode.EMPTY_NODE;\n          }\n        }\n        if (!oldChild.equals(newChild)) {\n          const newEventSnap = this.filter_.updateChild(\n            oldEventSnap.getNode(),\n            childKey,\n            newChild,\n            childChangePath,\n            source,\n            accumulator\n          );\n          newViewCache = oldViewCache.updateEventSnap(\n            newEventSnap,\n            oldEventSnap.isFullyInitialized(),\n            this.filter_.filtersNodes()\n          );\n        } else {\n          newViewCache = oldViewCache;\n        }\n      }\n    }\n    return newViewCache;\n  }\n\n  /**\n   * @param {!ViewCache} viewCache\n   * @param {string} childKey\n   * @return {boolean}\n   * @private\n   */\n  private static cacheHasChild_(\n    viewCache: ViewCache,\n    childKey: string\n  ): boolean {\n    return viewCache.getEventCache().isCompleteForChild(childKey);\n  }\n\n  /**\n   * @param {!ViewCache} viewCache\n   * @param {!Path} path\n   * @param {ImmutableTree.<!Node>} changedChildren\n   * @param {!WriteTreeRef} writesCache\n   * @param {?Node} serverCache\n   * @param {!ChildChangeAccumulator} accumulator\n   * @return {!ViewCache}\n   * @private\n   */\n  private applyUserMerge_(\n    viewCache: ViewCache,\n    path: Path,\n    changedChildren: ImmutableTree<Node>,\n    writesCache: WriteTreeRef,\n    serverCache: Node | null,\n    accumulator: ChildChangeAccumulator\n  ): ViewCache {\n    // HACK: In the case of a limit query, there may be some changes that bump things out of the\n    // window leaving room for new items.  It's important we process these changes first, so we\n    // iterate the changes twice, first processing any that affect items currently in view.\n    // TODO: I consider an item \"in view\" if cacheHasChild is true, which checks both the server\n    // and event snap.  I'm not sure if this will result in edge cases when a child is in one but\n    // not the other.\n    let curViewCache = viewCache;\n    changedChildren.foreach((relativePath, childNode) => {\n      const writePath = path.child(relativePath);\n      if (ViewProcessor.cacheHasChild_(viewCache, writePath.getFront())) {\n        curViewCache = this.applyUserOverwrite_(\n          curViewCache,\n          writePath,\n          childNode,\n          writesCache,\n          serverCache,\n          accumulator\n        );\n      }\n    });\n\n    changedChildren.foreach((relativePath, childNode) => {\n      const writePath = path.child(relativePath);\n      if (!ViewProcessor.cacheHasChild_(viewCache, writePath.getFront())) {\n        curViewCache = this.applyUserOverwrite_(\n          curViewCache,\n          writePath,\n          childNode,\n          writesCache,\n          serverCache,\n          accumulator\n        );\n      }\n    });\n\n    return curViewCache;\n  }\n\n  /**\n   * @param {!Node} node\n   * @param {ImmutableTree.<!Node>} merge\n   * @return {!Node}\n   * @private\n   */\n  private applyMerge_(node: Node, merge: ImmutableTree<Node>): Node {\n    merge.foreach(function(relativePath, childNode) {\n      node = node.updateChild(relativePath, childNode);\n    });\n    return node;\n  }\n\n  /**\n   * @param {!ViewCache} viewCache\n   * @param {!Path} path\n   * @param {!ImmutableTree.<!Node>} changedChildren\n   * @param {!WriteTreeRef} writesCache\n   * @param {?Node} serverCache\n   * @param {boolean} filterServerNode\n   * @param {!ChildChangeAccumulator} accumulator\n   * @return {!ViewCache}\n   * @private\n   */\n  private applyServerMerge_(\n    viewCache: ViewCache,\n    path: Path,\n    changedChildren: ImmutableTree<Node>,\n    writesCache: WriteTreeRef,\n    serverCache: Node | null,\n    filterServerNode: boolean,\n    accumulator: ChildChangeAccumulator\n  ): ViewCache {\n    // If we don't have a cache yet, this merge was intended for a previously listen in the same location. Ignore it and\n    // wait for the complete data update coming soon.\n    if (\n      viewCache\n        .getServerCache()\n        .getNode()\n        .isEmpty() &&\n      !viewCache.getServerCache().isFullyInitialized()\n    ) {\n      return viewCache;\n    }\n\n    // HACK: In the case of a limit query, there may be some changes that bump things out of the\n    // window leaving room for new items.  It's important we process these changes first, so we\n    // iterate the changes twice, first processing any that affect items currently in view.\n    // TODO: I consider an item \"in view\" if cacheHasChild is true, which checks both the server\n    // and event snap.  I'm not sure if this will result in edge cases when a child is in one but\n    // not the other.\n    let curViewCache = viewCache;\n    let viewMergeTree;\n    if (path.isEmpty()) {\n      viewMergeTree = changedChildren;\n    } else {\n      viewMergeTree = ImmutableTree.Empty.setTree(path, changedChildren);\n    }\n    const serverNode = viewCache.getServerCache().getNode();\n    viewMergeTree.children.inorderTraversal((childKey, childTree) => {\n      if (serverNode.hasChild(childKey)) {\n        const serverChild = viewCache\n          .getServerCache()\n          .getNode()\n          .getImmediateChild(childKey);\n        const newChild = this.applyMerge_(serverChild, childTree);\n        curViewCache = this.applyServerOverwrite_(\n          curViewCache,\n          new Path(childKey),\n          newChild,\n          writesCache,\n          serverCache,\n          filterServerNode,\n          accumulator\n        );\n      }\n    });\n    viewMergeTree.children.inorderTraversal((childKey, childMergeTree) => {\n      const isUnknownDeepMerge =\n        !viewCache.getServerCache().isCompleteForChild(childKey) &&\n        childMergeTree.value == null;\n      if (!serverNode.hasChild(childKey) && !isUnknownDeepMerge) {\n        const serverChild = viewCache\n          .getServerCache()\n          .getNode()\n          .getImmediateChild(childKey);\n        const newChild = this.applyMerge_(serverChild, childMergeTree);\n        curViewCache = this.applyServerOverwrite_(\n          curViewCache,\n          new Path(childKey),\n          newChild,\n          writesCache,\n          serverCache,\n          filterServerNode,\n          accumulator\n        );\n      }\n    });\n\n    return curViewCache;\n  }\n\n  /**\n   * @param {!ViewCache} viewCache\n   * @param {!Path} ackPath\n   * @param {!ImmutableTree<!boolean>} affectedTree\n   * @param {!WriteTreeRef} writesCache\n   * @param {?Node} completeCache\n   * @param {!ChildChangeAccumulator} accumulator\n   * @return {!ViewCache}\n   * @private\n   */\n  private ackUserWrite_(\n    viewCache: ViewCache,\n    ackPath: Path,\n    affectedTree: ImmutableTree<boolean>,\n    writesCache: WriteTreeRef,\n    completeCache: Node | null,\n    accumulator: ChildChangeAccumulator\n  ): ViewCache {\n    if (writesCache.shadowingWrite(ackPath) != null) {\n      return viewCache;\n    }\n\n    // Only filter server node if it is currently filtered\n    const filterServerNode = viewCache.getServerCache().isFiltered();\n\n    // Essentially we'll just get our existing server cache for the affected paths and re-apply it as a server update\n    // now that it won't be shadowed.\n    const serverCache = viewCache.getServerCache();\n    if (affectedTree.value != null) {\n      // This is an overwrite.\n      if (\n        (ackPath.isEmpty() && serverCache.isFullyInitialized()) ||\n        serverCache.isCompleteForPath(ackPath)\n      ) {\n        return this.applyServerOverwrite_(\n          viewCache,\n          ackPath,\n          serverCache.getNode().getChild(ackPath),\n          writesCache,\n          completeCache,\n          filterServerNode,\n          accumulator\n        );\n      } else if (ackPath.isEmpty()) {\n        // This is a goofy edge case where we are acking data at this location but don't have full data.  We\n        // should just re-apply whatever we have in our cache as a merge.\n        let changedChildren = ImmutableTree.Empty;\n        serverCache.getNode().forEachChild(KEY_INDEX, function(name, node) {\n          changedChildren = changedChildren.set(new Path(name), node);\n        });\n        return this.applyServerMerge_(\n          viewCache,\n          ackPath,\n          changedChildren,\n          writesCache,\n          completeCache,\n          filterServerNode,\n          accumulator\n        );\n      } else {\n        return viewCache;\n      }\n    } else {\n      // This is a merge.\n      let changedChildren = ImmutableTree.Empty;\n      affectedTree.foreach(function(mergePath, value) {\n        const serverCachePath = ackPath.child(mergePath);\n        if (serverCache.isCompleteForPath(serverCachePath)) {\n          changedChildren = changedChildren.set(\n            mergePath,\n            serverCache.getNode().getChild(serverCachePath)\n          );\n        }\n      });\n      return this.applyServerMerge_(\n        viewCache,\n        ackPath,\n        changedChildren,\n        writesCache,\n        completeCache,\n        filterServerNode,\n        accumulator\n      );\n    }\n  }\n\n  /**\n   * @param {!ViewCache} viewCache\n   * @param {!Path} path\n   * @param {!WriteTreeRef} writesCache\n   * @param {!ChildChangeAccumulator} accumulator\n   * @return {!ViewCache}\n   * @private\n   */\n  private listenComplete_(\n    viewCache: ViewCache,\n    path: Path,\n    writesCache: WriteTreeRef,\n    accumulator: ChildChangeAccumulator\n  ): ViewCache {\n    const oldServerNode = viewCache.getServerCache();\n    const newViewCache = viewCache.updateServerSnap(\n      oldServerNode.getNode(),\n      oldServerNode.isFullyInitialized() || path.isEmpty(),\n      oldServerNode.isFiltered()\n    );\n    return this.generateEventCacheAfterServerEvent_(\n      newViewCache,\n      path,\n      writesCache,\n      NO_COMPLETE_CHILD_SOURCE,\n      accumulator\n    );\n  }\n\n  /**\n   * @param {!ViewCache} viewCache\n   * @param {!Path} path\n   * @param {!WriteTreeRef} writesCache\n   * @param {?Node} completeServerCache\n   * @param {!ChildChangeAccumulator} accumulator\n   * @return {!ViewCache}\n   * @private\n   */\n  private revertUserWrite_(\n    viewCache: ViewCache,\n    path: Path,\n    writesCache: WriteTreeRef,\n    completeServerCache: Node | null,\n    accumulator: ChildChangeAccumulator\n  ): ViewCache {\n    let complete;\n    if (writesCache.shadowingWrite(path) != null) {\n      return viewCache;\n    } else {\n      const source = new WriteTreeCompleteChildSource(\n        writesCache,\n        viewCache,\n        completeServerCache\n      );\n      const oldEventCache = viewCache.getEventCache().getNode();\n      let newEventCache;\n      if (path.isEmpty() || path.getFront() === '.priority') {\n        let newNode;\n        if (viewCache.getServerCache().isFullyInitialized()) {\n          newNode = writesCache.calcCompleteEventCache(\n            viewCache.getCompleteServerSnap()\n          );\n        } else {\n          const serverChildren = viewCache.getServerCache().getNode();\n          assert(\n            serverChildren instanceof ChildrenNode,\n            'serverChildren would be complete if leaf node'\n          );\n          newNode = writesCache.calcCompleteEventChildren(\n            serverChildren as ChildrenNode\n          );\n        }\n        newNode = newNode as Node;\n        newEventCache = this.filter_.updateFullNode(\n          oldEventCache,\n          newNode,\n          accumulator\n        );\n      } else {\n        const childKey = path.getFront();\n        let newChild = writesCache.calcCompleteChild(\n          childKey,\n          viewCache.getServerCache()\n        );\n        if (\n          newChild == null &&\n          viewCache.getServerCache().isCompleteForChild(childKey)\n        ) {\n          newChild = oldEventCache.getImmediateChild(childKey);\n        }\n        if (newChild != null) {\n          newEventCache = this.filter_.updateChild(\n            oldEventCache,\n            childKey,\n            newChild,\n            path.popFront(),\n            source,\n            accumulator\n          );\n        } else if (\n          viewCache\n            .getEventCache()\n            .getNode()\n            .hasChild(childKey)\n        ) {\n          // No complete child available, delete the existing one, if any\n          newEventCache = this.filter_.updateChild(\n            oldEventCache,\n            childKey,\n            ChildrenNode.EMPTY_NODE,\n            path.popFront(),\n            source,\n            accumulator\n          );\n        } else {\n          newEventCache = oldEventCache;\n        }\n        if (\n          newEventCache.isEmpty() &&\n          viewCache.getServerCache().isFullyInitialized()\n        ) {\n          // We might have reverted all child writes. Maybe the old event was a leaf node\n          complete = writesCache.calcCompleteEventCache(\n            viewCache.getCompleteServerSnap()\n          );\n          if (complete.isLeafNode()) {\n            newEventCache = this.filter_.updateFullNode(\n              newEventCache,\n              complete,\n              accumulator\n            );\n          }\n        }\n      }\n      complete =\n        viewCache.getServerCache().isFullyInitialized() ||\n        writesCache.shadowingWrite(Path.Empty) != null;\n      return viewCache.updateEventSnap(\n        newEventCache,\n        complete,\n        this.filter_.filtersNodes()\n      );\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"script"}