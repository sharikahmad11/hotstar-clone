{"ast":null,"code":"\"use strict\";\n/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar util_1 = require(\"@firebase/util\");\n\nvar Path_1 = require(\"./Path\");\n\nvar util_2 = require(\"@firebase/util\");\n/**\n * Node in a Tree.\n */\n\n\nvar TreeNode =\n/** @class */\nfunction () {\n  function TreeNode() {\n    // TODO: Consider making accessors that create children and value lazily or\n    // separate Internal / Leaf 'types'.\n    this.children = {};\n    this.childCount = 0;\n    this.value = null;\n  }\n\n  return TreeNode;\n}();\n\nexports.TreeNode = TreeNode;\n/**\n * A light-weight tree, traversable by path.  Nodes can have both values and children.\n * Nodes are not enumerated (by forEachChild) unless they have a value or non-empty\n * children.\n */\n\nvar Tree =\n/** @class */\nfunction () {\n  /**\n   * @template T\n   * @param {string=} name_ Optional name of the node.\n   * @param {Tree=} parent_ Optional parent node.\n   * @param {TreeNode=} node_ Optional node to wrap.\n   */\n  function Tree(name_, parent_, node_) {\n    if (name_ === void 0) {\n      name_ = '';\n    }\n\n    if (parent_ === void 0) {\n      parent_ = null;\n    }\n\n    if (node_ === void 0) {\n      node_ = new TreeNode();\n    }\n\n    this.name_ = name_;\n    this.parent_ = parent_;\n    this.node_ = node_;\n  }\n  /**\n   * Returns a sub-Tree for the given path.\n   *\n   * @param {!(string|Path)} pathObj Path to look up.\n   * @return {!Tree.<T>} Tree for path.\n   */\n\n\n  Tree.prototype.subTree = function (pathObj) {\n    // TODO: Require pathObj to be Path?\n    var path = pathObj instanceof Path_1.Path ? pathObj : new Path_1.Path(pathObj);\n    var child = this,\n        next;\n\n    while ((next = path.getFront()) !== null) {\n      var childNode = util_2.safeGet(child.node_.children, next) || new TreeNode();\n      child = new Tree(next, child, childNode);\n      path = path.popFront();\n    }\n\n    return child;\n  };\n  /**\n   * Returns the data associated with this tree node.\n   *\n   * @return {?T} The data or null if no data exists.\n   */\n\n\n  Tree.prototype.getValue = function () {\n    return this.node_.value;\n  };\n  /**\n   * Sets data to this tree node.\n   *\n   * @param {!T} value Value to set.\n   */\n\n\n  Tree.prototype.setValue = function (value) {\n    util_1.assert(typeof value !== 'undefined', 'Cannot set value to undefined');\n    this.node_.value = value;\n    this.updateParents_();\n  };\n  /**\n   * Clears the contents of the tree node (its value and all children).\n   */\n\n\n  Tree.prototype.clear = function () {\n    this.node_.value = null;\n    this.node_.children = {};\n    this.node_.childCount = 0;\n    this.updateParents_();\n  };\n  /**\n   * @return {boolean} Whether the tree has any children.\n   */\n\n\n  Tree.prototype.hasChildren = function () {\n    return this.node_.childCount > 0;\n  };\n  /**\n   * @return {boolean} Whether the tree is empty (no value or children).\n   */\n\n\n  Tree.prototype.isEmpty = function () {\n    return this.getValue() === null && !this.hasChildren();\n  };\n  /**\n   * Calls action for each child of this tree node.\n   *\n   * @param {function(!Tree.<T>)} action Action to be called for each child.\n   */\n\n\n  Tree.prototype.forEachChild = function (action) {\n    var _this = this;\n\n    util_2.forEach(this.node_.children, function (child, childTree) {\n      action(new Tree(child, _this, childTree));\n    });\n  };\n  /**\n   * Does a depth-first traversal of this node's descendants, calling action for each one.\n   *\n   * @param {function(!Tree.<T>)} action Action to be called for each child.\n   * @param {boolean=} includeSelf Whether to call action on this node as well. Defaults to\n   *   false.\n   * @param {boolean=} childrenFirst Whether to call action on children before calling it on\n   *   parent.\n   */\n\n\n  Tree.prototype.forEachDescendant = function (action, includeSelf, childrenFirst) {\n    if (includeSelf && !childrenFirst) action(this);\n    this.forEachChild(function (child) {\n      child.forEachDescendant(action,\n      /*includeSelf=*/\n      true, childrenFirst);\n    });\n    if (includeSelf && childrenFirst) action(this);\n  };\n  /**\n   * Calls action on each ancestor node.\n   *\n   * @param {function(!Tree.<T>)} action Action to be called on each parent; return\n   *   true to abort.\n   * @param {boolean=} includeSelf Whether to call action on this node as well.\n   * @return {boolean} true if the action callback returned true.\n   */\n\n\n  Tree.prototype.forEachAncestor = function (action, includeSelf) {\n    var node = includeSelf ? this : this.parent();\n\n    while (node !== null) {\n      if (action(node)) {\n        return true;\n      }\n\n      node = node.parent();\n    }\n\n    return false;\n  };\n  /**\n   * Does a depth-first traversal of this node's descendants.  When a descendant with a value\n   * is found, action is called on it and traversal does not continue inside the node.\n   * Action is *not* called on this node.\n   *\n   * @param {function(!Tree.<T>)} action Action to be called for each child.\n   */\n\n\n  Tree.prototype.forEachImmediateDescendantWithValue = function (action) {\n    this.forEachChild(function (child) {\n      if (child.getValue() !== null) action(child);else child.forEachImmediateDescendantWithValue(action);\n    });\n  };\n  /**\n   * @return {!Path} The path of this tree node, as a Path.\n   */\n\n\n  Tree.prototype.path = function () {\n    return new Path_1.Path(this.parent_ === null ? this.name_ : this.parent_.path() + '/' + this.name_);\n  };\n  /**\n   * @return {string} The name of the tree node.\n   */\n\n\n  Tree.prototype.name = function () {\n    return this.name_;\n  };\n  /**\n   * @return {?Tree} The parent tree node, or null if this is the root of the tree.\n   */\n\n\n  Tree.prototype.parent = function () {\n    return this.parent_;\n  };\n  /**\n   * Adds or removes this child from its parent based on whether it's empty or not.\n   *\n   * @private\n   */\n\n\n  Tree.prototype.updateParents_ = function () {\n    if (this.parent_ !== null) this.parent_.updateChild_(this.name_, this);\n  };\n  /**\n   * Adds or removes the passed child to this tree node, depending on whether it's empty.\n   *\n   * @param {string} childName The name of the child to update.\n   * @param {!Tree.<T>} child The child to update.\n   * @private\n   */\n\n\n  Tree.prototype.updateChild_ = function (childName, child) {\n    var childEmpty = child.isEmpty();\n    var childExists = util_2.contains(this.node_.children, childName);\n\n    if (childEmpty && childExists) {\n      delete this.node_.children[childName];\n      this.node_.childCount--;\n      this.updateParents_();\n    } else if (!childEmpty && !childExists) {\n      this.node_.children[childName] = child.node_;\n      this.node_.childCount++;\n      this.updateParents_();\n    }\n  };\n\n  return Tree;\n}();\n\nexports.Tree = Tree;","map":{"version":3,"sources":["../src/core/util/Tree.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { assert } from '@firebase/util';\nimport { Path } from './Path';\nimport { forEach, contains, safeGet } from '@firebase/util';\n\n/**\n * Node in a Tree.\n */\nexport class TreeNode<T> {\n  // TODO: Consider making accessors that create children and value lazily or\n  // separate Internal / Leaf 'types'.\n  children: { [name: string]: TreeNode<T> } = {};\n  childCount = 0;\n  value: T | null = null;\n}\n\n/**\n * A light-weight tree, traversable by path.  Nodes can have both values and children.\n * Nodes are not enumerated (by forEachChild) unless they have a value or non-empty\n * children.\n */\nexport class Tree<T> {\n  /**\n   * @template T\n   * @param {string=} name_ Optional name of the node.\n   * @param {Tree=} parent_ Optional parent node.\n   * @param {TreeNode=} node_ Optional node to wrap.\n   */\n  constructor(\n    private name_: string = '',\n    private parent_: Tree<T> | null = null,\n    private node_: TreeNode<T> = new TreeNode<T>()\n  ) {}\n\n  /**\n   * Returns a sub-Tree for the given path.\n   *\n   * @param {!(string|Path)} pathObj Path to look up.\n   * @return {!Tree.<T>} Tree for path.\n   */\n  subTree(pathObj: string | Path): Tree<T> {\n    // TODO: Require pathObj to be Path?\n    let path = pathObj instanceof Path ? pathObj : new Path(pathObj);\n    let child = this as any,\n      next;\n    while ((next = path.getFront()) !== null) {\n      const childNode = safeGet(child.node_.children, next) || new TreeNode();\n      child = new Tree(next, child, childNode);\n      path = path.popFront();\n    }\n\n    return child;\n  }\n\n  /**\n   * Returns the data associated with this tree node.\n   *\n   * @return {?T} The data or null if no data exists.\n   */\n  getValue(): T | null {\n    return this.node_.value;\n  }\n\n  /**\n   * Sets data to this tree node.\n   *\n   * @param {!T} value Value to set.\n   */\n  setValue(value: T) {\n    assert(typeof value !== 'undefined', 'Cannot set value to undefined');\n    this.node_.value = value;\n    this.updateParents_();\n  }\n\n  /**\n   * Clears the contents of the tree node (its value and all children).\n   */\n  clear() {\n    this.node_.value = null;\n    this.node_.children = {};\n    this.node_.childCount = 0;\n    this.updateParents_();\n  }\n\n  /**\n   * @return {boolean} Whether the tree has any children.\n   */\n  hasChildren(): boolean {\n    return this.node_.childCount > 0;\n  }\n\n  /**\n   * @return {boolean} Whether the tree is empty (no value or children).\n   */\n  isEmpty(): boolean {\n    return this.getValue() === null && !this.hasChildren();\n  }\n\n  /**\n   * Calls action for each child of this tree node.\n   *\n   * @param {function(!Tree.<T>)} action Action to be called for each child.\n   */\n  forEachChild(action: (tree: Tree<T>) => void) {\n    forEach(this.node_.children, (child: string, childTree: TreeNode<T>) => {\n      action(new Tree<T>(child, this, childTree));\n    });\n  }\n\n  /**\n   * Does a depth-first traversal of this node's descendants, calling action for each one.\n   *\n   * @param {function(!Tree.<T>)} action Action to be called for each child.\n   * @param {boolean=} includeSelf Whether to call action on this node as well. Defaults to\n   *   false.\n   * @param {boolean=} childrenFirst Whether to call action on children before calling it on\n   *   parent.\n   */\n  forEachDescendant(\n    action: (tree: Tree<T>) => void,\n    includeSelf?: boolean,\n    childrenFirst?: boolean\n  ) {\n    if (includeSelf && !childrenFirst) action(this);\n\n    this.forEachChild(function(child) {\n      child.forEachDescendant(action, /*includeSelf=*/ true, childrenFirst);\n    });\n\n    if (includeSelf && childrenFirst) action(this);\n  }\n\n  /**\n   * Calls action on each ancestor node.\n   *\n   * @param {function(!Tree.<T>)} action Action to be called on each parent; return\n   *   true to abort.\n   * @param {boolean=} includeSelf Whether to call action on this node as well.\n   * @return {boolean} true if the action callback returned true.\n   */\n  forEachAncestor(\n    action: (tree: Tree<T>) => void,\n    includeSelf?: boolean\n  ): boolean {\n    let node = includeSelf ? this : this.parent();\n    while (node !== null) {\n      if (action(node)) {\n        return true;\n      }\n      node = node.parent();\n    }\n    return false;\n  }\n\n  /**\n   * Does a depth-first traversal of this node's descendants.  When a descendant with a value\n   * is found, action is called on it and traversal does not continue inside the node.\n   * Action is *not* called on this node.\n   *\n   * @param {function(!Tree.<T>)} action Action to be called for each child.\n   */\n  forEachImmediateDescendantWithValue(action: (tree: Tree<T>) => void) {\n    this.forEachChild(function(child) {\n      if (child.getValue() !== null) action(child);\n      else child.forEachImmediateDescendantWithValue(action);\n    });\n  }\n\n  /**\n   * @return {!Path} The path of this tree node, as a Path.\n   */\n  path(): Path {\n    return new Path(\n      this.parent_ === null\n        ? this.name_\n        : this.parent_.path() + '/' + this.name_\n    );\n  }\n\n  /**\n   * @return {string} The name of the tree node.\n   */\n  name(): string {\n    return this.name_;\n  }\n\n  /**\n   * @return {?Tree} The parent tree node, or null if this is the root of the tree.\n   */\n  parent(): Tree<T> | null {\n    return this.parent_;\n  }\n\n  /**\n   * Adds or removes this child from its parent based on whether it's empty or not.\n   *\n   * @private\n   */\n  private updateParents_() {\n    if (this.parent_ !== null) this.parent_.updateChild_(this.name_, this);\n  }\n\n  /**\n   * Adds or removes the passed child to this tree node, depending on whether it's empty.\n   *\n   * @param {string} childName The name of the child to update.\n   * @param {!Tree.<T>} child The child to update.\n   * @private\n   */\n  private updateChild_(childName: string, child: Tree<T>) {\n    const childEmpty = child.isEmpty();\n    const childExists = contains(this.node_.children, childName);\n    if (childEmpty && childExists) {\n      delete this.node_.children[childName];\n      this.node_.childCount--;\n      this.updateParents_();\n    } else if (!childEmpty && !childExists) {\n      this.node_.children[childName] = child.node_;\n      this.node_.childCount++;\n      this.updateParents_();\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"script"}