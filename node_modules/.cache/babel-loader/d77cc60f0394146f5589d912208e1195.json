{"ast":null,"code":"\"use strict\";\n/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar BrowserPollConnection_1 = require(\"./BrowserPollConnection\");\n\nvar WebSocketConnection_1 = require(\"./WebSocketConnection\");\n\nvar util_1 = require(\"../core/util/util\");\n/**\n * Currently simplistic, this class manages what transport a Connection should use at various stages of its\n * lifecycle.\n *\n * It starts with longpolling in a browser, and httppolling on node. It then upgrades to websockets if\n * they are available.\n * @constructor\n */\n\n\nvar TransportManager =\n/** @class */\nfunction () {\n  /**\n   * @param {!RepoInfo} repoInfo Metadata around the namespace we're connecting to\n   */\n  function TransportManager(repoInfo) {\n    this.initTransports_(repoInfo);\n  }\n\n  Object.defineProperty(TransportManager, \"ALL_TRANSPORTS\", {\n    /**\n     * @const\n     * @type {!Array.<function(new:Transport, string, RepoInfo, string=)>}\n     */\n    get: function () {\n      return [BrowserPollConnection_1.BrowserPollConnection, WebSocketConnection_1.WebSocketConnection];\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\n   * @param {!RepoInfo} repoInfo\n   * @private\n   */\n\n  TransportManager.prototype.initTransports_ = function (repoInfo) {\n    var isWebSocketsAvailable = WebSocketConnection_1.WebSocketConnection && WebSocketConnection_1.WebSocketConnection['isAvailable']();\n    var isSkipPollConnection = isWebSocketsAvailable && !WebSocketConnection_1.WebSocketConnection.previouslyFailed();\n\n    if (repoInfo.webSocketOnly) {\n      if (!isWebSocketsAvailable) util_1.warn(\"wss:// URL used, but browser isn't known to support websockets.  Trying anyway.\");\n      isSkipPollConnection = true;\n    }\n\n    if (isSkipPollConnection) {\n      this.transports_ = [WebSocketConnection_1.WebSocketConnection];\n    } else {\n      var transports_1 = this.transports_ = [];\n      util_1.each(TransportManager.ALL_TRANSPORTS, function (i, transport) {\n        if (transport && transport['isAvailable']()) {\n          transports_1.push(transport);\n        }\n      });\n    }\n  };\n  /**\n   * @return {function(new:Transport, !string, !RepoInfo, string=, string=)} The constructor for the\n   * initial transport to use\n   */\n\n\n  TransportManager.prototype.initialTransport = function () {\n    if (this.transports_.length > 0) {\n      return this.transports_[0];\n    } else {\n      throw new Error('No transports available');\n    }\n  };\n  /**\n   * @return {?function(new:Transport, function(),function(), string=)} The constructor for the next\n   * transport, or null\n   */\n\n\n  TransportManager.prototype.upgradeTransport = function () {\n    if (this.transports_.length > 1) {\n      return this.transports_[1];\n    } else {\n      return null;\n    }\n  };\n\n  return TransportManager;\n}();\n\nexports.TransportManager = TransportManager;","map":{"version":3,"sources":["../src/realtime/TransportManager.ts"],"names":[],"mappings":";AAAA;;;;;;;;;;;;;;AAcG;;;;;;AAEH,IAAA,uBAAA,GAAA,OAAA,CAAA,yBAAA,CAAA;;AACA,IAAA,qBAAA,GAAA,OAAA,CAAA,uBAAA,CAAA;;AACA,IAAA,MAAA,GAAA,OAAA,CAAA,mBAAA,CAAA;AAIA;;;;;;;AAOG;;;AACH,IAAA,gBAAA;AAAA;AAAA,YAAA;AAWE;;AAEG;AACH,WAAA,gBAAA,CAAY,QAAZ,EAA8B;AAC5B,SAAK,eAAL,CAAqB,QAArB;AACD;;AATD,EAAA,MAAA,CAAA,cAAA,CAAW,gBAAX,EAAW,gBAAX,EAAyB;AAJzB;;;AAGG;SACH,YAAA;AACE,aAAO,CAAC,uBAAA,CAAA,qBAAD,EAAwB,qBAAA,CAAA,mBAAxB,CAAP;AACD,KAFwB;oBAAA;;AAAA,GAAzB;AAWA;;;AAGG;;AACK,EAAA,gBAAA,CAAA,SAAA,CAAA,eAAA,GAAR,UAAwB,QAAxB,EAA0C;AACxC,QAAM,qBAAqB,GACzB,qBAAA,CAAA,mBAAA,IAAuB,qBAAA,CAAA,mBAAA,CAAoB,aAApB,GADzB;AAEA,QAAI,oBAAoB,GACtB,qBAAqB,IAAI,CAAC,qBAAA,CAAA,mBAAA,CAAoB,gBAApB,EAD5B;;AAGA,QAAI,QAAQ,CAAC,aAAb,EAA4B;AAC1B,UAAI,CAAC,qBAAL,EACE,MAAA,CAAA,IAAA,CACE,iFADF;AAIF,MAAA,oBAAoB,GAAG,IAAvB;AACD;;AAED,QAAI,oBAAJ,EAA0B;AACxB,WAAK,WAAL,GAAmB,CAAC,qBAAA,CAAA,mBAAD,CAAnB;AACD,KAFD,MAEO;AACL,UAAM,YAAU,GAAI,KAAK,WAAL,GAAmB,EAAvC;AACA,MAAA,MAAA,CAAA,IAAA,CACE,gBAAgB,CAAC,cADnB,EAEE,UAAC,CAAD,EAAY,SAAZ,EAA2C;AACzC,YAAI,SAAS,IAAI,SAAS,CAAC,aAAD,CAAT,EAAjB,EAA6C;AAC3C,UAAA,YAAU,CAAC,IAAX,CAAgB,SAAhB;AACD;AACF,OANH;AAQD;AACF,GA5BO;AA8BR;;;AAGG;;;AACH,EAAA,gBAAA,CAAA,SAAA,CAAA,gBAAA,GAAA,YAAA;AACE,QAAI,KAAK,WAAL,CAAiB,MAAjB,GAA0B,CAA9B,EAAiC;AAC/B,aAAO,KAAK,WAAL,CAAiB,CAAjB,CAAP;AACD,KAFD,MAEO;AACL,YAAM,IAAI,KAAJ,CAAU,yBAAV,CAAN;AACD;AACF,GAND;AAQA;;;AAGG;;;AACH,EAAA,gBAAA,CAAA,SAAA,CAAA,gBAAA,GAAA,YAAA;AACE,QAAI,KAAK,WAAL,CAAiB,MAAjB,GAA0B,CAA9B,EAAiC;AAC/B,aAAO,KAAK,WAAL,CAAiB,CAAjB,CAAP;AACD,KAFD,MAEO;AACL,aAAO,IAAP;AACD;AACF,GAND;;AAOF,SAAA,gBAAA;AAAC,CA3ED,EAAA;;AAAa,OAAA,CAAA,gBAAA,GAAA,gBAAA","sourcesContent":["/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { BrowserPollConnection } from './BrowserPollConnection';\nimport { WebSocketConnection } from './WebSocketConnection';\nimport { warn, each } from '../core/util/util';\nimport { TransportConstructor } from './Transport';\nimport { RepoInfo } from '../core/RepoInfo';\n\n/**\n * Currently simplistic, this class manages what transport a Connection should use at various stages of its\n * lifecycle.\n *\n * It starts with longpolling in a browser, and httppolling on node. It then upgrades to websockets if\n * they are available.\n * @constructor\n */\nexport class TransportManager {\n  private transports_: TransportConstructor[];\n\n  /**\n   * @const\n   * @type {!Array.<function(new:Transport, string, RepoInfo, string=)>}\n   */\n  static get ALL_TRANSPORTS() {\n    return [BrowserPollConnection, WebSocketConnection];\n  }\n\n  /**\n   * @param {!RepoInfo} repoInfo Metadata around the namespace we're connecting to\n   */\n  constructor(repoInfo: RepoInfo) {\n    this.initTransports_(repoInfo);\n  }\n\n  /**\n   * @param {!RepoInfo} repoInfo\n   * @private\n   */\n  private initTransports_(repoInfo: RepoInfo) {\n    const isWebSocketsAvailable: boolean =\n      WebSocketConnection && WebSocketConnection['isAvailable']();\n    let isSkipPollConnection =\n      isWebSocketsAvailable && !WebSocketConnection.previouslyFailed();\n\n    if (repoInfo.webSocketOnly) {\n      if (!isWebSocketsAvailable)\n        warn(\n          \"wss:// URL used, but browser isn't known to support websockets.  Trying anyway.\"\n        );\n\n      isSkipPollConnection = true;\n    }\n\n    if (isSkipPollConnection) {\n      this.transports_ = [WebSocketConnection];\n    } else {\n      const transports = (this.transports_ = [] as TransportConstructor[]);\n      each(\n        TransportManager.ALL_TRANSPORTS,\n        (i: number, transport: TransportConstructor) => {\n          if (transport && transport['isAvailable']()) {\n            transports.push(transport);\n          }\n        }\n      );\n    }\n  }\n\n  /**\n   * @return {function(new:Transport, !string, !RepoInfo, string=, string=)} The constructor for the\n   * initial transport to use\n   */\n  initialTransport(): TransportConstructor {\n    if (this.transports_.length > 0) {\n      return this.transports_[0];\n    } else {\n      throw new Error('No transports available');\n    }\n  }\n\n  /**\n   * @return {?function(new:Transport, function(),function(), string=)} The constructor for the next\n   * transport, or null\n   */\n  upgradeTransport(): TransportConstructor | null {\n    if (this.transports_.length > 1) {\n      return this.transports_[1];\n    } else {\n      return null;\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"script"}