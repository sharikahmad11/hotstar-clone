{"ast":null,"code":"\"use strict\";\n/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar util_1 = require(\"@firebase/util\");\n\nvar childSet_1 = require(\"./childSet\");\n\nvar util_2 = require(\"@firebase/util\");\n\nvar Node_1 = require(\"./Node\");\n\nvar PriorityIndex_1 = require(\"./indexes/PriorityIndex\");\n\nvar KeyIndex_1 = require(\"./indexes/KeyIndex\");\n\nvar _defaultIndexMap;\n\nvar fallbackObject = {};\n/**\n *\n * @param {Object.<string, FallbackType|SortedMap.<NamedNode, Node>>} indexes\n * @param {Object.<string, Index>} indexSet\n * @constructor\n */\n\nvar IndexMap =\n/** @class */\nfunction () {\n  function IndexMap(indexes_, indexSet_) {\n    this.indexes_ = indexes_;\n    this.indexSet_ = indexSet_;\n  }\n\n  Object.defineProperty(IndexMap, \"Default\", {\n    /**\n     * The default IndexMap for nodes without a priority\n     * @type {!IndexMap}\n     * @const\n     */\n    get: function () {\n      util_1.assert(fallbackObject && PriorityIndex_1.PRIORITY_INDEX, 'ChildrenNode.ts has not been loaded');\n      _defaultIndexMap = _defaultIndexMap || new IndexMap({\n        '.priority': fallbackObject\n      }, {\n        '.priority': PriorityIndex_1.PRIORITY_INDEX\n      });\n      return _defaultIndexMap;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\n   *\n   * @param {!string} indexKey\n   * @return {?SortedMap.<NamedNode, Node>}\n   */\n\n  IndexMap.prototype.get = function (indexKey) {\n    var sortedMap = util_2.safeGet(this.indexes_, indexKey);\n    if (!sortedMap) throw new Error('No index defined for ' + indexKey);\n\n    if (sortedMap === fallbackObject) {\n      // The index exists, but it falls back to just name comparison. Return null so that the calling code uses the\n      // regular child map\n      return null;\n    } else {\n      return sortedMap;\n    }\n  };\n  /**\n   * @param {!Index} indexDefinition\n   * @return {boolean}\n   */\n\n\n  IndexMap.prototype.hasIndex = function (indexDefinition) {\n    return util_2.contains(this.indexSet_, indexDefinition.toString());\n  };\n  /**\n   * @param {!Index} indexDefinition\n   * @param {!SortedMap.<string, !Node>} existingChildren\n   * @return {!IndexMap}\n   */\n\n\n  IndexMap.prototype.addIndex = function (indexDefinition, existingChildren) {\n    util_1.assert(indexDefinition !== KeyIndex_1.KEY_INDEX, \"KeyIndex always exists and isn't meant to be added to the IndexMap.\");\n    var childList = [];\n    var sawIndexedValue = false;\n    var iter = existingChildren.getIterator(Node_1.NamedNode.Wrap);\n    var next = iter.getNext();\n\n    while (next) {\n      sawIndexedValue = sawIndexedValue || indexDefinition.isDefinedOn(next.node);\n      childList.push(next);\n      next = iter.getNext();\n    }\n\n    var newIndex;\n\n    if (sawIndexedValue) {\n      newIndex = childSet_1.buildChildSet(childList, indexDefinition.getCompare());\n    } else {\n      newIndex = fallbackObject;\n    }\n\n    var indexName = indexDefinition.toString();\n    var newIndexSet = util_2.clone(this.indexSet_);\n    newIndexSet[indexName] = indexDefinition;\n    var newIndexes = util_2.clone(this.indexes_);\n    newIndexes[indexName] = newIndex;\n    return new IndexMap(newIndexes, newIndexSet);\n  };\n  /**\n   * Ensure that this node is properly tracked in any indexes that we're maintaining\n   * @param {!NamedNode} namedNode\n   * @param {!SortedMap.<string, !Node>} existingChildren\n   * @return {!IndexMap}\n   */\n\n\n  IndexMap.prototype.addToIndexes = function (namedNode, existingChildren) {\n    var _this = this;\n\n    var newIndexes = util_2.map(this.indexes_, function (indexedChildren, indexName) {\n      var index = util_2.safeGet(_this.indexSet_, indexName);\n      util_1.assert(index, 'Missing index implementation for ' + indexName);\n\n      if (indexedChildren === fallbackObject) {\n        // Check to see if we need to index everything\n        if (index.isDefinedOn(namedNode.node)) {\n          // We need to build this index\n          var childList = [];\n          var iter = existingChildren.getIterator(Node_1.NamedNode.Wrap);\n          var next = iter.getNext();\n\n          while (next) {\n            if (next.name != namedNode.name) {\n              childList.push(next);\n            }\n\n            next = iter.getNext();\n          }\n\n          childList.push(namedNode);\n          return childSet_1.buildChildSet(childList, index.getCompare());\n        } else {\n          // No change, this remains a fallback\n          return fallbackObject;\n        }\n      } else {\n        var existingSnap = existingChildren.get(namedNode.name);\n        var newChildren = indexedChildren;\n\n        if (existingSnap) {\n          newChildren = newChildren.remove(new Node_1.NamedNode(namedNode.name, existingSnap));\n        }\n\n        return newChildren.insert(namedNode, namedNode.node);\n      }\n    });\n    return new IndexMap(newIndexes, this.indexSet_);\n  };\n  /**\n   * Create a new IndexMap instance with the given value removed\n   * @param {!NamedNode} namedNode\n   * @param {!SortedMap.<string, !Node>} existingChildren\n   * @return {!IndexMap}\n   */\n\n\n  IndexMap.prototype.removeFromIndexes = function (namedNode, existingChildren) {\n    var newIndexes = util_2.map(this.indexes_, function (indexedChildren) {\n      if (indexedChildren === fallbackObject) {\n        // This is the fallback. Just return it, nothing to do in this case\n        return indexedChildren;\n      } else {\n        var existingSnap = existingChildren.get(namedNode.name);\n\n        if (existingSnap) {\n          return indexedChildren.remove(new Node_1.NamedNode(namedNode.name, existingSnap));\n        } else {\n          // No record of this child\n          return indexedChildren;\n        }\n      }\n    });\n    return new IndexMap(newIndexes, this.indexSet_);\n  };\n\n  return IndexMap;\n}();\n\nexports.IndexMap = IndexMap;","map":{"version":3,"sources":["../src/core/snap/IndexMap.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { assert } from '@firebase/util';\nimport { buildChildSet } from './childSet';\nimport { contains, clone, map, safeGet } from '@firebase/util';\nimport { NamedNode, Node } from './Node';\nimport { PRIORITY_INDEX } from './indexes/PriorityIndex';\nimport { KEY_INDEX } from './indexes/KeyIndex';\nimport { SortedMap } from '../util/SortedMap';\nimport { Index } from './indexes/Index';\n\nlet _defaultIndexMap: IndexMap;\n\nconst fallbackObject = {};\n\n/**\n *\n * @param {Object.<string, FallbackType|SortedMap.<NamedNode, Node>>} indexes\n * @param {Object.<string, Index>} indexSet\n * @constructor\n */\nexport class IndexMap {\n  /**\n   * The default IndexMap for nodes without a priority\n   * @type {!IndexMap}\n   * @const\n   */\n  static get Default(): IndexMap {\n    assert(\n      fallbackObject && PRIORITY_INDEX,\n      'ChildrenNode.ts has not been loaded'\n    );\n    _defaultIndexMap =\n      _defaultIndexMap ||\n      new IndexMap(\n        { '.priority': fallbackObject },\n        { '.priority': PRIORITY_INDEX }\n      );\n    return _defaultIndexMap;\n  }\n\n  constructor(\n    private indexes_: {\n      [k: string]: SortedMap<NamedNode, Node> | /*FallbackType*/ object;\n    },\n    private indexSet_: { [k: string]: Index }\n  ) {}\n\n  /**\n   *\n   * @param {!string} indexKey\n   * @return {?SortedMap.<NamedNode, Node>}\n   */\n  get(indexKey: string): SortedMap<NamedNode, Node> | null {\n    const sortedMap = safeGet(this.indexes_, indexKey);\n    if (!sortedMap) throw new Error('No index defined for ' + indexKey);\n\n    if (sortedMap === fallbackObject) {\n      // The index exists, but it falls back to just name comparison. Return null so that the calling code uses the\n      // regular child map\n      return null;\n    } else {\n      return sortedMap;\n    }\n  }\n\n  /**\n   * @param {!Index} indexDefinition\n   * @return {boolean}\n   */\n  hasIndex(indexDefinition: Index): boolean {\n    return contains(this.indexSet_, indexDefinition.toString());\n  }\n\n  /**\n   * @param {!Index} indexDefinition\n   * @param {!SortedMap.<string, !Node>} existingChildren\n   * @return {!IndexMap}\n   */\n  addIndex(\n    indexDefinition: Index,\n    existingChildren: SortedMap<string, Node>\n  ): IndexMap {\n    assert(\n      indexDefinition !== KEY_INDEX,\n      \"KeyIndex always exists and isn't meant to be added to the IndexMap.\"\n    );\n    const childList = [];\n    let sawIndexedValue = false;\n    const iter = existingChildren.getIterator(NamedNode.Wrap);\n    let next = iter.getNext();\n    while (next) {\n      sawIndexedValue =\n        sawIndexedValue || indexDefinition.isDefinedOn(next.node);\n      childList.push(next);\n      next = iter.getNext();\n    }\n    let newIndex;\n    if (sawIndexedValue) {\n      newIndex = buildChildSet(childList, indexDefinition.getCompare());\n    } else {\n      newIndex = fallbackObject;\n    }\n    const indexName = indexDefinition.toString();\n    const newIndexSet = clone(this.indexSet_);\n    newIndexSet[indexName] = indexDefinition;\n    const newIndexes = clone(this.indexes_);\n    newIndexes[indexName] = newIndex;\n    return new IndexMap(newIndexes, newIndexSet);\n  }\n\n  /**\n   * Ensure that this node is properly tracked in any indexes that we're maintaining\n   * @param {!NamedNode} namedNode\n   * @param {!SortedMap.<string, !Node>} existingChildren\n   * @return {!IndexMap}\n   */\n  addToIndexes(\n    namedNode: NamedNode,\n    existingChildren: SortedMap<string, Node>\n  ): IndexMap {\n    const newIndexes = map(\n      this.indexes_,\n      (indexedChildren: SortedMap<NamedNode, Node>, indexName: string) => {\n        const index = safeGet(this.indexSet_, indexName);\n        assert(index, 'Missing index implementation for ' + indexName);\n        if (indexedChildren === fallbackObject) {\n          // Check to see if we need to index everything\n          if (index.isDefinedOn(namedNode.node)) {\n            // We need to build this index\n            const childList = [];\n            const iter = existingChildren.getIterator(NamedNode.Wrap);\n            let next = iter.getNext();\n            while (next) {\n              if (next.name != namedNode.name) {\n                childList.push(next);\n              }\n              next = iter.getNext();\n            }\n            childList.push(namedNode);\n            return buildChildSet(childList, index.getCompare());\n          } else {\n            // No change, this remains a fallback\n            return fallbackObject;\n          }\n        } else {\n          const existingSnap = existingChildren.get(namedNode.name);\n          let newChildren = indexedChildren;\n          if (existingSnap) {\n            newChildren = newChildren.remove(\n              new NamedNode(namedNode.name, existingSnap)\n            );\n          }\n          return newChildren.insert(namedNode, namedNode.node);\n        }\n      }\n    );\n    return new IndexMap(newIndexes, this.indexSet_);\n  }\n\n  /**\n   * Create a new IndexMap instance with the given value removed\n   * @param {!NamedNode} namedNode\n   * @param {!SortedMap.<string, !Node>} existingChildren\n   * @return {!IndexMap}\n   */\n  removeFromIndexes(\n    namedNode: NamedNode,\n    existingChildren: SortedMap<string, Node>\n  ): IndexMap {\n    const newIndexes = map(this.indexes_, function(\n      indexedChildren: SortedMap<NamedNode, Node>\n    ) {\n      if (indexedChildren === fallbackObject) {\n        // This is the fallback. Just return it, nothing to do in this case\n        return indexedChildren;\n      } else {\n        const existingSnap = existingChildren.get(namedNode.name);\n        if (existingSnap) {\n          return indexedChildren.remove(\n            new NamedNode(namedNode.name, existingSnap)\n          );\n        } else {\n          // No record of this child\n          return indexedChildren;\n        }\n      }\n    });\n    return new IndexMap(newIndexes, this.indexSet_);\n  }\n}\n"]},"metadata":{},"sourceType":"script"}