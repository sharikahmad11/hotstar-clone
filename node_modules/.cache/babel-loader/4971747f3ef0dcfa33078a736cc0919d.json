{"ast":null,"code":"\"use strict\";\n/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar DataSnapshot_1 = require(\"../../api/DataSnapshot\");\n\nvar Event_1 = require(\"./Event\");\n\nvar util_1 = require(\"@firebase/util\");\n\nvar util_2 = require(\"@firebase/util\");\n/**\n * Represents registration for 'value' events.\n */\n\n\nvar ValueEventRegistration =\n/** @class */\nfunction () {\n  /**\n   * @param {?function(!DataSnapshot)} callback_\n   * @param {?function(Error)} cancelCallback_\n   * @param {?Object} context_\n   */\n  function ValueEventRegistration(callback_, cancelCallback_, context_) {\n    this.callback_ = callback_;\n    this.cancelCallback_ = cancelCallback_;\n    this.context_ = context_;\n  }\n  /**\n   * @inheritDoc\n   */\n\n\n  ValueEventRegistration.prototype.respondsTo = function (eventType) {\n    return eventType === 'value';\n  };\n  /**\n   * @inheritDoc\n   */\n\n\n  ValueEventRegistration.prototype.createEvent = function (change, query) {\n    var index = query.getQueryParams().getIndex();\n    return new Event_1.DataEvent('value', this, new DataSnapshot_1.DataSnapshot(change.snapshotNode, query.getRef(), index));\n  };\n  /**\n   * @inheritDoc\n   */\n\n\n  ValueEventRegistration.prototype.getEventRunner = function (eventData) {\n    var ctx = this.context_;\n\n    if (eventData.getEventType() === 'cancel') {\n      util_2.assert(this.cancelCallback_, 'Raising a cancel event on a listener with no cancel callback');\n      var cancelCB_1 = this.cancelCallback_;\n      return function () {\n        // We know that error exists, we checked above that this is a cancel event\n        cancelCB_1.call(ctx, eventData.error);\n      };\n    } else {\n      var cb_1 = this.callback_;\n      return function () {\n        cb_1.call(ctx, eventData.snapshot);\n      };\n    }\n  };\n  /**\n   * @inheritDoc\n   */\n\n\n  ValueEventRegistration.prototype.createCancelEvent = function (error, path) {\n    if (this.cancelCallback_) {\n      return new Event_1.CancelEvent(this, error, path);\n    } else {\n      return null;\n    }\n  };\n  /**\n   * @inheritDoc\n   */\n\n\n  ValueEventRegistration.prototype.matches = function (other) {\n    if (!(other instanceof ValueEventRegistration)) {\n      return false;\n    } else if (!other.callback_ || !this.callback_) {\n      // If no callback specified, we consider it to match any callback.\n      return true;\n    } else {\n      return other.callback_ === this.callback_ && other.context_ === this.context_;\n    }\n  };\n  /**\n   * @inheritDoc\n   */\n\n\n  ValueEventRegistration.prototype.hasAnyCallback = function () {\n    return this.callback_ !== null;\n  };\n\n  return ValueEventRegistration;\n}();\n\nexports.ValueEventRegistration = ValueEventRegistration;\n/**\n * Represents the registration of 1 or more child_xxx events.\n *\n * Currently, it is always exactly 1 child_xxx event, but the idea is we might let you\n * register a group of callbacks together in the future.\n *\n * @constructor\n * @implements {EventRegistration}\n */\n\nvar ChildEventRegistration =\n/** @class */\nfunction () {\n  /**\n   * @param {?Object.<string, function(!DataSnapshot, ?string=)>} callbacks_\n   * @param {?function(Error)} cancelCallback_\n   * @param {Object=} context_\n   */\n  function ChildEventRegistration(callbacks_, cancelCallback_, context_) {\n    this.callbacks_ = callbacks_;\n    this.cancelCallback_ = cancelCallback_;\n    this.context_ = context_;\n  }\n  /**\n   * @inheritDoc\n   */\n\n\n  ChildEventRegistration.prototype.respondsTo = function (eventType) {\n    var eventToCheck = eventType === 'children_added' ? 'child_added' : eventType;\n    eventToCheck = eventToCheck === 'children_removed' ? 'child_removed' : eventToCheck;\n    return util_1.contains(this.callbacks_, eventToCheck);\n  };\n  /**\n   * @inheritDoc\n   */\n\n\n  ChildEventRegistration.prototype.createCancelEvent = function (error, path) {\n    if (this.cancelCallback_) {\n      return new Event_1.CancelEvent(this, error, path);\n    } else {\n      return null;\n    }\n  };\n  /**\n   * @inheritDoc\n   */\n\n\n  ChildEventRegistration.prototype.createEvent = function (change, query) {\n    util_2.assert(change.childName != null, 'Child events should have a childName.');\n    var ref = query.getRef().child(\n    /** @type {!string} */\n    change.childName);\n    var index = query.getQueryParams().getIndex();\n    return new Event_1.DataEvent(change.type, this, new DataSnapshot_1.DataSnapshot(change.snapshotNode, ref, index), change.prevName);\n  };\n  /**\n   * @inheritDoc\n   */\n\n\n  ChildEventRegistration.prototype.getEventRunner = function (eventData) {\n    var ctx = this.context_;\n\n    if (eventData.getEventType() === 'cancel') {\n      util_2.assert(this.cancelCallback_, 'Raising a cancel event on a listener with no cancel callback');\n      var cancelCB_2 = this.cancelCallback_;\n      return function () {\n        // We know that error exists, we checked above that this is a cancel event\n        cancelCB_2.call(ctx, eventData.error);\n      };\n    } else {\n      var cb_2 = this.callbacks_[eventData.eventType];\n      return function () {\n        cb_2.call(ctx, eventData.snapshot, eventData.prevName);\n      };\n    }\n  };\n  /**\n   * @inheritDoc\n   */\n\n\n  ChildEventRegistration.prototype.matches = function (other) {\n    if (other instanceof ChildEventRegistration) {\n      if (!this.callbacks_ || !other.callbacks_) {\n        return true;\n      } else if (this.context_ === other.context_) {\n        var otherCount = util_1.getCount(other.callbacks_);\n        var thisCount = util_1.getCount(this.callbacks_);\n\n        if (otherCount === thisCount) {\n          // If count is 1, do an exact match on eventType, if either is defined but null, it's a match.\n          //  If event types don't match, not a match\n          // If count is not 1, exact match across all\n          if (otherCount === 1) {\n            var otherKey\n            /** @type {!string} */\n            = util_1.getAnyKey(other.callbacks_);\n            var thisKey\n            /** @type {!string} */\n            = util_1.getAnyKey(this.callbacks_);\n            return thisKey === otherKey && (!other.callbacks_[otherKey] || !this.callbacks_[thisKey] || other.callbacks_[otherKey] === this.callbacks_[thisKey]);\n          } else {\n            // Exact match on each key.\n            return util_1.every(this.callbacks_, function (eventType, cb) {\n              return other.callbacks_[eventType] === cb;\n            });\n          }\n        }\n      }\n    }\n\n    return false;\n  };\n  /**\n   * @inheritDoc\n   */\n\n\n  ChildEventRegistration.prototype.hasAnyCallback = function () {\n    return this.callbacks_ !== null;\n  };\n\n  return ChildEventRegistration;\n}();\n\nexports.ChildEventRegistration = ChildEventRegistration;","map":{"version":3,"sources":["../src/core/view/EventRegistration.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { DataSnapshot } from '../../api/DataSnapshot';\nimport { DataEvent, CancelEvent, Event } from './Event';\nimport { contains, getCount, getAnyKey, every } from '@firebase/util';\nimport { assert } from '@firebase/util';\nimport { Path } from '../util/Path';\nimport { Change } from './Change';\nimport { Query } from '../../api/Query';\n\n/**\n * An EventRegistration is basically an event type ('value', 'child_added', etc.) and a callback\n * to be notified of that type of event.\n *\n * That said, it can also contain a cancel callback to be notified if the event is canceled.  And\n * currently, this code is organized around the idea that you would register multiple child_ callbacks\n * together, as a single EventRegistration.  Though currently we don't do that.\n */\nexport interface EventRegistration {\n  /**\n   * True if this container has a callback to trigger for this event type\n   * @param {!string} eventType\n   * @return {boolean}\n   */\n  respondsTo(eventType: string): boolean;\n\n  /**\n   * @param {!Change} change\n   * @param {!Query} query\n   * @return {!Event}\n   */\n  createEvent(change: Change, query: Query): Event;\n\n  /**\n   * Given event data, return a function to trigger the user's callback\n   * @param {!Event} eventData\n   * @return {function()}\n   */\n  getEventRunner(eventData: Event): () => void;\n\n  /**\n   * @param {!Error} error\n   * @param {!Path} path\n   * @return {?CancelEvent}\n   */\n  createCancelEvent(error: Error, path: Path): CancelEvent | null;\n\n  /**\n   * @param {!EventRegistration} other\n   * @return {boolean}\n   */\n  matches(other: EventRegistration): boolean;\n\n  /**\n   * False basically means this is a \"dummy\" callback container being used as a sentinel\n   * to remove all callback containers of a particular type.  (e.g. if the user does\n   * ref.off('value') without specifying a specific callback).\n   *\n   * (TODO: Rework this, since it's hacky)\n   *\n   * @return {boolean}\n   */\n  hasAnyCallback(): boolean;\n}\n\n/**\n * Represents registration for 'value' events.\n */\nexport class ValueEventRegistration implements EventRegistration {\n  /**\n   * @param {?function(!DataSnapshot)} callback_\n   * @param {?function(Error)} cancelCallback_\n   * @param {?Object} context_\n   */\n  constructor(\n    private callback_: ((d: DataSnapshot) => void) | null,\n    private cancelCallback_: ((e: Error) => void) | null,\n    private context_: Object | null\n  ) {}\n\n  /**\n   * @inheritDoc\n   */\n  respondsTo(eventType: string): boolean {\n    return eventType === 'value';\n  }\n\n  /**\n   * @inheritDoc\n   */\n  createEvent(change: Change, query: Query): DataEvent {\n    const index = query.getQueryParams().getIndex();\n    return new DataEvent(\n      'value',\n      this,\n      new DataSnapshot(change.snapshotNode, query.getRef(), index)\n    );\n  }\n\n  /**\n   * @inheritDoc\n   */\n  getEventRunner(eventData: CancelEvent | DataEvent): () => void {\n    const ctx = this.context_;\n    if (eventData.getEventType() === 'cancel') {\n      assert(\n        this.cancelCallback_,\n        'Raising a cancel event on a listener with no cancel callback'\n      );\n      const cancelCB = this.cancelCallback_;\n      return function() {\n        // We know that error exists, we checked above that this is a cancel event\n        cancelCB.call(ctx, (eventData as CancelEvent).error);\n      };\n    } else {\n      const cb = this.callback_;\n      return function() {\n        cb.call(ctx, (eventData as DataEvent).snapshot);\n      };\n    }\n  }\n\n  /**\n   * @inheritDoc\n   */\n  createCancelEvent(error: Error, path: Path): CancelEvent | null {\n    if (this.cancelCallback_) {\n      return new CancelEvent(this, error, path);\n    } else {\n      return null;\n    }\n  }\n\n  /**\n   * @inheritDoc\n   */\n  matches(other: EventRegistration): boolean {\n    if (!(other instanceof ValueEventRegistration)) {\n      return false;\n    } else if (!other.callback_ || !this.callback_) {\n      // If no callback specified, we consider it to match any callback.\n      return true;\n    } else {\n      return (\n        other.callback_ === this.callback_ && other.context_ === this.context_\n      );\n    }\n  }\n\n  /**\n   * @inheritDoc\n   */\n  hasAnyCallback(): boolean {\n    return this.callback_ !== null;\n  }\n}\n\n/**\n * Represents the registration of 1 or more child_xxx events.\n *\n * Currently, it is always exactly 1 child_xxx event, but the idea is we might let you\n * register a group of callbacks together in the future.\n *\n * @constructor\n * @implements {EventRegistration}\n */\nexport class ChildEventRegistration implements EventRegistration {\n  /**\n   * @param {?Object.<string, function(!DataSnapshot, ?string=)>} callbacks_\n   * @param {?function(Error)} cancelCallback_\n   * @param {Object=} context_\n   */\n  constructor(\n    private callbacks_:\n      | ({ [k: string]: (d: DataSnapshot, s?: string | null) => void })\n      | null,\n    private cancelCallback_: ((e: Error) => void) | null,\n    private context_?: Object\n  ) {}\n\n  /**\n   * @inheritDoc\n   */\n  respondsTo(eventType: string): boolean {\n    let eventToCheck =\n      eventType === 'children_added' ? 'child_added' : eventType;\n    eventToCheck =\n      eventToCheck === 'children_removed' ? 'child_removed' : eventToCheck;\n    return contains(this.callbacks_, eventToCheck);\n  }\n\n  /**\n   * @inheritDoc\n   */\n  createCancelEvent(error: Error, path: Path): CancelEvent | null {\n    if (this.cancelCallback_) {\n      return new CancelEvent(this, error, path);\n    } else {\n      return null;\n    }\n  }\n\n  /**\n   * @inheritDoc\n   */\n  createEvent(change: Change, query: Query): DataEvent {\n    assert(change.childName != null, 'Child events should have a childName.');\n    const ref = query.getRef().child(/** @type {!string} */ (change.childName));\n    const index = query.getQueryParams().getIndex();\n    return new DataEvent(\n      change.type as any,\n      this,\n      new DataSnapshot(change.snapshotNode, ref, index as any),\n      change.prevName\n    );\n  }\n\n  /**\n   * @inheritDoc\n   */\n  getEventRunner(eventData: CancelEvent | DataEvent): () => void {\n    const ctx = this.context_;\n    if (eventData.getEventType() === 'cancel') {\n      assert(\n        this.cancelCallback_,\n        'Raising a cancel event on a listener with no cancel callback'\n      );\n      const cancelCB = this.cancelCallback_;\n      return function() {\n        // We know that error exists, we checked above that this is a cancel event\n        cancelCB.call(ctx, (eventData as CancelEvent).error);\n      };\n    } else {\n      const cb = this.callbacks_[(eventData as DataEvent).eventType];\n      return function() {\n        cb.call(\n          ctx,\n          (eventData as DataEvent).snapshot,\n          (eventData as DataEvent).prevName\n        );\n      };\n    }\n  }\n\n  /**\n   * @inheritDoc\n   */\n  matches(other: EventRegistration): boolean {\n    if (other instanceof ChildEventRegistration) {\n      if (!this.callbacks_ || !other.callbacks_) {\n        return true;\n      } else if (this.context_ === other.context_) {\n        const otherCount = getCount(other.callbacks_);\n        const thisCount = getCount(this.callbacks_);\n        if (otherCount === thisCount) {\n          // If count is 1, do an exact match on eventType, if either is defined but null, it's a match.\n          //  If event types don't match, not a match\n          // If count is not 1, exact match across all\n\n          if (otherCount === 1) {\n            const otherKey /** @type {!string} */ = getAnyKey(other.callbacks_);\n            const thisKey /** @type {!string} */ = getAnyKey(this.callbacks_);\n            return (\n              thisKey === otherKey &&\n              (!other.callbacks_[otherKey] ||\n                !this.callbacks_[thisKey] ||\n                other.callbacks_[otherKey] === this.callbacks_[thisKey])\n            );\n          } else {\n            // Exact match on each key.\n            return every(\n              this.callbacks_,\n              (eventType, cb) => other.callbacks_[eventType] === cb\n            );\n          }\n        }\n      }\n    }\n\n    return false;\n  }\n\n  /**\n   * @inheritDoc\n   */\n  hasAnyCallback(): boolean {\n    return this.callbacks_ !== null;\n  }\n}\n"]},"metadata":{},"sourceType":"script"}