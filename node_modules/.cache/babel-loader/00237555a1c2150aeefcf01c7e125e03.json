{"ast":null,"code":"'use strict';\n\nmodule.exports = stringify;\nvar indentation = ''; // eslint-disable-next-line\n\nconst strEscapeSequencesRegExp = /[\\x00-\\x1f\\x22\\x5c]/; // eslint-disable-next-line\n\nconst strEscapeSequencesReplacer = /[\\x00-\\x1f\\x22\\x5c]/g; // Escaped special characters. Use empty strings to fill up unused entries.\n\nconst meta = ['\\\\u0000', '\\\\u0001', '\\\\u0002', '\\\\u0003', '\\\\u0004', '\\\\u0005', '\\\\u0006', '\\\\u0007', '\\\\b', '\\\\t', '\\\\n', '\\\\u000b', '\\\\f', '\\\\r', '\\\\u000e', '\\\\u000f', '\\\\u0010', '\\\\u0011', '\\\\u0012', '\\\\u0013', '\\\\u0014', '\\\\u0015', '\\\\u0016', '\\\\u0017', '\\\\u0018', '\\\\u0019', '\\\\u001a', '\\\\u001b', '\\\\u001c', '\\\\u001d', '\\\\u001e', '\\\\u001f', '', '', '\\\\\"', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '\\\\\\\\'];\n\nfunction escapeFn(str) {\n  return meta[str.charCodeAt(0)];\n} // Escape control characters, double quotes and the backslash.\n// Note: it is faster to run this only once for a big string instead of only for\n// the parts that it is necessary for. But this is only true if we do not add\n// extra indentation to the string before.\n\n\nfunction strEscape(str) {\n  // Some magic numbers that worked out fine while benchmarking with v8 6.0\n  if (str.length < 5000 && !strEscapeSequencesRegExp.test(str)) {\n    return str;\n  }\n\n  if (str.length > 100) {\n    return str.replace(strEscapeSequencesReplacer, escapeFn);\n  }\n\n  var result = '';\n  var last = 0;\n\n  for (var i = 0; i < str.length; i++) {\n    const point = str.charCodeAt(i);\n\n    if (point === 34 || point === 92 || point < 32) {\n      if (last === i) {\n        result += meta[point];\n      } else {\n        result += `${str.slice(last, i)}${meta[point]}`;\n      }\n\n      last = i + 1;\n    }\n  }\n\n  if (last === 0) {\n    result = str;\n  } else if (last !== i) {\n    result += str.slice(last);\n  }\n\n  return result;\n} // Full version: supports all options\n\n\nfunction stringifyFullFn(key, parent, stack, replacer, indent) {\n  var i, res, join;\n  const originalIndentation = indentation;\n  var value = parent[key];\n\n  if (typeof value === 'object' && value !== null && typeof value.toJSON === 'function') {\n    value = value.toJSON(key);\n  }\n\n  value = replacer.call(parent, key, value);\n\n  switch (typeof value) {\n    case 'object':\n      if (value === null) {\n        return 'null';\n      }\n\n      for (i = 0; i < stack.length; i++) {\n        if (stack[i] === value) {\n          return '\"[Circular]\"';\n        }\n      }\n\n      if (Array.isArray(value)) {\n        if (value.length === 0) {\n          return '[]';\n        }\n\n        stack.push(value);\n        res = '[';\n        indentation += indent;\n        res += `\\n${indentation}`;\n        join = `,\\n${indentation}`; // Use null as placeholder for non-JSON values.\n\n        for (i = 0; i < value.length - 1; i++) {\n          const tmp = stringifyFullFn(i, value, stack, replacer, indent);\n          res += tmp !== undefined ? tmp : 'null';\n          res += join;\n        }\n\n        const tmp = stringifyFullFn(i, value, stack, replacer, indent);\n        res += tmp !== undefined ? tmp : 'null';\n\n        if (indentation !== '') {\n          res += `\\n${originalIndentation}`;\n        }\n\n        res += ']';\n        stack.pop();\n        indentation = originalIndentation;\n        return res;\n      }\n\n      var keys = insertSort(Object.keys(value));\n\n      if (keys.length === 0) {\n        return '{}';\n      }\n\n      stack.push(value);\n      res = '{';\n      indentation += indent;\n      res += `\\n${indentation}`;\n      join = `,\\n${indentation}`;\n      var separator = '';\n\n      for (i = 0; i < keys.length; i++) {\n        key = keys[i];\n        const tmp = stringifyFullFn(key, value, stack, replacer, indent);\n\n        if (tmp !== undefined) {\n          res += `${separator}\"${strEscape(key)}\": ${tmp}`;\n          separator = join;\n        }\n      }\n\n      if (separator !== '') {\n        res += `\\n${originalIndentation}`;\n      } else {\n        res = '{';\n      }\n\n      res += '}';\n      stack.pop();\n      indentation = originalIndentation;\n      return res;\n\n    case 'string':\n      return `\"${strEscape(value)}\"`;\n\n    case 'number':\n      // JSON numbers must be finite. Encode non-finite numbers as null.\n      return isFinite(value) ? String(value) : 'null';\n\n    case 'boolean':\n      return value === true ? 'true' : 'false';\n  }\n}\n\nfunction stringifyFullArr(key, value, stack, replacer, indent) {\n  var i, res, join;\n  const originalIndentation = indentation;\n\n  if (typeof value === 'object' && value !== null && typeof value.toJSON === 'function') {\n    value = value.toJSON(key);\n  }\n\n  switch (typeof value) {\n    case 'object':\n      if (value === null) {\n        return 'null';\n      }\n\n      for (i = 0; i < stack.length; i++) {\n        if (stack[i] === value) {\n          return '\"[Circular]\"';\n        }\n      }\n\n      if (Array.isArray(value)) {\n        if (value.length === 0) {\n          return '[]';\n        }\n\n        stack.push(value);\n        res = '[';\n        indentation += indent;\n        res += `\\n${indentation}`;\n        join = `,\\n${indentation}`; // Use null as placeholder for non-JSON values.\n\n        for (i = 0; i < value.length - 1; i++) {\n          const tmp = stringifyFullArr(i, value[i], stack, replacer, indent);\n          res += tmp !== undefined ? tmp : 'null';\n          res += join;\n        }\n\n        const tmp = stringifyFullArr(i, value[i], stack, replacer, indent);\n        res += tmp !== undefined ? tmp : 'null';\n\n        if (indentation !== '') {\n          res += `\\n${originalIndentation}`;\n        }\n\n        res += ']';\n        stack.pop();\n        indentation = originalIndentation;\n        return res;\n      }\n\n      if (replacer.length === 0) {\n        return '{}';\n      }\n\n      stack.push(value);\n      res = '{';\n      indentation += indent;\n      res += `\\n${indentation}`;\n      join = `,\\n${indentation}`;\n      var separator = '';\n\n      for (i = 0; i < replacer.length; i++) {\n        if (typeof replacer[i] === 'string' || typeof replacer[i] === 'number') {\n          key = replacer[i];\n          const tmp = stringifyFullArr(key, value[key], stack, replacer, indent);\n\n          if (tmp !== undefined) {\n            res += `${separator}\"${strEscape(key)}\": ${tmp}`;\n            separator = join;\n          }\n        }\n      }\n\n      if (separator !== '') {\n        res += `\\n${originalIndentation}`;\n      } else {\n        res = '{';\n      }\n\n      res += '}';\n      stack.pop();\n      indentation = originalIndentation;\n      return res;\n\n    case 'string':\n      return `\"${strEscape(value)}\"`;\n\n    case 'number':\n      // JSON numbers must be finite. Encode non-finite numbers as null.\n      return isFinite(value) ? String(value) : 'null';\n\n    case 'boolean':\n      return value === true ? 'true' : 'false';\n  }\n} // Supports only the spacer option\n\n\nfunction stringifyIndent(key, value, stack, indent) {\n  var i, res, join;\n  const originalIndentation = indentation;\n\n  switch (typeof value) {\n    case 'object':\n      if (value === null) {\n        return 'null';\n      }\n\n      if (typeof value.toJSON === 'function') {\n        value = value.toJSON(key); // Prevent calling `toJSON` again.\n\n        if (typeof value !== 'object') {\n          return stringifyIndent(key, value, stack, indent);\n        }\n\n        if (value === null) {\n          return 'null';\n        }\n      }\n\n      for (i = 0; i < stack.length; i++) {\n        if (stack[i] === value) {\n          return '\"[Circular]\"';\n        }\n      }\n\n      if (Array.isArray(value)) {\n        if (value.length === 0) {\n          return '[]';\n        }\n\n        stack.push(value);\n        res = '[';\n        indentation += indent;\n        res += `\\n${indentation}`;\n        join = `,\\n${indentation}`; // Use null as placeholder for non-JSON values.\n\n        for (i = 0; i < value.length - 1; i++) {\n          const tmp = stringifyIndent(i, value[i], stack, indent);\n          res += tmp !== undefined ? tmp : 'null';\n          res += join;\n        }\n\n        const tmp = stringifyIndent(i, value[i], stack, indent);\n        res += tmp !== undefined ? tmp : 'null';\n\n        if (indentation !== '') {\n          res += `\\n${originalIndentation}`;\n        }\n\n        res += ']';\n        stack.pop();\n        indentation = originalIndentation;\n        return res;\n      }\n\n      var keys = insertSort(Object.keys(value));\n\n      if (keys.length === 0) {\n        return '{}';\n      }\n\n      stack.push(value);\n      res = '{';\n      indentation += indent;\n      res += `\\n${indentation}`;\n      join = `,\\n${indentation}`;\n      var separator = '';\n\n      for (i = 0; i < keys.length; i++) {\n        key = keys[i];\n        const tmp = stringifyIndent(key, value[key], stack, indent);\n\n        if (tmp !== undefined) {\n          res += `${separator}\"${strEscape(key)}\": ${tmp}`;\n          separator = join;\n        }\n      }\n\n      if (separator !== '') {\n        res += `\\n${originalIndentation}`;\n      } else {\n        res = '{';\n      }\n\n      res += '}';\n      stack.pop();\n      indentation = originalIndentation;\n      return res;\n\n    case 'string':\n      return `\"${strEscape(value)}\"`;\n\n    case 'number':\n      // JSON numbers must be finite. Encode non-finite numbers as null.\n      return isFinite(value) ? String(value) : 'null';\n\n    case 'boolean':\n      return value === true ? 'true' : 'false';\n  }\n} // Supports only the replacer option\n\n\nfunction stringifyReplacerArr(key, value, stack, replacer) {\n  var i, res; // If the value has a toJSON method, call it to obtain a replacement value.\n\n  if (typeof value === 'object' && value !== null && typeof value.toJSON === 'function') {\n    value = value.toJSON(key);\n  }\n\n  switch (typeof value) {\n    case 'object':\n      if (value === null) {\n        return 'null';\n      }\n\n      for (i = 0; i < stack.length; i++) {\n        if (stack[i] === value) {\n          return '\"[Circular]\"';\n        }\n      }\n\n      if (Array.isArray(value)) {\n        if (value.length === 0) {\n          return '[]';\n        }\n\n        stack.push(value);\n        res = '['; // Use null as placeholder for non-JSON values.\n\n        for (i = 0; i < value.length - 1; i++) {\n          const tmp = stringifyReplacerArr(i, value[i], stack, replacer);\n          res += tmp !== undefined ? tmp : 'null';\n          res += ',';\n        }\n\n        const tmp = stringifyReplacerArr(i, value[i], stack, replacer);\n        res += tmp !== undefined ? tmp : 'null';\n        res += ']';\n        stack.pop();\n        return res;\n      }\n\n      if (replacer.length === 0) {\n        return '{}';\n      }\n\n      stack.push(value);\n      res = '{';\n      var separator = '';\n\n      for (i = 0; i < replacer.length; i++) {\n        if (typeof replacer[i] === 'string' || typeof replacer[i] === 'number') {\n          key = replacer[i];\n          const tmp = stringifyReplacerArr(key, value[key], stack, replacer);\n\n          if (tmp !== undefined) {\n            res += `${separator}\"${strEscape(key)}\":${tmp}`;\n            separator = ',';\n          }\n        }\n      }\n\n      res += '}';\n      stack.pop();\n      return res;\n\n    case 'string':\n      return `\"${strEscape(value)}\"`;\n\n    case 'number':\n      // JSON numbers must be finite. Encode non-finite numbers as null.\n      return isFinite(value) ? String(value) : 'null';\n\n    case 'boolean':\n      return value === true ? 'true' : 'false';\n  }\n}\n\nfunction stringifyReplacerFn(key, parent, stack, replacer) {\n  var i, res;\n  var value = parent[key]; // If the value has a toJSON method, call it to obtain a replacement value.\n\n  if (typeof value === 'object' && value !== null && typeof value.toJSON === 'function') {\n    value = value.toJSON(key);\n  }\n\n  value = replacer.call(parent, key, value);\n\n  switch (typeof value) {\n    case 'object':\n      if (value === null) {\n        return 'null';\n      }\n\n      for (i = 0; i < stack.length; i++) {\n        if (stack[i] === value) {\n          return '\"[Circular]\"';\n        }\n      }\n\n      if (Array.isArray(value)) {\n        if (value.length === 0) {\n          return '[]';\n        }\n\n        stack.push(value);\n        res = '['; // Use null as placeholder for non-JSON values.\n\n        for (i = 0; i < value.length - 1; i++) {\n          const tmp = stringifyReplacerFn(i, value, stack, replacer);\n          res += tmp !== undefined ? tmp : 'null';\n          res += ',';\n        }\n\n        const tmp = stringifyReplacerFn(i, value, stack, replacer);\n        res += tmp !== undefined ? tmp : 'null';\n        res += ']';\n        stack.pop();\n        return res;\n      }\n\n      var keys = insertSort(Object.keys(value));\n\n      if (keys.length === 0) {\n        return '{}';\n      }\n\n      stack.push(value);\n      res = '{';\n      var separator = '';\n\n      for (i = 0; i < keys.length; i++) {\n        key = keys[i];\n        const tmp = stringifyReplacerFn(key, value, stack, replacer);\n\n        if (tmp !== undefined) {\n          res += `${separator}\"${strEscape(key)}\":${tmp}`;\n          separator = ',';\n        }\n      }\n\n      res += '}';\n      stack.pop();\n      return res;\n\n    case 'string':\n      return `\"${strEscape(value)}\"`;\n\n    case 'number':\n      // JSON numbers must be finite. Encode non-finite numbers as null.\n      return isFinite(value) ? String(value) : 'null';\n\n    case 'boolean':\n      return value === true ? 'true' : 'false';\n  }\n} // Simple without any options\n\n\nfunction stringifySimple(key, value, stack) {\n  var i, res;\n\n  switch (typeof value) {\n    case 'object':\n      if (value === null) {\n        return 'null';\n      }\n\n      if (typeof value.toJSON === 'function') {\n        value = value.toJSON(key); // Prevent calling `toJSON` again\n\n        if (typeof value !== 'object') {\n          return stringifySimple(key, value, stack);\n        }\n\n        if (value === null) {\n          return 'null';\n        }\n      }\n\n      for (i = 0; i < stack.length; i++) {\n        if (stack[i] === value) {\n          return '\"[Circular]\"';\n        }\n      }\n\n      if (Array.isArray(value)) {\n        if (value.length === 0) {\n          return '[]';\n        }\n\n        stack.push(value);\n        res = '['; // Use null as placeholder for non-JSON values.\n\n        for (i = 0; i < value.length - 1; i++) {\n          const tmp = stringifySimple(i, value[i], stack);\n          res += tmp !== undefined ? tmp : 'null';\n          res += ',';\n        }\n\n        const tmp = stringifySimple(i, value[i], stack);\n        res += tmp !== undefined ? tmp : 'null';\n        res += ']';\n        stack.pop();\n        return res;\n      }\n\n      var keys = insertSort(Object.keys(value));\n\n      if (keys.length === 0) {\n        return '{}';\n      }\n\n      stack.push(value);\n      var separator = '';\n      res = '{';\n\n      for (i = 0; i < keys.length; i++) {\n        key = keys[i];\n        const tmp = stringifySimple(key, value[key], stack);\n\n        if (tmp !== undefined) {\n          res += `${separator}\"${strEscape(key)}\":${tmp}`;\n          separator = ',';\n        }\n      }\n\n      res += '}';\n      stack.pop();\n      return res;\n\n    case 'string':\n      return `\"${strEscape(value)}\"`;\n\n    case 'number':\n      // JSON numbers must be finite. Encode non-finite numbers as null.\n      // Convert the numbers implicit to a string instead of explicit.\n      return isFinite(value) ? String(value) : 'null';\n\n    case 'boolean':\n      return value === true ? 'true' : 'false';\n  }\n}\n\nfunction insertSort(arr) {\n  for (var i = 1; i < arr.length; i++) {\n    const tmp = arr[i];\n    var j = i;\n\n    while (j !== 0 && arr[j - 1] > tmp) {\n      arr[j] = arr[j - 1];\n      j--;\n    }\n\n    arr[j] = tmp;\n  }\n\n  return arr;\n}\n\nfunction stringify(value, replacer, spacer) {\n  var i;\n  var indent = '';\n  indentation = '';\n\n  if (arguments.length > 1) {\n    // If the spacer parameter is a number, make an indent string containing that\n    // many spaces.\n    if (typeof spacer === 'number') {\n      for (i = 0; i < spacer; i += 1) {\n        indent += ' ';\n      } // If the spacer parameter is a string, it will be used as the indent string.\n\n    } else if (typeof spacer === 'string') {\n      indent = spacer;\n    }\n\n    if (indent !== '') {\n      if (replacer !== undefined && replacer !== null) {\n        if (typeof replacer === 'function') {\n          return stringifyFullFn('', {\n            '': value\n          }, [], replacer, indent);\n        }\n\n        if (Array.isArray(replacer)) {\n          return stringifyFullArr('', value, [], replacer, indent);\n        }\n      }\n\n      return stringifyIndent('', value, [], indent);\n    }\n\n    if (typeof replacer === 'function') {\n      return stringifyReplacerFn('', {\n        '': value\n      }, [], replacer);\n    }\n\n    if (Array.isArray(replacer)) {\n      return stringifyReplacerArr('', value, [], replacer);\n    }\n  }\n\n  return stringifySimple('', value, []);\n}","map":{"version":3,"sources":["C:/Users/Sharik/Desktop/Projects/ReactProject/my-first-app/node_modules/safe-stable-stringify/stable.js"],"names":["module","exports","stringify","indentation","strEscapeSequencesRegExp","strEscapeSequencesReplacer","meta","escapeFn","str","charCodeAt","strEscape","length","test","replace","result","last","i","point","slice","stringifyFullFn","key","parent","stack","replacer","indent","res","join","originalIndentation","value","toJSON","call","Array","isArray","push","tmp","undefined","pop","keys","insertSort","Object","separator","isFinite","String","stringifyFullArr","stringifyIndent","stringifyReplacerArr","stringifyReplacerFn","stringifySimple","arr","j","spacer","arguments"],"mappings":"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","sourcesContent":["'use strict'\n\nmodule.exports = stringify\n\nvar indentation = ''\n// eslint-disable-next-line\nconst strEscapeSequencesRegExp = /[\\x00-\\x1f\\x22\\x5c]/\n// eslint-disable-next-line\nconst strEscapeSequencesReplacer = /[\\x00-\\x1f\\x22\\x5c]/g\n\n// Escaped special characters. Use empty strings to fill up unused entries.\nconst meta = [\n  '\\\\u0000', '\\\\u0001', '\\\\u0002', '\\\\u0003', '\\\\u0004',\n  '\\\\u0005', '\\\\u0006', '\\\\u0007', '\\\\b', '\\\\t',\n  '\\\\n', '\\\\u000b', '\\\\f', '\\\\r', '\\\\u000e',\n  '\\\\u000f', '\\\\u0010', '\\\\u0011', '\\\\u0012', '\\\\u0013',\n  '\\\\u0014', '\\\\u0015', '\\\\u0016', '\\\\u0017', '\\\\u0018',\n  '\\\\u0019', '\\\\u001a', '\\\\u001b', '\\\\u001c', '\\\\u001d',\n  '\\\\u001e', '\\\\u001f', '', '', '\\\\\"',\n  '', '', '', '', '', '', '', '', '', '',\n  '', '', '', '', '', '', '', '', '', '',\n  '', '', '', '', '', '', '', '', '', '',\n  '', '', '', '', '', '', '', '', '', '',\n  '', '', '', '', '', '', '', '', '', '',\n  '', '', '', '', '', '', '', '\\\\\\\\'\n]\n\nfunction escapeFn (str) {\n  return meta[str.charCodeAt(0)]\n}\n\n// Escape control characters, double quotes and the backslash.\n// Note: it is faster to run this only once for a big string instead of only for\n// the parts that it is necessary for. But this is only true if we do not add\n// extra indentation to the string before.\nfunction strEscape (str) {\n  // Some magic numbers that worked out fine while benchmarking with v8 6.0\n  if (str.length < 5000 && !strEscapeSequencesRegExp.test(str)) {\n    return str\n  }\n  if (str.length > 100) {\n    return str.replace(strEscapeSequencesReplacer, escapeFn)\n  }\n  var result = ''\n  var last = 0\n  for (var i = 0; i < str.length; i++) {\n    const point = str.charCodeAt(i)\n    if (point === 34 || point === 92 || point < 32) {\n      if (last === i) {\n        result += meta[point]\n      } else {\n        result += `${str.slice(last, i)}${meta[point]}`\n      }\n      last = i + 1\n    }\n  }\n  if (last === 0) {\n    result = str\n  } else if (last !== i) {\n    result += str.slice(last)\n  }\n  return result\n}\n\n// Full version: supports all options\nfunction stringifyFullFn (key, parent, stack, replacer, indent) {\n  var i, res, join\n  const originalIndentation = indentation\n  var value = parent[key]\n\n  if (typeof value === 'object' && value !== null && typeof value.toJSON === 'function') {\n    value = value.toJSON(key)\n  }\n  value = replacer.call(parent, key, value)\n\n  switch (typeof value) {\n    case 'object':\n      if (value === null) {\n        return 'null'\n      }\n      for (i = 0; i < stack.length; i++) {\n        if (stack[i] === value) {\n          return '\"[Circular]\"'\n        }\n      }\n      if (Array.isArray(value)) {\n        if (value.length === 0) {\n          return '[]'\n        }\n        stack.push(value)\n        res = '['\n        indentation += indent\n        res += `\\n${indentation}`\n        join = `,\\n${indentation}`\n        // Use null as placeholder for non-JSON values.\n        for (i = 0; i < value.length - 1; i++) {\n          const tmp = stringifyFullFn(i, value, stack, replacer, indent)\n          res += tmp !== undefined ? tmp : 'null'\n          res += join\n        }\n        const tmp = stringifyFullFn(i, value, stack, replacer, indent)\n        res += tmp !== undefined ? tmp : 'null'\n        if (indentation !== '') {\n          res += `\\n${originalIndentation}`\n        }\n        res += ']'\n        stack.pop()\n        indentation = originalIndentation\n        return res\n      }\n\n      var keys = insertSort(Object.keys(value))\n      if (keys.length === 0) {\n        return '{}'\n      }\n      stack.push(value)\n      res = '{'\n      indentation += indent\n      res += `\\n${indentation}`\n      join = `,\\n${indentation}`\n      var separator = ''\n      for (i = 0; i < keys.length; i++) {\n        key = keys[i]\n        const tmp = stringifyFullFn(key, value, stack, replacer, indent)\n        if (tmp !== undefined) {\n          res += `${separator}\"${strEscape(key)}\": ${tmp}`\n          separator = join\n        }\n      }\n      if (separator !== '') {\n        res += `\\n${originalIndentation}`\n      } else {\n        res = '{'\n      }\n      res += '}'\n      stack.pop()\n      indentation = originalIndentation\n      return res\n    case 'string':\n      return `\"${strEscape(value)}\"`\n    case 'number':\n      // JSON numbers must be finite. Encode non-finite numbers as null.\n      return isFinite(value) ? String(value) : 'null'\n    case 'boolean':\n      return value === true ? 'true' : 'false'\n  }\n}\n\nfunction stringifyFullArr (key, value, stack, replacer, indent) {\n  var i, res, join\n  const originalIndentation = indentation\n\n  if (typeof value === 'object' && value !== null && typeof value.toJSON === 'function') {\n    value = value.toJSON(key)\n  }\n\n  switch (typeof value) {\n    case 'object':\n      if (value === null) {\n        return 'null'\n      }\n      for (i = 0; i < stack.length; i++) {\n        if (stack[i] === value) {\n          return '\"[Circular]\"'\n        }\n      }\n      if (Array.isArray(value)) {\n        if (value.length === 0) {\n          return '[]'\n        }\n        stack.push(value)\n        res = '['\n        indentation += indent\n        res += `\\n${indentation}`\n        join = `,\\n${indentation}`\n        // Use null as placeholder for non-JSON values.\n        for (i = 0; i < value.length - 1; i++) {\n          const tmp = stringifyFullArr(i, value[i], stack, replacer, indent)\n          res += tmp !== undefined ? tmp : 'null'\n          res += join\n        }\n        const tmp = stringifyFullArr(i, value[i], stack, replacer, indent)\n        res += tmp !== undefined ? tmp : 'null'\n        if (indentation !== '') {\n          res += `\\n${originalIndentation}`\n        }\n        res += ']'\n        stack.pop()\n        indentation = originalIndentation\n        return res\n      }\n\n      if (replacer.length === 0) {\n        return '{}'\n      }\n      stack.push(value)\n      res = '{'\n      indentation += indent\n      res += `\\n${indentation}`\n      join = `,\\n${indentation}`\n      var separator = ''\n      for (i = 0; i < replacer.length; i++) {\n        if (typeof replacer[i] === 'string' || typeof replacer[i] === 'number') {\n          key = replacer[i]\n          const tmp = stringifyFullArr(key, value[key], stack, replacer, indent)\n          if (tmp !== undefined) {\n            res += `${separator}\"${strEscape(key)}\": ${tmp}`\n            separator = join\n          }\n        }\n      }\n      if (separator !== '') {\n        res += `\\n${originalIndentation}`\n      } else {\n        res = '{'\n      }\n      res += '}'\n      stack.pop()\n      indentation = originalIndentation\n      return res\n    case 'string':\n      return `\"${strEscape(value)}\"`\n    case 'number':\n      // JSON numbers must be finite. Encode non-finite numbers as null.\n      return isFinite(value) ? String(value) : 'null'\n    case 'boolean':\n      return value === true ? 'true' : 'false'\n  }\n}\n\n// Supports only the spacer option\nfunction stringifyIndent (key, value, stack, indent) {\n  var i, res, join\n  const originalIndentation = indentation\n\n  switch (typeof value) {\n    case 'object':\n      if (value === null) {\n        return 'null'\n      }\n      if (typeof value.toJSON === 'function') {\n        value = value.toJSON(key)\n        // Prevent calling `toJSON` again.\n        if (typeof value !== 'object') {\n          return stringifyIndent(key, value, stack, indent)\n        }\n        if (value === null) {\n          return 'null'\n        }\n      }\n      for (i = 0; i < stack.length; i++) {\n        if (stack[i] === value) {\n          return '\"[Circular]\"'\n        }\n      }\n\n      if (Array.isArray(value)) {\n        if (value.length === 0) {\n          return '[]'\n        }\n        stack.push(value)\n        res = '['\n        indentation += indent\n        res += `\\n${indentation}`\n        join = `,\\n${indentation}`\n        // Use null as placeholder for non-JSON values.\n        for (i = 0; i < value.length - 1; i++) {\n          const tmp = stringifyIndent(i, value[i], stack, indent)\n          res += tmp !== undefined ? tmp : 'null'\n          res += join\n        }\n        const tmp = stringifyIndent(i, value[i], stack, indent)\n        res += tmp !== undefined ? tmp : 'null'\n        if (indentation !== '') {\n          res += `\\n${originalIndentation}`\n        }\n        res += ']'\n        stack.pop()\n        indentation = originalIndentation\n        return res\n      }\n\n      var keys = insertSort(Object.keys(value))\n      if (keys.length === 0) {\n        return '{}'\n      }\n      stack.push(value)\n      res = '{'\n      indentation += indent\n      res += `\\n${indentation}`\n      join = `,\\n${indentation}`\n      var separator = ''\n      for (i = 0; i < keys.length; i++) {\n        key = keys[i]\n        const tmp = stringifyIndent(key, value[key], stack, indent)\n        if (tmp !== undefined) {\n          res += `${separator}\"${strEscape(key)}\": ${tmp}`\n          separator = join\n        }\n      }\n      if (separator !== '') {\n        res += `\\n${originalIndentation}`\n      } else {\n        res = '{'\n      }\n      res += '}'\n      stack.pop()\n      indentation = originalIndentation\n      return res\n    case 'string':\n      return `\"${strEscape(value)}\"`\n    case 'number':\n      // JSON numbers must be finite. Encode non-finite numbers as null.\n      return isFinite(value) ? String(value) : 'null'\n    case 'boolean':\n      return value === true ? 'true' : 'false'\n  }\n}\n\n// Supports only the replacer option\nfunction stringifyReplacerArr (key, value, stack, replacer) {\n  var i, res\n  // If the value has a toJSON method, call it to obtain a replacement value.\n  if (typeof value === 'object' && value !== null && typeof value.toJSON === 'function') {\n    value = value.toJSON(key)\n  }\n\n  switch (typeof value) {\n    case 'object':\n      if (value === null) {\n        return 'null'\n      }\n      for (i = 0; i < stack.length; i++) {\n        if (stack[i] === value) {\n          return '\"[Circular]\"'\n        }\n      }\n      if (Array.isArray(value)) {\n        if (value.length === 0) {\n          return '[]'\n        }\n        stack.push(value)\n        res = '['\n        // Use null as placeholder for non-JSON values.\n        for (i = 0; i < value.length - 1; i++) {\n          const tmp = stringifyReplacerArr(i, value[i], stack, replacer)\n          res += tmp !== undefined ? tmp : 'null'\n          res += ','\n        }\n        const tmp = stringifyReplacerArr(i, value[i], stack, replacer)\n        res += tmp !== undefined ? tmp : 'null'\n        res += ']'\n        stack.pop()\n        return res\n      }\n\n      if (replacer.length === 0) {\n        return '{}'\n      }\n      stack.push(value)\n      res = '{'\n      var separator = ''\n      for (i = 0; i < replacer.length; i++) {\n        if (typeof replacer[i] === 'string' || typeof replacer[i] === 'number') {\n          key = replacer[i]\n          const tmp = stringifyReplacerArr(key, value[key], stack, replacer)\n          if (tmp !== undefined) {\n            res += `${separator}\"${strEscape(key)}\":${tmp}`\n            separator = ','\n          }\n        }\n      }\n      res += '}'\n      stack.pop()\n      return res\n    case 'string':\n      return `\"${strEscape(value)}\"`\n    case 'number':\n      // JSON numbers must be finite. Encode non-finite numbers as null.\n      return isFinite(value) ? String(value) : 'null'\n    case 'boolean':\n      return value === true ? 'true' : 'false'\n  }\n}\n\nfunction stringifyReplacerFn (key, parent, stack, replacer) {\n  var i, res\n  var value = parent[key]\n  // If the value has a toJSON method, call it to obtain a replacement value.\n  if (typeof value === 'object' && value !== null && typeof value.toJSON === 'function') {\n    value = value.toJSON(key)\n  }\n  value = replacer.call(parent, key, value)\n\n  switch (typeof value) {\n    case 'object':\n      if (value === null) {\n        return 'null'\n      }\n      for (i = 0; i < stack.length; i++) {\n        if (stack[i] === value) {\n          return '\"[Circular]\"'\n        }\n      }\n      if (Array.isArray(value)) {\n        if (value.length === 0) {\n          return '[]'\n        }\n        stack.push(value)\n        res = '['\n        // Use null as placeholder for non-JSON values.\n        for (i = 0; i < value.length - 1; i++) {\n          const tmp = stringifyReplacerFn(i, value, stack, replacer)\n          res += tmp !== undefined ? tmp : 'null'\n          res += ','\n        }\n        const tmp = stringifyReplacerFn(i, value, stack, replacer)\n        res += tmp !== undefined ? tmp : 'null'\n        res += ']'\n        stack.pop()\n        return res\n      }\n\n      var keys = insertSort(Object.keys(value))\n      if (keys.length === 0) {\n        return '{}'\n      }\n      stack.push(value)\n      res = '{'\n      var separator = ''\n      for (i = 0; i < keys.length; i++) {\n        key = keys[i]\n        const tmp = stringifyReplacerFn(key, value, stack, replacer)\n        if (tmp !== undefined) {\n          res += `${separator}\"${strEscape(key)}\":${tmp}`\n          separator = ','\n        }\n      }\n      res += '}'\n      stack.pop()\n      return res\n    case 'string':\n      return `\"${strEscape(value)}\"`\n    case 'number':\n      // JSON numbers must be finite. Encode non-finite numbers as null.\n      return isFinite(value) ? String(value) : 'null'\n    case 'boolean':\n      return value === true ? 'true' : 'false'\n  }\n}\n\n// Simple without any options\nfunction stringifySimple (key, value, stack) {\n  var i, res\n  switch (typeof value) {\n    case 'object':\n      if (value === null) {\n        return 'null'\n      }\n      if (typeof value.toJSON === 'function') {\n        value = value.toJSON(key)\n        // Prevent calling `toJSON` again\n        if (typeof value !== 'object') {\n          return stringifySimple(key, value, stack)\n        }\n        if (value === null) {\n          return 'null'\n        }\n      }\n      for (i = 0; i < stack.length; i++) {\n        if (stack[i] === value) {\n          return '\"[Circular]\"'\n        }\n      }\n\n      if (Array.isArray(value)) {\n        if (value.length === 0) {\n          return '[]'\n        }\n        stack.push(value)\n        res = '['\n        // Use null as placeholder for non-JSON values.\n        for (i = 0; i < value.length - 1; i++) {\n          const tmp = stringifySimple(i, value[i], stack)\n          res += tmp !== undefined ? tmp : 'null'\n          res += ','\n        }\n        const tmp = stringifySimple(i, value[i], stack)\n        res += tmp !== undefined ? tmp : 'null'\n        res += ']'\n        stack.pop()\n        return res\n      }\n\n      var keys = insertSort(Object.keys(value))\n      if (keys.length === 0) {\n        return '{}'\n      }\n      stack.push(value)\n      var separator = ''\n      res = '{'\n      for (i = 0; i < keys.length; i++) {\n        key = keys[i]\n        const tmp = stringifySimple(key, value[key], stack)\n        if (tmp !== undefined) {\n          res += `${separator}\"${strEscape(key)}\":${tmp}`\n          separator = ','\n        }\n      }\n      res += '}'\n      stack.pop()\n      return res\n    case 'string':\n      return `\"${strEscape(value)}\"`\n    case 'number':\n      // JSON numbers must be finite. Encode non-finite numbers as null.\n      // Convert the numbers implicit to a string instead of explicit.\n      return isFinite(value) ? String(value) : 'null'\n    case 'boolean':\n      return value === true ? 'true' : 'false'\n  }\n}\n\nfunction insertSort (arr) {\n  for (var i = 1; i < arr.length; i++) {\n    const tmp = arr[i]\n    var j = i\n    while (j !== 0 && arr[j - 1] > tmp) {\n      arr[j] = arr[j - 1]\n      j--\n    }\n    arr[j] = tmp\n  }\n\n  return arr\n}\n\nfunction stringify (value, replacer, spacer) {\n  var i\n  var indent = ''\n  indentation = ''\n\n  if (arguments.length > 1) {\n    // If the spacer parameter is a number, make an indent string containing that\n    // many spaces.\n    if (typeof spacer === 'number') {\n      for (i = 0; i < spacer; i += 1) {\n        indent += ' '\n      }\n    // If the spacer parameter is a string, it will be used as the indent string.\n    } else if (typeof spacer === 'string') {\n      indent = spacer\n    }\n    if (indent !== '') {\n      if (replacer !== undefined && replacer !== null) {\n        if (typeof replacer === 'function') {\n          return stringifyFullFn('', { '': value }, [], replacer, indent)\n        }\n        if (Array.isArray(replacer)) {\n          return stringifyFullArr('', value, [], replacer, indent)\n        }\n      }\n      return stringifyIndent('', value, [], indent)\n    }\n    if (typeof replacer === 'function') {\n      return stringifyReplacerFn('', { '': value }, [], replacer)\n    }\n    if (Array.isArray(replacer)) {\n      return stringifyReplacerArr('', value, [], replacer)\n    }\n  }\n  return stringifySimple('', value, [])\n}\n"]},"metadata":{},"sourceType":"script"}