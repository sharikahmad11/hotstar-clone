{"ast":null,"code":"\"use strict\";\n/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar CacheNode_1 = require(\"./view/CacheNode\");\n\nvar ChildrenNode_1 = require(\"./snap/ChildrenNode\");\n\nvar util_1 = require(\"@firebase/util\");\n\nvar util_2 = require(\"@firebase/util\");\n\nvar ViewCache_1 = require(\"./view/ViewCache\");\n\nvar View_1 = require(\"./view/View\");\n\nvar __referenceConstructor;\n/**\n * SyncPoint represents a single location in a SyncTree with 1 or more event registrations, meaning we need to\n * maintain 1 or more Views at this location to cache server data and raise appropriate events for server changes\n * and user writes (set, transaction, update).\n *\n * It's responsible for:\n *  - Maintaining the set of 1 or more views necessary at this location (a SyncPoint with 0 views should be removed).\n *  - Proxying user / server operations to the views as appropriate (i.e. applyServerOverwrite,\n *    applyUserOverwrite, etc.)\n */\n\n\nvar SyncPoint =\n/** @class */\nfunction () {\n  function SyncPoint() {\n    /**\n     * The Views being tracked at this location in the tree, stored as a map where the key is a\n     * queryId and the value is the View for that query.\n     *\n     * NOTE: This list will be quite small (usually 1, but perhaps 2 or 3; any more is an odd use case).\n     *\n     * @type {!Object.<!string, !View>}\n     * @private\n     */\n    this.views_ = {};\n  }\n\n  Object.defineProperty(SyncPoint, \"__referenceConstructor\", {\n    get: function () {\n      util_1.assert(__referenceConstructor, 'Reference.ts has not been loaded');\n      return __referenceConstructor;\n    },\n    set: function (val) {\n      util_1.assert(!__referenceConstructor, '__referenceConstructor has already been defined');\n      __referenceConstructor = val;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\n   * @return {boolean}\n   */\n\n  SyncPoint.prototype.isEmpty = function () {\n    return util_2.isEmpty(this.views_);\n  };\n  /**\n   *\n   * @param {!Operation} operation\n   * @param {!WriteTreeRef} writesCache\n   * @param {?Node} optCompleteServerCache\n   * @return {!Array.<!Event>}\n   */\n\n\n  SyncPoint.prototype.applyOperation = function (operation, writesCache, optCompleteServerCache) {\n    var queryId = operation.source.queryId;\n\n    if (queryId !== null) {\n      var view = util_2.safeGet(this.views_, queryId);\n      util_1.assert(view != null, 'SyncTree gave us an op for an invalid query.');\n      return view.applyOperation(operation, writesCache, optCompleteServerCache);\n    } else {\n      var events_1 = [];\n      util_2.forEach(this.views_, function (key, view) {\n        events_1 = events_1.concat(view.applyOperation(operation, writesCache, optCompleteServerCache));\n      });\n      return events_1;\n    }\n  };\n  /**\n   * Add an event callback for the specified query.\n   *\n   * @param {!Query} query\n   * @param {!EventRegistration} eventRegistration\n   * @param {!WriteTreeRef} writesCache\n   * @param {?Node} serverCache Complete server cache, if we have it.\n   * @param {boolean} serverCacheComplete\n   * @return {!Array.<!Event>} Events to raise.\n   */\n\n\n  SyncPoint.prototype.addEventRegistration = function (query, eventRegistration, writesCache, serverCache, serverCacheComplete) {\n    var queryId = query.queryIdentifier();\n    var view = util_2.safeGet(this.views_, queryId);\n\n    if (!view) {\n      // TODO: make writesCache take flag for complete server node\n      var eventCache = writesCache.calcCompleteEventCache(serverCacheComplete ? serverCache : null);\n      var eventCacheComplete = false;\n\n      if (eventCache) {\n        eventCacheComplete = true;\n      } else if (serverCache instanceof ChildrenNode_1.ChildrenNode) {\n        eventCache = writesCache.calcCompleteEventChildren(serverCache);\n        eventCacheComplete = false;\n      } else {\n        eventCache = ChildrenNode_1.ChildrenNode.EMPTY_NODE;\n        eventCacheComplete = false;\n      }\n\n      var viewCache = new ViewCache_1.ViewCache(new CacheNode_1.CacheNode(\n      /** @type {!Node} */\n      eventCache, eventCacheComplete, false), new CacheNode_1.CacheNode(\n      /** @type {!Node} */\n      serverCache, serverCacheComplete, false));\n      view = new View_1.View(query, viewCache);\n      this.views_[queryId] = view;\n    } // This is guaranteed to exist now, we just created anything that was missing\n\n\n    view.addEventRegistration(eventRegistration);\n    return view.getInitialEvents(eventRegistration);\n  };\n  /**\n   * Remove event callback(s).  Return cancelEvents if a cancelError is specified.\n   *\n   * If query is the default query, we'll check all views for the specified eventRegistration.\n   * If eventRegistration is null, we'll remove all callbacks for the specified view(s).\n   *\n   * @param {!Query} query\n   * @param {?EventRegistration} eventRegistration If null, remove all callbacks.\n   * @param {Error=} cancelError If a cancelError is provided, appropriate cancel events will be returned.\n   * @return {{removed:!Array.<!Query>, events:!Array.<!Event>}} removed queries and any cancel events\n   */\n\n\n  SyncPoint.prototype.removeEventRegistration = function (query, eventRegistration, cancelError) {\n    var queryId = query.queryIdentifier();\n    var removed = [];\n    var cancelEvents = [];\n    var hadCompleteView = this.hasCompleteView();\n\n    if (queryId === 'default') {\n      // When you do ref.off(...), we search all views for the registration to remove.\n      var self_1 = this;\n      util_2.forEach(this.views_, function (viewQueryId, view) {\n        cancelEvents = cancelEvents.concat(view.removeEventRegistration(eventRegistration, cancelError));\n\n        if (view.isEmpty()) {\n          delete self_1.views_[viewQueryId]; // We'll deal with complete views later.\n\n          if (!view.getQuery().getQueryParams().loadsAllData()) {\n            removed.push(view.getQuery());\n          }\n        }\n      });\n    } else {\n      // remove the callback from the specific view.\n      var view = util_2.safeGet(this.views_, queryId);\n\n      if (view) {\n        cancelEvents = cancelEvents.concat(view.removeEventRegistration(eventRegistration, cancelError));\n\n        if (view.isEmpty()) {\n          delete this.views_[queryId]; // We'll deal with complete views later.\n\n          if (!view.getQuery().getQueryParams().loadsAllData()) {\n            removed.push(view.getQuery());\n          }\n        }\n      }\n    }\n\n    if (hadCompleteView && !this.hasCompleteView()) {\n      // We removed our last complete view.\n      removed.push(new SyncPoint.__referenceConstructor(query.repo, query.path));\n    }\n\n    return {\n      removed: removed,\n      events: cancelEvents\n    };\n  };\n  /**\n   * @return {!Array.<!View>}\n   */\n\n\n  SyncPoint.prototype.getQueryViews = function () {\n    var _this = this;\n\n    var values = Object.keys(this.views_).map(function (key) {\n      return _this.views_[key];\n    });\n    return values.filter(function (view) {\n      return !view.getQuery().getQueryParams().loadsAllData();\n    });\n  };\n  /**\n   *\n   * @param {!Path} path The path to the desired complete snapshot\n   * @return {?Node} A complete cache, if it exists\n   */\n\n\n  SyncPoint.prototype.getCompleteServerCache = function (path) {\n    var serverCache = null;\n    util_2.forEach(this.views_, function (key, view) {\n      serverCache = serverCache || view.getCompleteServerCache(path);\n    });\n    return serverCache;\n  };\n  /**\n   * @param {!Query} query\n   * @return {?View}\n   */\n\n\n  SyncPoint.prototype.viewForQuery = function (query) {\n    var params = query.getQueryParams();\n\n    if (params.loadsAllData()) {\n      return this.getCompleteView();\n    } else {\n      var queryId = query.queryIdentifier();\n      return util_2.safeGet(this.views_, queryId);\n    }\n  };\n  /**\n   * @param {!Query} query\n   * @return {boolean}\n   */\n\n\n  SyncPoint.prototype.viewExistsForQuery = function (query) {\n    return this.viewForQuery(query) != null;\n  };\n  /**\n   * @return {boolean}\n   */\n\n\n  SyncPoint.prototype.hasCompleteView = function () {\n    return this.getCompleteView() != null;\n  };\n  /**\n   * @return {?View}\n   */\n\n\n  SyncPoint.prototype.getCompleteView = function () {\n    var completeView = util_2.findValue(this.views_, function (view) {\n      return view.getQuery().getQueryParams().loadsAllData();\n    });\n    return completeView || null;\n  };\n\n  return SyncPoint;\n}();\n\nexports.SyncPoint = SyncPoint;","map":{"version":3,"sources":["../src/core/SyncPoint.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { CacheNode } from './view/CacheNode';\nimport { ChildrenNode } from './snap/ChildrenNode';\nimport { assert } from '@firebase/util';\nimport { isEmpty, forEach, findValue, safeGet } from '@firebase/util';\nimport { ViewCache } from './view/ViewCache';\nimport { View } from './view/View';\nimport { Operation } from './operation/Operation';\nimport { WriteTreeRef } from './WriteTree';\nimport { Query } from '../api/Query';\nimport { EventRegistration } from './view/EventRegistration';\nimport { Node } from './snap/Node';\nimport { Path } from './util/Path';\nimport { Event } from './view/Event';\nimport { Reference, ReferenceConstructor } from '../api/Reference';\n\nlet __referenceConstructor: ReferenceConstructor;\n\n/**\n * SyncPoint represents a single location in a SyncTree with 1 or more event registrations, meaning we need to\n * maintain 1 or more Views at this location to cache server data and raise appropriate events for server changes\n * and user writes (set, transaction, update).\n *\n * It's responsible for:\n *  - Maintaining the set of 1 or more views necessary at this location (a SyncPoint with 0 views should be removed).\n *  - Proxying user / server operations to the views as appropriate (i.e. applyServerOverwrite,\n *    applyUserOverwrite, etc.)\n */\nexport class SyncPoint {\n  static set __referenceConstructor(val: ReferenceConstructor) {\n    assert(\n      !__referenceConstructor,\n      '__referenceConstructor has already been defined'\n    );\n    __referenceConstructor = val;\n  }\n\n  static get __referenceConstructor() {\n    assert(__referenceConstructor, 'Reference.ts has not been loaded');\n    return __referenceConstructor;\n  }\n\n  /**\n   * The Views being tracked at this location in the tree, stored as a map where the key is a\n   * queryId and the value is the View for that query.\n   *\n   * NOTE: This list will be quite small (usually 1, but perhaps 2 or 3; any more is an odd use case).\n   *\n   * @type {!Object.<!string, !View>}\n   * @private\n   */\n  private views_: { [k: string]: View } = {};\n\n  /**\n   * @return {boolean}\n   */\n  isEmpty(): boolean {\n    return isEmpty(this.views_);\n  }\n\n  /**\n   *\n   * @param {!Operation} operation\n   * @param {!WriteTreeRef} writesCache\n   * @param {?Node} optCompleteServerCache\n   * @return {!Array.<!Event>}\n   */\n  applyOperation(\n    operation: Operation,\n    writesCache: WriteTreeRef,\n    optCompleteServerCache: Node | null\n  ): Event[] {\n    const queryId = operation.source.queryId;\n    if (queryId !== null) {\n      const view = safeGet(this.views_, queryId);\n      assert(view != null, 'SyncTree gave us an op for an invalid query.');\n      return view.applyOperation(\n        operation,\n        writesCache,\n        optCompleteServerCache\n      );\n    } else {\n      let events: Event[] = [];\n\n      forEach(this.views_, function(key: string, view: View) {\n        events = events.concat(\n          view.applyOperation(operation, writesCache, optCompleteServerCache)\n        );\n      });\n\n      return events;\n    }\n  }\n\n  /**\n   * Add an event callback for the specified query.\n   *\n   * @param {!Query} query\n   * @param {!EventRegistration} eventRegistration\n   * @param {!WriteTreeRef} writesCache\n   * @param {?Node} serverCache Complete server cache, if we have it.\n   * @param {boolean} serverCacheComplete\n   * @return {!Array.<!Event>} Events to raise.\n   */\n  addEventRegistration(\n    query: Query,\n    eventRegistration: EventRegistration,\n    writesCache: WriteTreeRef,\n    serverCache: Node | null,\n    serverCacheComplete: boolean\n  ): Event[] {\n    const queryId = query.queryIdentifier();\n    let view = safeGet(this.views_, queryId);\n    if (!view) {\n      // TODO: make writesCache take flag for complete server node\n      let eventCache = writesCache.calcCompleteEventCache(\n        serverCacheComplete ? serverCache : null\n      );\n      let eventCacheComplete = false;\n      if (eventCache) {\n        eventCacheComplete = true;\n      } else if (serverCache instanceof ChildrenNode) {\n        eventCache = writesCache.calcCompleteEventChildren(serverCache);\n        eventCacheComplete = false;\n      } else {\n        eventCache = ChildrenNode.EMPTY_NODE;\n        eventCacheComplete = false;\n      }\n      const viewCache = new ViewCache(\n        new CacheNode(\n          /** @type {!Node} */ (eventCache),\n          eventCacheComplete,\n          false\n        ),\n        new CacheNode(\n          /** @type {!Node} */ (serverCache),\n          serverCacheComplete,\n          false\n        )\n      );\n      view = new View(query, viewCache);\n      this.views_[queryId] = view;\n    }\n\n    // This is guaranteed to exist now, we just created anything that was missing\n    view.addEventRegistration(eventRegistration);\n    return view.getInitialEvents(eventRegistration);\n  }\n\n  /**\n   * Remove event callback(s).  Return cancelEvents if a cancelError is specified.\n   *\n   * If query is the default query, we'll check all views for the specified eventRegistration.\n   * If eventRegistration is null, we'll remove all callbacks for the specified view(s).\n   *\n   * @param {!Query} query\n   * @param {?EventRegistration} eventRegistration If null, remove all callbacks.\n   * @param {Error=} cancelError If a cancelError is provided, appropriate cancel events will be returned.\n   * @return {{removed:!Array.<!Query>, events:!Array.<!Event>}} removed queries and any cancel events\n   */\n  removeEventRegistration(\n    query: Query,\n    eventRegistration: EventRegistration | null,\n    cancelError?: Error\n  ): { removed: Query[]; events: Event[] } {\n    const queryId = query.queryIdentifier();\n    const removed: Query[] = [];\n    let cancelEvents: Event[] = [];\n    const hadCompleteView = this.hasCompleteView();\n    if (queryId === 'default') {\n      // When you do ref.off(...), we search all views for the registration to remove.\n      const self = this;\n      forEach(this.views_, function(viewQueryId: string, view: View) {\n        cancelEvents = cancelEvents.concat(\n          view.removeEventRegistration(eventRegistration, cancelError)\n        );\n        if (view.isEmpty()) {\n          delete self.views_[viewQueryId];\n\n          // We'll deal with complete views later.\n          if (\n            !view\n              .getQuery()\n              .getQueryParams()\n              .loadsAllData()\n          ) {\n            removed.push(view.getQuery());\n          }\n        }\n      });\n    } else {\n      // remove the callback from the specific view.\n      const view = safeGet(this.views_, queryId);\n      if (view) {\n        cancelEvents = cancelEvents.concat(\n          view.removeEventRegistration(eventRegistration, cancelError)\n        );\n        if (view.isEmpty()) {\n          delete this.views_[queryId];\n\n          // We'll deal with complete views later.\n          if (\n            !view\n              .getQuery()\n              .getQueryParams()\n              .loadsAllData()\n          ) {\n            removed.push(view.getQuery());\n          }\n        }\n      }\n    }\n\n    if (hadCompleteView && !this.hasCompleteView()) {\n      // We removed our last complete view.\n      removed.push(\n        new SyncPoint.__referenceConstructor(query.repo, query.path)\n      );\n    }\n\n    return { removed: removed, events: cancelEvents };\n  }\n\n  /**\n   * @return {!Array.<!View>}\n   */\n  getQueryViews(): View[] {\n    const values = Object.keys(this.views_).map(key => this.views_[key]);\n    return values.filter(function(view) {\n      return !view\n        .getQuery()\n        .getQueryParams()\n        .loadsAllData();\n    });\n  }\n\n  /**\n   *\n   * @param {!Path} path The path to the desired complete snapshot\n   * @return {?Node} A complete cache, if it exists\n   */\n  getCompleteServerCache(path: Path): Node | null {\n    let serverCache: Node | null = null;\n    forEach(this.views_, (key: string, view: View) => {\n      serverCache = serverCache || view.getCompleteServerCache(path);\n    });\n    return serverCache;\n  }\n\n  /**\n   * @param {!Query} query\n   * @return {?View}\n   */\n  viewForQuery(query: Query): View | null {\n    const params = query.getQueryParams();\n    if (params.loadsAllData()) {\n      return this.getCompleteView();\n    } else {\n      const queryId = query.queryIdentifier();\n      return safeGet(this.views_, queryId);\n    }\n  }\n\n  /**\n   * @param {!Query} query\n   * @return {boolean}\n   */\n  viewExistsForQuery(query: Query): boolean {\n    return this.viewForQuery(query) != null;\n  }\n\n  /**\n   * @return {boolean}\n   */\n  hasCompleteView(): boolean {\n    return this.getCompleteView() != null;\n  }\n\n  /**\n   * @return {?View}\n   */\n  getCompleteView(): View | null {\n    const completeView = findValue(this.views_, (view: View) =>\n      view\n        .getQuery()\n        .getQueryParams()\n        .loadsAllData()\n    );\n    return completeView || null;\n  }\n}\n"]},"metadata":{},"sourceType":"script"}