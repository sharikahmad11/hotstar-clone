{"ast":null,"code":"\"use strict\";\n/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar SortedMap_1 = require(\"../util/SortedMap\");\n\nvar SortedMap_2 = require(\"../util/SortedMap\");\n\nvar LOG_2 = Math.log(2);\n/**\n * @constructor\n */\n\nvar Base12Num =\n/** @class */\nfunction () {\n  /**\n   * @param {number} length\n   */\n  function Base12Num(length) {\n    var logBase2 = function (num) {\n      return parseInt(Math.log(num) / LOG_2, 10);\n    };\n\n    var bitMask = function (bits) {\n      return parseInt(Array(bits + 1).join('1'), 2);\n    };\n\n    this.count = logBase2(length + 1);\n    this.current_ = this.count - 1;\n    var mask = bitMask(this.count);\n    this.bits_ = length + 1 & mask;\n  }\n  /**\n   * @return {boolean}\n   */\n\n\n  Base12Num.prototype.nextBitIsOne = function () {\n    //noinspection JSBitwiseOperatorUsage\n    var result = !(this.bits_ & 0x1 << this.current_);\n    this.current_--;\n    return result;\n  };\n\n  return Base12Num;\n}();\n/**\n * Takes a list of child nodes and constructs a SortedSet using the given comparison\n * function\n *\n * Uses the algorithm described in the paper linked here:\n * http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.46.1458\n *\n * @template K, V\n * @param {Array.<!NamedNode>} childList Unsorted list of children\n * @param {function(!NamedNode, !NamedNode):number} cmp The comparison method to be used\n * @param {(function(NamedNode):K)=} keyFn An optional function to extract K from a node wrapper, if K's\n *                                                        type is not NamedNode\n * @param {(function(K, K):number)=} mapSortFn An optional override for comparator used by the generated sorted map\n * @return {SortedMap.<K, V>}\n */\n\n\nexports.buildChildSet = function (childList, cmp, keyFn, mapSortFn) {\n  childList.sort(cmp);\n\n  var buildBalancedTree = function (low, high) {\n    var length = high - low;\n    var namedNode;\n    var key;\n\n    if (length == 0) {\n      return null;\n    } else if (length == 1) {\n      namedNode = childList[low];\n      key = keyFn ? keyFn(namedNode) : namedNode;\n      return new SortedMap_1.LLRBNode(key, namedNode.node, SortedMap_1.LLRBNode.BLACK, null, null);\n    } else {\n      var middle = parseInt(length / 2, 10) + low;\n      var left = buildBalancedTree(low, middle);\n      var right = buildBalancedTree(middle + 1, high);\n      namedNode = childList[middle];\n      key = keyFn ? keyFn(namedNode) : namedNode;\n      return new SortedMap_1.LLRBNode(key, namedNode.node, SortedMap_1.LLRBNode.BLACK, left, right);\n    }\n  };\n\n  var buildFrom12Array = function (base12) {\n    var node = null;\n    var root = null;\n    var index = childList.length;\n\n    var buildPennant = function (chunkSize, color) {\n      var low = index - chunkSize;\n      var high = index;\n      index -= chunkSize;\n      var childTree = buildBalancedTree(low + 1, high);\n      var namedNode = childList[low];\n      var key = keyFn ? keyFn(namedNode) : namedNode;\n      attachPennant(new SortedMap_1.LLRBNode(key, namedNode.node, color, null, childTree));\n    };\n\n    var attachPennant = function (pennant) {\n      if (node) {\n        node.left = pennant;\n        node = pennant;\n      } else {\n        root = pennant;\n        node = pennant;\n      }\n    };\n\n    for (var i = 0; i < base12.count; ++i) {\n      var isOne = base12.nextBitIsOne(); // The number of nodes taken in each slice is 2^(arr.length - (i + 1))\n\n      var chunkSize = Math.pow(2, base12.count - (i + 1));\n\n      if (isOne) {\n        buildPennant(chunkSize, SortedMap_1.LLRBNode.BLACK);\n      } else {\n        // current == 2\n        buildPennant(chunkSize, SortedMap_1.LLRBNode.BLACK);\n        buildPennant(chunkSize, SortedMap_1.LLRBNode.RED);\n      }\n    }\n\n    return root;\n  };\n\n  var base12 = new Base12Num(childList.length);\n  var root = buildFrom12Array(base12);\n  return new SortedMap_2.SortedMap(mapSortFn || cmp, root);\n};","map":{"version":3,"sources":["../src/core/snap/childSet.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { LLRBNode } from '../util/SortedMap';\nimport { SortedMap } from '../util/SortedMap';\nimport { NamedNode } from './Node';\n\nconst LOG_2 = Math.log(2);\n\n/**\n * @constructor\n */\nclass Base12Num {\n  count: number;\n  private current_: number;\n  private bits_: number;\n\n  /**\n   * @param {number} length\n   */\n  constructor(length: number) {\n    const logBase2 = (num: number) =>\n      parseInt((Math.log(num) / LOG_2) as any, 10);\n    const bitMask = (bits: number) => parseInt(Array(bits + 1).join('1'), 2);\n    this.count = logBase2(length + 1);\n    this.current_ = this.count - 1;\n    const mask = bitMask(this.count);\n    this.bits_ = (length + 1) & mask;\n  }\n\n  /**\n   * @return {boolean}\n   */\n  nextBitIsOne(): boolean {\n    //noinspection JSBitwiseOperatorUsage\n    const result = !(this.bits_ & (0x1 << this.current_));\n    this.current_--;\n    return result;\n  }\n}\n\n/**\n * Takes a list of child nodes and constructs a SortedSet using the given comparison\n * function\n *\n * Uses the algorithm described in the paper linked here:\n * http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.46.1458\n *\n * @template K, V\n * @param {Array.<!NamedNode>} childList Unsorted list of children\n * @param {function(!NamedNode, !NamedNode):number} cmp The comparison method to be used\n * @param {(function(NamedNode):K)=} keyFn An optional function to extract K from a node wrapper, if K's\n *                                                        type is not NamedNode\n * @param {(function(K, K):number)=} mapSortFn An optional override for comparator used by the generated sorted map\n * @return {SortedMap.<K, V>}\n */\nexport const buildChildSet = function<K, V>(\n  childList: NamedNode[],\n  cmp: (a: NamedNode, b: NamedNode) => number,\n  keyFn?: (a: NamedNode) => K,\n  mapSortFn?: (a: K, b: K) => number\n): SortedMap<K, V> {\n  childList.sort(cmp);\n\n  const buildBalancedTree = function(\n    low: number,\n    high: number\n  ): LLRBNode<K, V> | null {\n    const length = high - low;\n    let namedNode: NamedNode;\n    let key: K;\n    if (length == 0) {\n      return null;\n    } else if (length == 1) {\n      namedNode = childList[low];\n      key = keyFn ? keyFn(namedNode) : ((namedNode as any) as K);\n      return new LLRBNode(\n        key,\n        (namedNode.node as any) as V,\n        LLRBNode.BLACK,\n        null,\n        null\n      );\n    } else {\n      const middle = parseInt((length / 2) as any, 10) + low;\n      const left = buildBalancedTree(low, middle);\n      const right = buildBalancedTree(middle + 1, high);\n      namedNode = childList[middle];\n      key = keyFn ? keyFn(namedNode) : ((namedNode as any) as K);\n      return new LLRBNode(\n        key,\n        (namedNode.node as any) as V,\n        LLRBNode.BLACK,\n        left,\n        right\n      );\n    }\n  };\n\n  const buildFrom12Array = function(base12: Base12Num): LLRBNode<K, V> {\n    let node: LLRBNode<K, V> = null;\n    let root = null;\n    let index = childList.length;\n\n    const buildPennant = function(chunkSize: number, color: boolean) {\n      const low = index - chunkSize;\n      const high = index;\n      index -= chunkSize;\n      const childTree = buildBalancedTree(low + 1, high);\n      const namedNode = childList[low];\n      const key: K = keyFn ? keyFn(namedNode) : ((namedNode as any) as K);\n      attachPennant(\n        new LLRBNode(key, (namedNode.node as any) as V, color, null, childTree)\n      );\n    };\n\n    const attachPennant = function(pennant: LLRBNode<K, V>) {\n      if (node) {\n        node.left = pennant;\n        node = pennant;\n      } else {\n        root = pennant;\n        node = pennant;\n      }\n    };\n\n    for (let i = 0; i < base12.count; ++i) {\n      const isOne = base12.nextBitIsOne();\n      // The number of nodes taken in each slice is 2^(arr.length - (i + 1))\n      const chunkSize = Math.pow(2, base12.count - (i + 1));\n      if (isOne) {\n        buildPennant(chunkSize, LLRBNode.BLACK);\n      } else {\n        // current == 2\n        buildPennant(chunkSize, LLRBNode.BLACK);\n        buildPennant(chunkSize, LLRBNode.RED);\n      }\n    }\n    return root;\n  };\n\n  const base12 = new Base12Num(childList.length);\n  const root = buildFrom12Array(base12);\n\n  return new SortedMap<K, V>(mapSortFn || (cmp as any), root);\n};\n"]},"metadata":{},"sourceType":"script"}