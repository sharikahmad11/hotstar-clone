{"ast":null,"code":"\"use strict\";\n/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar util_1 = require(\"@firebase/util\");\n\nvar KeyIndex_1 = require(\"../core/snap/indexes/KeyIndex\");\n\nvar PriorityIndex_1 = require(\"../core/snap/indexes/PriorityIndex\");\n\nvar ValueIndex_1 = require(\"../core/snap/indexes/ValueIndex\");\n\nvar PathIndex_1 = require(\"../core/snap/indexes/PathIndex\");\n\nvar util_2 = require(\"../core/util/util\");\n\nvar Path_1 = require(\"../core/util/Path\");\n\nvar validation_1 = require(\"../core/util/validation\");\n\nvar util_3 = require(\"@firebase/util\");\n\nvar EventRegistration_1 = require(\"../core/view/EventRegistration\");\n\nvar util_4 = require(\"@firebase/util\");\n\nvar __referenceConstructor;\n/**\n * A Query represents a filter to be applied to a firebase location.  This object purely represents the\n * query expression (and exposes our public API to build the query).  The actual query logic is in ViewBase.js.\n *\n * Since every Firebase reference is a query, Firebase inherits from this object.\n */\n\n\nvar Query =\n/** @class */\nfunction () {\n  function Query(repo, path, queryParams_, orderByCalled_) {\n    this.repo = repo;\n    this.path = path;\n    this.queryParams_ = queryParams_;\n    this.orderByCalled_ = orderByCalled_;\n  }\n\n  Object.defineProperty(Query, \"__referenceConstructor\", {\n    get: function () {\n      util_1.assert(__referenceConstructor, 'Reference.ts has not been loaded');\n      return __referenceConstructor;\n    },\n    set: function (val) {\n      __referenceConstructor = val;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\n   * Validates start/end values for queries.\n   * @param {!QueryParams} params\n   * @private\n   */\n\n  Query.validateQueryEndpoints_ = function (params) {\n    var startNode = null;\n    var endNode = null;\n\n    if (params.hasStart()) {\n      startNode = params.getIndexStartValue();\n    }\n\n    if (params.hasEnd()) {\n      endNode = params.getIndexEndValue();\n    }\n\n    if (params.getIndex() === KeyIndex_1.KEY_INDEX) {\n      var tooManyArgsError = 'Query: When ordering by key, you may only pass one argument to ' + 'startAt(), endAt(), or equalTo().';\n      var wrongArgTypeError = 'Query: When ordering by key, the argument passed to startAt(), endAt(),' + 'or equalTo() must be a string.';\n\n      if (params.hasStart()) {\n        var startName = params.getIndexStartName();\n\n        if (startName != util_2.MIN_NAME) {\n          throw new Error(tooManyArgsError);\n        } else if (typeof startNode !== 'string') {\n          throw new Error(wrongArgTypeError);\n        }\n      }\n\n      if (params.hasEnd()) {\n        var endName = params.getIndexEndName();\n\n        if (endName != util_2.MAX_NAME) {\n          throw new Error(tooManyArgsError);\n        } else if (typeof endNode !== 'string') {\n          throw new Error(wrongArgTypeError);\n        }\n      }\n    } else if (params.getIndex() === PriorityIndex_1.PRIORITY_INDEX) {\n      if (startNode != null && !validation_1.isValidPriority(startNode) || endNode != null && !validation_1.isValidPriority(endNode)) {\n        throw new Error('Query: When ordering by priority, the first argument passed to startAt(), ' + 'endAt(), or equalTo() must be a valid priority value (null, a number, or a string).');\n      }\n    } else {\n      util_1.assert(params.getIndex() instanceof PathIndex_1.PathIndex || params.getIndex() === ValueIndex_1.VALUE_INDEX, 'unknown index type.');\n\n      if (startNode != null && typeof startNode === 'object' || endNode != null && typeof endNode === 'object') {\n        throw new Error('Query: First argument passed to startAt(), endAt(), or equalTo() cannot be ' + 'an object.');\n      }\n    }\n  };\n  /**\n   * Validates that limit* has been called with the correct combination of parameters\n   * @param {!QueryParams} params\n   * @private\n   */\n\n\n  Query.validateLimit_ = function (params) {\n    if (params.hasStart() && params.hasEnd() && params.hasLimit() && !params.hasAnchoredLimit()) {\n      throw new Error(\"Query: Can't combine startAt(), endAt(), and limit(). Use limitToFirst() or limitToLast() instead.\");\n    }\n  };\n  /**\n   * Validates that no other order by call has been made\n   * @param {!string} fnName\n   * @private\n   */\n\n\n  Query.prototype.validateNoPreviousOrderByCall_ = function (fnName) {\n    if (this.orderByCalled_ === true) {\n      throw new Error(fnName + \": You can't combine multiple orderBy calls.\");\n    }\n  };\n  /**\n   * @return {!QueryParams}\n   */\n\n\n  Query.prototype.getQueryParams = function () {\n    return this.queryParams_;\n  };\n  /**\n   * @return {!Reference}\n   */\n\n\n  Query.prototype.getRef = function () {\n    util_3.validateArgCount('Query.ref', 0, 0, arguments.length); // This is a slight hack. We cannot goog.require('fb.api.Firebase'), since Firebase requires fb.api.Query.\n    // However, we will always export 'Firebase' to the global namespace, so it's guaranteed to exist by the time this\n    // method gets called.\n\n    return new Query.__referenceConstructor(this.repo, this.path);\n  };\n  /**\n   * @param {!string} eventType\n   * @param {!function(DataSnapshot, string=)} callback\n   * @param {(function(Error)|Object)=} cancelCallbackOrContext\n   * @param {Object=} context\n   * @return {!function(DataSnapshot, string=)}\n   */\n\n\n  Query.prototype.on = function (eventType, callback, cancelCallbackOrContext, context) {\n    util_3.validateArgCount('Query.on', 2, 4, arguments.length);\n    validation_1.validateEventType('Query.on', 1, eventType, false);\n    util_3.validateCallback('Query.on', 2, callback, false);\n    var ret = Query.getCancelAndContextArgs_('Query.on', cancelCallbackOrContext, context);\n\n    if (eventType === 'value') {\n      this.onValueEvent(callback, ret.cancel, ret.context);\n    } else {\n      var callbacks = {};\n      callbacks[eventType] = callback;\n      this.onChildEvent(callbacks, ret.cancel, ret.context);\n    }\n\n    return callback;\n  };\n  /**\n   * @param {!function(!DataSnapshot)} callback\n   * @param {?function(Error)} cancelCallback\n   * @param {?Object} context\n   * @protected\n   */\n\n\n  Query.prototype.onValueEvent = function (callback, cancelCallback, context) {\n    var container = new EventRegistration_1.ValueEventRegistration(callback, cancelCallback || null, context || null);\n    this.repo.addEventCallbackForQuery(this, container);\n  };\n  /**\n   * @param {!Object.<string, !function(!DataSnapshot, ?string)>} callbacks\n   * @param {?function(Error)} cancelCallback\n   * @param {?Object} context\n   * @protected\n   */\n\n\n  Query.prototype.onChildEvent = function (callbacks, cancelCallback, context) {\n    var container = new EventRegistration_1.ChildEventRegistration(callbacks, cancelCallback, context);\n    this.repo.addEventCallbackForQuery(this, container);\n  };\n  /**\n   * @param {string=} eventType\n   * @param {(function(!DataSnapshot, ?string=))=} callback\n   * @param {Object=} context\n   */\n\n\n  Query.prototype.off = function (eventType, callback, context) {\n    util_3.validateArgCount('Query.off', 0, 3, arguments.length);\n    validation_1.validateEventType('Query.off', 1, eventType, true);\n    util_3.validateCallback('Query.off', 2, callback, true);\n    util_3.validateContextObject('Query.off', 3, context, true);\n    var container = null;\n    var callbacks = null;\n\n    if (eventType === 'value') {\n      var valueCallback = callback || null;\n      container = new EventRegistration_1.ValueEventRegistration(valueCallback, null, context || null);\n    } else if (eventType) {\n      if (callback) {\n        callbacks = {};\n        callbacks[eventType] = callback;\n      }\n\n      container = new EventRegistration_1.ChildEventRegistration(callbacks, null, context || null);\n    }\n\n    this.repo.removeEventCallbackForQuery(this, container);\n  };\n  /**\n   * Attaches a listener, waits for the first event, and then removes the listener\n   * @param {!string} eventType\n   * @param {!function(!DataSnapshot, string=)} userCallback\n   * @param cancelOrContext\n   * @param context\n   * @return {!firebase.Promise}\n   */\n\n\n  Query.prototype.once = function (eventType, userCallback, cancelOrContext, context) {\n    var _this = this;\n\n    util_3.validateArgCount('Query.once', 1, 4, arguments.length);\n    validation_1.validateEventType('Query.once', 1, eventType, false);\n    util_3.validateCallback('Query.once', 2, userCallback, true);\n    var ret = Query.getCancelAndContextArgs_('Query.once', cancelOrContext, context); // TODO: Implement this more efficiently (in particular, use 'get' wire protocol for 'value' event)\n    // TODO: consider actually wiring the callbacks into the promise. We cannot do this without a breaking change\n    // because the API currently expects callbacks will be called synchronously if the data is cached, but this is\n    // against the Promise specification.\n\n    var firstCall = true;\n    var deferred = new util_4.Deferred(); // A dummy error handler in case a user wasn't expecting promises\n\n    deferred.promise.catch(function () {});\n\n    var onceCallback = function (snapshot) {\n      // NOTE: Even though we unsubscribe, we may get called multiple times if a single action (e.g. set() with JSON)\n      // triggers multiple events (e.g. child_added or child_changed).\n      if (firstCall) {\n        firstCall = false;\n\n        _this.off(eventType, onceCallback);\n\n        if (userCallback) {\n          userCallback.bind(ret.context)(snapshot);\n        }\n\n        deferred.resolve(snapshot);\n      }\n    };\n\n    this.on(eventType, onceCallback,\n    /*cancel=*/\n    function (err) {\n      _this.off(eventType, onceCallback);\n\n      if (ret.cancel) ret.cancel.bind(ret.context)(err);\n      deferred.reject(err);\n    });\n    return deferred.promise;\n  };\n  /**\n   * Set a limit and anchor it to the start of the window.\n   * @param {!number} limit\n   * @return {!Query}\n   */\n\n\n  Query.prototype.limitToFirst = function (limit) {\n    util_3.validateArgCount('Query.limitToFirst', 1, 1, arguments.length);\n\n    if (typeof limit !== 'number' || Math.floor(limit) !== limit || limit <= 0) {\n      throw new Error('Query.limitToFirst: First argument must be a positive integer.');\n    }\n\n    if (this.queryParams_.hasLimit()) {\n      throw new Error('Query.limitToFirst: Limit was already set (by another call to limit, ' + 'limitToFirst, or limitToLast).');\n    }\n\n    return new Query(this.repo, this.path, this.queryParams_.limitToFirst(limit), this.orderByCalled_);\n  };\n  /**\n   * Set a limit and anchor it to the end of the window.\n   * @param {!number} limit\n   * @return {!Query}\n   */\n\n\n  Query.prototype.limitToLast = function (limit) {\n    util_3.validateArgCount('Query.limitToLast', 1, 1, arguments.length);\n\n    if (typeof limit !== 'number' || Math.floor(limit) !== limit || limit <= 0) {\n      throw new Error('Query.limitToLast: First argument must be a positive integer.');\n    }\n\n    if (this.queryParams_.hasLimit()) {\n      throw new Error('Query.limitToLast: Limit was already set (by another call to limit, ' + 'limitToFirst, or limitToLast).');\n    }\n\n    return new Query(this.repo, this.path, this.queryParams_.limitToLast(limit), this.orderByCalled_);\n  };\n  /**\n   * Given a child path, return a new query ordered by the specified grandchild path.\n   * @param {!string} path\n   * @return {!Query}\n   */\n\n\n  Query.prototype.orderByChild = function (path) {\n    util_3.validateArgCount('Query.orderByChild', 1, 1, arguments.length);\n\n    if (path === '$key') {\n      throw new Error('Query.orderByChild: \"$key\" is invalid.  Use Query.orderByKey() instead.');\n    } else if (path === '$priority') {\n      throw new Error('Query.orderByChild: \"$priority\" is invalid.  Use Query.orderByPriority() instead.');\n    } else if (path === '$value') {\n      throw new Error('Query.orderByChild: \"$value\" is invalid.  Use Query.orderByValue() instead.');\n    }\n\n    validation_1.validatePathString('Query.orderByChild', 1, path, false);\n    this.validateNoPreviousOrderByCall_('Query.orderByChild');\n    var parsedPath = new Path_1.Path(path);\n\n    if (parsedPath.isEmpty()) {\n      throw new Error('Query.orderByChild: cannot pass in empty path.  Use Query.orderByValue() instead.');\n    }\n\n    var index = new PathIndex_1.PathIndex(parsedPath);\n    var newParams = this.queryParams_.orderBy(index);\n    Query.validateQueryEndpoints_(newParams);\n    return new Query(this.repo, this.path, newParams,\n    /*orderByCalled=*/\n    true);\n  };\n  /**\n   * Return a new query ordered by the KeyIndex\n   * @return {!Query}\n   */\n\n\n  Query.prototype.orderByKey = function () {\n    util_3.validateArgCount('Query.orderByKey', 0, 0, arguments.length);\n    this.validateNoPreviousOrderByCall_('Query.orderByKey');\n    var newParams = this.queryParams_.orderBy(KeyIndex_1.KEY_INDEX);\n    Query.validateQueryEndpoints_(newParams);\n    return new Query(this.repo, this.path, newParams,\n    /*orderByCalled=*/\n    true);\n  };\n  /**\n   * Return a new query ordered by the PriorityIndex\n   * @return {!Query}\n   */\n\n\n  Query.prototype.orderByPriority = function () {\n    util_3.validateArgCount('Query.orderByPriority', 0, 0, arguments.length);\n    this.validateNoPreviousOrderByCall_('Query.orderByPriority');\n    var newParams = this.queryParams_.orderBy(PriorityIndex_1.PRIORITY_INDEX);\n    Query.validateQueryEndpoints_(newParams);\n    return new Query(this.repo, this.path, newParams,\n    /*orderByCalled=*/\n    true);\n  };\n  /**\n   * Return a new query ordered by the ValueIndex\n   * @return {!Query}\n   */\n\n\n  Query.prototype.orderByValue = function () {\n    util_3.validateArgCount('Query.orderByValue', 0, 0, arguments.length);\n    this.validateNoPreviousOrderByCall_('Query.orderByValue');\n    var newParams = this.queryParams_.orderBy(ValueIndex_1.VALUE_INDEX);\n    Query.validateQueryEndpoints_(newParams);\n    return new Query(this.repo, this.path, newParams,\n    /*orderByCalled=*/\n    true);\n  };\n  /**\n   * @param {number|string|boolean|null} value\n   * @param {?string=} name\n   * @return {!Query}\n   */\n\n\n  Query.prototype.startAt = function (value, name) {\n    if (value === void 0) {\n      value = null;\n    }\n\n    util_3.validateArgCount('Query.startAt', 0, 2, arguments.length);\n    validation_1.validateFirebaseDataArg('Query.startAt', 1, value, this.path, true);\n    validation_1.validateKey('Query.startAt', 2, name, true);\n    var newParams = this.queryParams_.startAt(value, name);\n    Query.validateLimit_(newParams);\n    Query.validateQueryEndpoints_(newParams);\n\n    if (this.queryParams_.hasStart()) {\n      throw new Error('Query.startAt: Starting point was already set (by another call to startAt ' + 'or equalTo).');\n    } // Calling with no params tells us to start at the beginning.\n\n\n    if (value === undefined) {\n      value = null;\n      name = null;\n    }\n\n    return new Query(this.repo, this.path, newParams, this.orderByCalled_);\n  };\n  /**\n   * @param {number|string|boolean|null} value\n   * @param {?string=} name\n   * @return {!Query}\n   */\n\n\n  Query.prototype.endAt = function (value, name) {\n    if (value === void 0) {\n      value = null;\n    }\n\n    util_3.validateArgCount('Query.endAt', 0, 2, arguments.length);\n    validation_1.validateFirebaseDataArg('Query.endAt', 1, value, this.path, true);\n    validation_1.validateKey('Query.endAt', 2, name, true);\n    var newParams = this.queryParams_.endAt(value, name);\n    Query.validateLimit_(newParams);\n    Query.validateQueryEndpoints_(newParams);\n\n    if (this.queryParams_.hasEnd()) {\n      throw new Error('Query.endAt: Ending point was already set (by another call to endAt or ' + 'equalTo).');\n    }\n\n    return new Query(this.repo, this.path, newParams, this.orderByCalled_);\n  };\n  /**\n   * Load the selection of children with exactly the specified value, and, optionally,\n   * the specified name.\n   * @param {number|string|boolean|null} value\n   * @param {string=} name\n   * @return {!Query}\n   */\n\n\n  Query.prototype.equalTo = function (value, name) {\n    util_3.validateArgCount('Query.equalTo', 1, 2, arguments.length);\n    validation_1.validateFirebaseDataArg('Query.equalTo', 1, value, this.path, false);\n    validation_1.validateKey('Query.equalTo', 2, name, true);\n\n    if (this.queryParams_.hasStart()) {\n      throw new Error('Query.equalTo: Starting point was already set (by another call to startAt or ' + 'equalTo).');\n    }\n\n    if (this.queryParams_.hasEnd()) {\n      throw new Error('Query.equalTo: Ending point was already set (by another call to endAt or ' + 'equalTo).');\n    }\n\n    return this.startAt(value, name).endAt(value, name);\n  };\n  /**\n   * @return {!string} URL for this location.\n   */\n\n\n  Query.prototype.toString = function () {\n    util_3.validateArgCount('Query.toString', 0, 0, arguments.length);\n    return this.repo.toString() + this.path.toUrlEncodedString();\n  }; // Do not create public documentation. This is intended to make JSON serialization work but is otherwise unnecessary\n  // for end-users.\n\n\n  Query.prototype.toJSON = function () {\n    // An optional spacer argument is unnecessary for a string.\n    util_3.validateArgCount('Query.toJSON', 0, 1, arguments.length);\n    return this.toString();\n  };\n  /**\n   * An object representation of the query parameters used by this Query.\n   * @return {!Object}\n   */\n\n\n  Query.prototype.queryObject = function () {\n    return this.queryParams_.getQueryObject();\n  };\n  /**\n   * @return {!string}\n   */\n\n\n  Query.prototype.queryIdentifier = function () {\n    var obj = this.queryObject();\n    var id = util_2.ObjectToUniqueKey(obj);\n    return id === '{}' ? 'default' : id;\n  };\n  /**\n   * Return true if this query and the provided query are equivalent; otherwise, return false.\n   * @param {Query} other\n   * @return {boolean}\n   */\n\n\n  Query.prototype.isEqual = function (other) {\n    util_3.validateArgCount('Query.isEqual', 1, 1, arguments.length);\n\n    if (!(other instanceof Query)) {\n      var error = 'Query.isEqual failed: First argument must be an instance of firebase.database.Query.';\n      throw new Error(error);\n    }\n\n    var sameRepo = this.repo === other.repo;\n    var samePath = this.path.equals(other.path);\n    var sameQueryIdentifier = this.queryIdentifier() === other.queryIdentifier();\n    return sameRepo && samePath && sameQueryIdentifier;\n  };\n  /**\n   * Helper used by .on and .once to extract the context and or cancel arguments.\n   * @param {!string} fnName The function name (on or once)\n   * @param {(function(Error)|Object)=} cancelOrContext\n   * @param {Object=} context\n   * @return {{cancel: ?function(Error), context: ?Object}}\n   * @private\n   */\n\n\n  Query.getCancelAndContextArgs_ = function (fnName, cancelOrContext, context) {\n    var ret = {\n      cancel: null,\n      context: null\n    };\n\n    if (cancelOrContext && context) {\n      ret.cancel = cancelOrContext;\n      util_3.validateCallback(fnName, 3, ret.cancel, true);\n      ret.context = context;\n      util_3.validateContextObject(fnName, 4, ret.context, true);\n    } else if (cancelOrContext) {\n      // we have either a cancel callback or a context.\n      if (typeof cancelOrContext === 'object' && cancelOrContext !== null) {\n        // it's a context!\n        ret.context = cancelOrContext;\n      } else if (typeof cancelOrContext === 'function') {\n        ret.cancel = cancelOrContext;\n      } else {\n        throw new Error(util_3.errorPrefix(fnName, 3, true) + ' must either be a cancel callback or a context object.');\n      }\n    }\n\n    return ret;\n  };\n\n  Object.defineProperty(Query.prototype, \"ref\", {\n    get: function () {\n      return this.getRef();\n    },\n    enumerable: true,\n    configurable: true\n  });\n  return Query;\n}();\n\nexports.Query = Query;","map":{"version":3,"sources":["../src/api/Query.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { assert } from '@firebase/util';\nimport { KEY_INDEX } from '../core/snap/indexes/KeyIndex';\nimport { PRIORITY_INDEX } from '../core/snap/indexes/PriorityIndex';\nimport { VALUE_INDEX } from '../core/snap/indexes/ValueIndex';\nimport { PathIndex } from '../core/snap/indexes/PathIndex';\nimport { MIN_NAME, MAX_NAME, ObjectToUniqueKey } from '../core/util/util';\nimport { Path } from '../core/util/Path';\nimport {\n  isValidPriority,\n  validateEventType,\n  validatePathString,\n  validateFirebaseDataArg,\n  validateKey\n} from '../core/util/validation';\nimport {\n  errorPrefix,\n  validateArgCount,\n  validateCallback,\n  validateContextObject\n} from '@firebase/util';\nimport {\n  ValueEventRegistration,\n  ChildEventRegistration,\n  EventRegistration\n} from '../core/view/EventRegistration';\nimport { Deferred } from '@firebase/util';\nimport { Repo } from '../core/Repo';\nimport { QueryParams } from '../core/view/QueryParams';\nimport { Reference } from './Reference';\nimport { DataSnapshot } from './DataSnapshot';\n\nlet __referenceConstructor: new (repo: Repo, path: Path) => Query;\n\nexport interface SnapshotCallback {\n  (a: DataSnapshot, b?: string): any;\n}\n\n/**\n * A Query represents a filter to be applied to a firebase location.  This object purely represents the\n * query expression (and exposes our public API to build the query).  The actual query logic is in ViewBase.js.\n *\n * Since every Firebase reference is a query, Firebase inherits from this object.\n */\nexport class Query {\n  static set __referenceConstructor(val) {\n    __referenceConstructor = val;\n  }\n\n  static get __referenceConstructor() {\n    assert(__referenceConstructor, 'Reference.ts has not been loaded');\n    return __referenceConstructor;\n  }\n\n  constructor(\n    public repo: Repo,\n    public path: Path,\n    private queryParams_: QueryParams,\n    private orderByCalled_: boolean\n  ) {}\n\n  /**\n   * Validates start/end values for queries.\n   * @param {!QueryParams} params\n   * @private\n   */\n  private static validateQueryEndpoints_(params: QueryParams) {\n    let startNode = null;\n    let endNode = null;\n    if (params.hasStart()) {\n      startNode = params.getIndexStartValue();\n    }\n    if (params.hasEnd()) {\n      endNode = params.getIndexEndValue();\n    }\n\n    if (params.getIndex() === KEY_INDEX) {\n      const tooManyArgsError =\n        'Query: When ordering by key, you may only pass one argument to ' +\n        'startAt(), endAt(), or equalTo().';\n      const wrongArgTypeError =\n        'Query: When ordering by key, the argument passed to startAt(), endAt(),' +\n        'or equalTo() must be a string.';\n      if (params.hasStart()) {\n        const startName = params.getIndexStartName();\n        if (startName != MIN_NAME) {\n          throw new Error(tooManyArgsError);\n        } else if (typeof startNode !== 'string') {\n          throw new Error(wrongArgTypeError);\n        }\n      }\n      if (params.hasEnd()) {\n        const endName = params.getIndexEndName();\n        if (endName != MAX_NAME) {\n          throw new Error(tooManyArgsError);\n        } else if (typeof endNode !== 'string') {\n          throw new Error(wrongArgTypeError);\n        }\n      }\n    } else if (params.getIndex() === PRIORITY_INDEX) {\n      if (\n        (startNode != null && !isValidPriority(startNode)) ||\n        (endNode != null && !isValidPriority(endNode))\n      ) {\n        throw new Error(\n          'Query: When ordering by priority, the first argument passed to startAt(), ' +\n            'endAt(), or equalTo() must be a valid priority value (null, a number, or a string).'\n        );\n      }\n    } else {\n      assert(\n        params.getIndex() instanceof PathIndex ||\n          params.getIndex() === VALUE_INDEX,\n        'unknown index type.'\n      );\n      if (\n        (startNode != null && typeof startNode === 'object') ||\n        (endNode != null && typeof endNode === 'object')\n      ) {\n        throw new Error(\n          'Query: First argument passed to startAt(), endAt(), or equalTo() cannot be ' +\n            'an object.'\n        );\n      }\n    }\n  }\n\n  /**\n   * Validates that limit* has been called with the correct combination of parameters\n   * @param {!QueryParams} params\n   * @private\n   */\n  private static validateLimit_(params: QueryParams) {\n    if (\n      params.hasStart() &&\n      params.hasEnd() &&\n      params.hasLimit() &&\n      !params.hasAnchoredLimit()\n    ) {\n      throw new Error(\n        \"Query: Can't combine startAt(), endAt(), and limit(). Use limitToFirst() or limitToLast() instead.\"\n      );\n    }\n  }\n\n  /**\n   * Validates that no other order by call has been made\n   * @param {!string} fnName\n   * @private\n   */\n  private validateNoPreviousOrderByCall_(fnName: string) {\n    if (this.orderByCalled_ === true) {\n      throw new Error(fnName + \": You can't combine multiple orderBy calls.\");\n    }\n  }\n\n  /**\n   * @return {!QueryParams}\n   */\n  getQueryParams(): QueryParams {\n    return this.queryParams_;\n  }\n\n  /**\n   * @return {!Reference}\n   */\n  getRef(): Reference {\n    validateArgCount('Query.ref', 0, 0, arguments.length);\n    // This is a slight hack. We cannot goog.require('fb.api.Firebase'), since Firebase requires fb.api.Query.\n    // However, we will always export 'Firebase' to the global namespace, so it's guaranteed to exist by the time this\n    // method gets called.\n    return new Query.__referenceConstructor(this.repo, this.path) as Reference;\n  }\n\n  /**\n   * @param {!string} eventType\n   * @param {!function(DataSnapshot, string=)} callback\n   * @param {(function(Error)|Object)=} cancelCallbackOrContext\n   * @param {Object=} context\n   * @return {!function(DataSnapshot, string=)}\n   */\n  on(\n    eventType: string,\n    callback: SnapshotCallback,\n    cancelCallbackOrContext?: ((a: Error) => any) | Object,\n    context?: Object\n  ): SnapshotCallback {\n    validateArgCount('Query.on', 2, 4, arguments.length);\n    validateEventType('Query.on', 1, eventType, false);\n    validateCallback('Query.on', 2, callback, false);\n\n    const ret = Query.getCancelAndContextArgs_(\n      'Query.on',\n      cancelCallbackOrContext,\n      context\n    );\n\n    if (eventType === 'value') {\n      this.onValueEvent(callback, ret.cancel, ret.context);\n    } else {\n      const callbacks: { [k: string]: typeof callback } = {};\n      callbacks[eventType] = callback;\n      this.onChildEvent(callbacks, ret.cancel, ret.context);\n    }\n    return callback;\n  }\n\n  /**\n   * @param {!function(!DataSnapshot)} callback\n   * @param {?function(Error)} cancelCallback\n   * @param {?Object} context\n   * @protected\n   */\n  protected onValueEvent(\n    callback: (a: DataSnapshot) => void,\n    cancelCallback: ((a: Error) => void) | null,\n    context: Object | null\n  ) {\n    const container = new ValueEventRegistration(\n      callback,\n      cancelCallback || null,\n      context || null\n    );\n    this.repo.addEventCallbackForQuery(this, container);\n  }\n\n  /**\n   * @param {!Object.<string, !function(!DataSnapshot, ?string)>} callbacks\n   * @param {?function(Error)} cancelCallback\n   * @param {?Object} context\n   * @protected\n   */\n  onChildEvent(\n    callbacks: { [k: string]: SnapshotCallback },\n    cancelCallback: ((a: Error) => any) | null,\n    context: Object | null\n  ) {\n    const container = new ChildEventRegistration(\n      callbacks,\n      cancelCallback,\n      context\n    );\n    this.repo.addEventCallbackForQuery(this, container);\n  }\n\n  /**\n   * @param {string=} eventType\n   * @param {(function(!DataSnapshot, ?string=))=} callback\n   * @param {Object=} context\n   */\n  off(eventType?: string, callback?: SnapshotCallback, context?: Object) {\n    validateArgCount('Query.off', 0, 3, arguments.length);\n    validateEventType('Query.off', 1, eventType, true);\n    validateCallback('Query.off', 2, callback, true);\n    validateContextObject('Query.off', 3, context, true);\n\n    let container: EventRegistration | null = null;\n    let callbacks: { [k: string]: typeof callback } | null = null;\n    if (eventType === 'value') {\n      const valueCallback = callback || null;\n      container = new ValueEventRegistration(\n        valueCallback,\n        null,\n        context || null\n      );\n    } else if (eventType) {\n      if (callback) {\n        callbacks = {};\n        callbacks[eventType] = callback;\n      }\n      container = new ChildEventRegistration(callbacks, null, context || null);\n    }\n    this.repo.removeEventCallbackForQuery(this, container);\n  }\n\n  /**\n   * Attaches a listener, waits for the first event, and then removes the listener\n   * @param {!string} eventType\n   * @param {!function(!DataSnapshot, string=)} userCallback\n   * @param cancelOrContext\n   * @param context\n   * @return {!firebase.Promise}\n   */\n  once(\n    eventType: string,\n    userCallback?: SnapshotCallback,\n    cancelOrContext?: ((a: Error) => void) | Object,\n    context?: Object\n  ): Promise<DataSnapshot> {\n    validateArgCount('Query.once', 1, 4, arguments.length);\n    validateEventType('Query.once', 1, eventType, false);\n    validateCallback('Query.once', 2, userCallback, true);\n\n    const ret = Query.getCancelAndContextArgs_(\n      'Query.once',\n      cancelOrContext,\n      context\n    );\n\n    // TODO: Implement this more efficiently (in particular, use 'get' wire protocol for 'value' event)\n    // TODO: consider actually wiring the callbacks into the promise. We cannot do this without a breaking change\n    // because the API currently expects callbacks will be called synchronously if the data is cached, but this is\n    // against the Promise specification.\n    let firstCall = true;\n    const deferred = new Deferred<DataSnapshot>();\n\n    // A dummy error handler in case a user wasn't expecting promises\n    deferred.promise.catch(() => {});\n\n    const onceCallback = (snapshot: DataSnapshot) => {\n      // NOTE: Even though we unsubscribe, we may get called multiple times if a single action (e.g. set() with JSON)\n      // triggers multiple events (e.g. child_added or child_changed).\n      if (firstCall) {\n        firstCall = false;\n        this.off(eventType, onceCallback);\n\n        if (userCallback) {\n          userCallback.bind(ret.context)(snapshot);\n        }\n        deferred.resolve(snapshot);\n      }\n    };\n\n    this.on(\n      eventType,\n      onceCallback,\n      /*cancel=*/ err => {\n        this.off(eventType, onceCallback);\n\n        if (ret.cancel) ret.cancel.bind(ret.context)(err);\n        deferred.reject(err);\n      }\n    );\n    return deferred.promise;\n  }\n\n  /**\n   * Set a limit and anchor it to the start of the window.\n   * @param {!number} limit\n   * @return {!Query}\n   */\n  limitToFirst(limit: number): Query {\n    validateArgCount('Query.limitToFirst', 1, 1, arguments.length);\n    if (\n      typeof limit !== 'number' ||\n      Math.floor(limit) !== limit ||\n      limit <= 0\n    ) {\n      throw new Error(\n        'Query.limitToFirst: First argument must be a positive integer.'\n      );\n    }\n    if (this.queryParams_.hasLimit()) {\n      throw new Error(\n        'Query.limitToFirst: Limit was already set (by another call to limit, ' +\n          'limitToFirst, or limitToLast).'\n      );\n    }\n\n    return new Query(\n      this.repo,\n      this.path,\n      this.queryParams_.limitToFirst(limit),\n      this.orderByCalled_\n    );\n  }\n\n  /**\n   * Set a limit and anchor it to the end of the window.\n   * @param {!number} limit\n   * @return {!Query}\n   */\n  limitToLast(limit: number): Query {\n    validateArgCount('Query.limitToLast', 1, 1, arguments.length);\n    if (\n      typeof limit !== 'number' ||\n      Math.floor(limit) !== limit ||\n      limit <= 0\n    ) {\n      throw new Error(\n        'Query.limitToLast: First argument must be a positive integer.'\n      );\n    }\n    if (this.queryParams_.hasLimit()) {\n      throw new Error(\n        'Query.limitToLast: Limit was already set (by another call to limit, ' +\n          'limitToFirst, or limitToLast).'\n      );\n    }\n\n    return new Query(\n      this.repo,\n      this.path,\n      this.queryParams_.limitToLast(limit),\n      this.orderByCalled_\n    );\n  }\n\n  /**\n   * Given a child path, return a new query ordered by the specified grandchild path.\n   * @param {!string} path\n   * @return {!Query}\n   */\n  orderByChild(path: string): Query {\n    validateArgCount('Query.orderByChild', 1, 1, arguments.length);\n    if (path === '$key') {\n      throw new Error(\n        'Query.orderByChild: \"$key\" is invalid.  Use Query.orderByKey() instead.'\n      );\n    } else if (path === '$priority') {\n      throw new Error(\n        'Query.orderByChild: \"$priority\" is invalid.  Use Query.orderByPriority() instead.'\n      );\n    } else if (path === '$value') {\n      throw new Error(\n        'Query.orderByChild: \"$value\" is invalid.  Use Query.orderByValue() instead.'\n      );\n    }\n    validatePathString('Query.orderByChild', 1, path, false);\n    this.validateNoPreviousOrderByCall_('Query.orderByChild');\n    const parsedPath = new Path(path);\n    if (parsedPath.isEmpty()) {\n      throw new Error(\n        'Query.orderByChild: cannot pass in empty path.  Use Query.orderByValue() instead.'\n      );\n    }\n    const index = new PathIndex(parsedPath);\n    const newParams = this.queryParams_.orderBy(index);\n    Query.validateQueryEndpoints_(newParams);\n\n    return new Query(this.repo, this.path, newParams, /*orderByCalled=*/ true);\n  }\n\n  /**\n   * Return a new query ordered by the KeyIndex\n   * @return {!Query}\n   */\n  orderByKey(): Query {\n    validateArgCount('Query.orderByKey', 0, 0, arguments.length);\n    this.validateNoPreviousOrderByCall_('Query.orderByKey');\n    const newParams = this.queryParams_.orderBy(KEY_INDEX);\n    Query.validateQueryEndpoints_(newParams);\n    return new Query(this.repo, this.path, newParams, /*orderByCalled=*/ true);\n  }\n\n  /**\n   * Return a new query ordered by the PriorityIndex\n   * @return {!Query}\n   */\n  orderByPriority(): Query {\n    validateArgCount('Query.orderByPriority', 0, 0, arguments.length);\n    this.validateNoPreviousOrderByCall_('Query.orderByPriority');\n    const newParams = this.queryParams_.orderBy(PRIORITY_INDEX);\n    Query.validateQueryEndpoints_(newParams);\n    return new Query(this.repo, this.path, newParams, /*orderByCalled=*/ true);\n  }\n\n  /**\n   * Return a new query ordered by the ValueIndex\n   * @return {!Query}\n   */\n  orderByValue(): Query {\n    validateArgCount('Query.orderByValue', 0, 0, arguments.length);\n    this.validateNoPreviousOrderByCall_('Query.orderByValue');\n    const newParams = this.queryParams_.orderBy(VALUE_INDEX);\n    Query.validateQueryEndpoints_(newParams);\n    return new Query(this.repo, this.path, newParams, /*orderByCalled=*/ true);\n  }\n\n  /**\n   * @param {number|string|boolean|null} value\n   * @param {?string=} name\n   * @return {!Query}\n   */\n  startAt(\n    value: number | string | boolean | null = null,\n    name?: string | null\n  ): Query {\n    validateArgCount('Query.startAt', 0, 2, arguments.length);\n    validateFirebaseDataArg('Query.startAt', 1, value, this.path, true);\n    validateKey('Query.startAt', 2, name, true);\n\n    const newParams = this.queryParams_.startAt(value, name);\n    Query.validateLimit_(newParams);\n    Query.validateQueryEndpoints_(newParams);\n    if (this.queryParams_.hasStart()) {\n      throw new Error(\n        'Query.startAt: Starting point was already set (by another call to startAt ' +\n          'or equalTo).'\n      );\n    }\n\n    // Calling with no params tells us to start at the beginning.\n    if (value === undefined) {\n      value = null;\n      name = null;\n    }\n    return new Query(this.repo, this.path, newParams, this.orderByCalled_);\n  }\n\n  /**\n   * @param {number|string|boolean|null} value\n   * @param {?string=} name\n   * @return {!Query}\n   */\n  endAt(\n    value: number | string | boolean | null = null,\n    name?: string | null\n  ): Query {\n    validateArgCount('Query.endAt', 0, 2, arguments.length);\n    validateFirebaseDataArg('Query.endAt', 1, value, this.path, true);\n    validateKey('Query.endAt', 2, name, true);\n\n    const newParams = this.queryParams_.endAt(value, name);\n    Query.validateLimit_(newParams);\n    Query.validateQueryEndpoints_(newParams);\n    if (this.queryParams_.hasEnd()) {\n      throw new Error(\n        'Query.endAt: Ending point was already set (by another call to endAt or ' +\n          'equalTo).'\n      );\n    }\n\n    return new Query(this.repo, this.path, newParams, this.orderByCalled_);\n  }\n\n  /**\n   * Load the selection of children with exactly the specified value, and, optionally,\n   * the specified name.\n   * @param {number|string|boolean|null} value\n   * @param {string=} name\n   * @return {!Query}\n   */\n  equalTo(value: number | string | boolean | null, name?: string) {\n    validateArgCount('Query.equalTo', 1, 2, arguments.length);\n    validateFirebaseDataArg('Query.equalTo', 1, value, this.path, false);\n    validateKey('Query.equalTo', 2, name, true);\n    if (this.queryParams_.hasStart()) {\n      throw new Error(\n        'Query.equalTo: Starting point was already set (by another call to startAt or ' +\n          'equalTo).'\n      );\n    }\n    if (this.queryParams_.hasEnd()) {\n      throw new Error(\n        'Query.equalTo: Ending point was already set (by another call to endAt or ' +\n          'equalTo).'\n      );\n    }\n    return this.startAt(value, name).endAt(value, name);\n  }\n\n  /**\n   * @return {!string} URL for this location.\n   */\n  toString(): string {\n    validateArgCount('Query.toString', 0, 0, arguments.length);\n\n    return this.repo.toString() + this.path.toUrlEncodedString();\n  }\n\n  // Do not create public documentation. This is intended to make JSON serialization work but is otherwise unnecessary\n  // for end-users.\n  toJSON() {\n    // An optional spacer argument is unnecessary for a string.\n    validateArgCount('Query.toJSON', 0, 1, arguments.length);\n    return this.toString();\n  }\n\n  /**\n   * An object representation of the query parameters used by this Query.\n   * @return {!Object}\n   */\n  queryObject(): Object {\n    return this.queryParams_.getQueryObject();\n  }\n\n  /**\n   * @return {!string}\n   */\n  queryIdentifier(): string {\n    const obj = this.queryObject();\n    const id = ObjectToUniqueKey(obj);\n    return id === '{}' ? 'default' : id;\n  }\n\n  /**\n   * Return true if this query and the provided query are equivalent; otherwise, return false.\n   * @param {Query} other\n   * @return {boolean}\n   */\n  isEqual(other: Query): boolean {\n    validateArgCount('Query.isEqual', 1, 1, arguments.length);\n    if (!(other instanceof Query)) {\n      const error =\n        'Query.isEqual failed: First argument must be an instance of firebase.database.Query.';\n      throw new Error(error);\n    }\n\n    const sameRepo = this.repo === other.repo;\n    const samePath = this.path.equals(other.path);\n    const sameQueryIdentifier =\n      this.queryIdentifier() === other.queryIdentifier();\n\n    return sameRepo && samePath && sameQueryIdentifier;\n  }\n\n  /**\n   * Helper used by .on and .once to extract the context and or cancel arguments.\n   * @param {!string} fnName The function name (on or once)\n   * @param {(function(Error)|Object)=} cancelOrContext\n   * @param {Object=} context\n   * @return {{cancel: ?function(Error), context: ?Object}}\n   * @private\n   */\n  private static getCancelAndContextArgs_(\n    fnName: string,\n    cancelOrContext?: ((a: Error) => void) | Object,\n    context?: Object\n  ): { cancel: ((a: Error) => void) | null; context: Object | null } {\n    const ret: {\n      cancel: ((a: Error) => void) | null;\n      context: Object | null;\n    } = { cancel: null, context: null };\n    if (cancelOrContext && context) {\n      ret.cancel = cancelOrContext as (a: Error) => void;\n      validateCallback(fnName, 3, ret.cancel, true);\n\n      ret.context = context;\n      validateContextObject(fnName, 4, ret.context, true);\n    } else if (cancelOrContext) {\n      // we have either a cancel callback or a context.\n      if (typeof cancelOrContext === 'object' && cancelOrContext !== null) {\n        // it's a context!\n        ret.context = cancelOrContext;\n      } else if (typeof cancelOrContext === 'function') {\n        ret.cancel = cancelOrContext;\n      } else {\n        throw new Error(\n          errorPrefix(fnName, 3, true) +\n            ' must either be a cancel callback or a context object.'\n        );\n      }\n    }\n    return ret;\n  }\n\n  get ref(): Reference {\n    return this.getRef();\n  }\n}\n"]},"metadata":{},"sourceType":"script"}