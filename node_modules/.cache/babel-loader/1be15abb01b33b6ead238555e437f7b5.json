{"ast":null,"code":"/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n'use strict';\n\nimport { ErrorFactory } from '@firebase/util';\nimport Errors from '../models/errors';\nimport TokenManager from '../models/token-manager';\nimport NOTIFICATION_PERMISSION from '../models/notification-permission';\nvar SENDER_ID_OPTION_NAME = 'messagingSenderId';\n\nvar ControllerInterface =\n/** @class */\nfunction () {\n  /**\n   * An interface of the Messaging Service API\n   * @param {!firebase.app.App} app\n   */\n  function ControllerInterface(app) {\n    var _this = this;\n\n    this.errorFactory_ = new ErrorFactory('messaging', 'Messaging', Errors.map);\n\n    if (!app.options[SENDER_ID_OPTION_NAME] || typeof app.options[SENDER_ID_OPTION_NAME] !== 'string') {\n      throw this.errorFactory_.create(Errors.codes.BAD_SENDER_ID);\n    }\n\n    this.messagingSenderId_ = app.options[SENDER_ID_OPTION_NAME];\n    this.tokenManager_ = new TokenManager();\n    this.app = app;\n    this.INTERNAL = {};\n\n    this.INTERNAL.delete = function () {\n      return _this.delete;\n    };\n  }\n  /**\n   * @export\n   * @return {Promise<string> | Promise<null>} Returns a promise that\n   * resolves to an FCM token.\n   */\n\n\n  ControllerInterface.prototype.getToken = function () {\n    var _this = this; // Check with permissions\n\n\n    var currentPermission = this.getNotificationPermission_();\n\n    if (currentPermission !== NOTIFICATION_PERMISSION.granted) {\n      if (currentPermission === NOTIFICATION_PERMISSION.denied) {\n        return Promise.reject(this.errorFactory_.create(Errors.codes.NOTIFICATIONS_BLOCKED));\n      } // We must wait for permission to be granted\n\n\n      return Promise.resolve(null);\n    }\n\n    return this.getSWRegistration_().then(function (registration) {\n      return _this.tokenManager_.getSavedToken(_this.messagingSenderId_, registration).then(function (token) {\n        if (token) {\n          return token;\n        }\n\n        return _this.tokenManager_.createToken(_this.messagingSenderId_, registration);\n      });\n    });\n  };\n  /**\n   * This method deletes tokens that the token manager looks after and then\n   * unregisters the push subscription if it exists.\n   * @export\n   * @param {string} token\n   * @return {Promise<void>}\n   */\n\n\n  ControllerInterface.prototype.deleteToken = function (token) {\n    var _this = this;\n\n    return this.tokenManager_.deleteToken(token).then(function () {\n      return _this.getSWRegistration_().then(function (registration) {\n        if (registration) {\n          return registration.pushManager.getSubscription();\n        }\n      }).then(function (subscription) {\n        if (subscription) {\n          return subscription.unsubscribe();\n        }\n      });\n    });\n  };\n\n  ControllerInterface.prototype.getSWRegistration_ = function () {\n    throw this.errorFactory_.create(Errors.codes.SHOULD_BE_INHERITED);\n  }; //\n  // The following methods should only be available in the window.\n  //\n\n\n  ControllerInterface.prototype.requestPermission = function () {\n    throw this.errorFactory_.create(Errors.codes.AVAILABLE_IN_WINDOW);\n  };\n  /**\n   * @export\n   * @param {!ServiceWorkerRegistration} registration\n   */\n\n\n  ControllerInterface.prototype.useServiceWorker = function (registration) {\n    throw this.errorFactory_.create(Errors.codes.AVAILABLE_IN_WINDOW);\n  };\n  /**\n   * @export\n   * @param {!firebase.Observer|function(*)} nextOrObserver\n   * @param {function(!Error)=} optError\n   * @param {function()=} optCompleted\n   * @return {!function()}\n   */\n\n\n  ControllerInterface.prototype.onMessage = function (nextOrObserver, optError, optCompleted) {\n    throw this.errorFactory_.create(Errors.codes.AVAILABLE_IN_WINDOW);\n  };\n  /**\n   * @export\n   * @param {!firebase.Observer|function()} nextOrObserver An observer object\n   * or a function triggered on token refresh.\n   * @param {function(!Error)=} optError Optional A function\n   * triggered on token refresh error.\n   * @param {function()=} optCompleted Optional function triggered when the\n   * observer is removed.\n   * @return {!function()} The unsubscribe function for the observer.\n   */\n\n\n  ControllerInterface.prototype.onTokenRefresh = function (nextOrObserver, optError, optCompleted) {\n    throw this.errorFactory_.create(Errors.codes.AVAILABLE_IN_WINDOW);\n  }; //\n  // The following methods are used by the service worker only.\n  //\n\n  /**\n   * @export\n   * @param {function(Object)} callback\n   */\n\n\n  ControllerInterface.prototype.setBackgroundMessageHandler = function (callback) {\n    throw this.errorFactory_.create(Errors.codes.AVAILABLE_IN_SW);\n  }; //\n  // The following methods are used by the service themselves and not exposed\n  // publicly or not expected to be used by developers.\n  //\n\n  /**\n   * This method is required to adhere to the Firebase interface.\n   * It closes any currently open indexdb database connections.\n   */\n\n\n  ControllerInterface.prototype.delete = function () {\n    return this.tokenManager_.closeDatabase();\n  };\n  /**\n   * Returns the current Notification Permission state.\n   * @private\n   * @return {string} The currenct permission state.\n   */\n\n\n  ControllerInterface.prototype.getNotificationPermission_ = function () {\n    return Notification.permission;\n  };\n  /**\n   * @protected\n   * @returns {TokenManager}\n   */\n\n\n  ControllerInterface.prototype.getTokenManager = function () {\n    return this.tokenManager_;\n  };\n\n  return ControllerInterface;\n}();\n\nexport default ControllerInterface;","map":{"version":3,"sources":["../src/controllers/controller-interface.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n'use strict';\n\nimport { ErrorFactory } from '@firebase/util';\nimport Errors from '../models/errors';\nimport TokenManager from '../models/token-manager';\nimport NOTIFICATION_PERMISSION from '../models/notification-permission';\n\nconst SENDER_ID_OPTION_NAME = 'messagingSenderId';\n\nexport default class ControllerInterface {\n  public app;\n  public INTERNAL;\n  protected errorFactory_;\n  private messagingSenderId_: string;\n  private tokenManager_: TokenManager;\n\n  /**\n   * An interface of the Messaging Service API\n   * @param {!firebase.app.App} app\n   */\n  constructor(app) {\n    this.errorFactory_ = new ErrorFactory('messaging', 'Messaging', Errors.map);\n\n    if (\n      !app.options[SENDER_ID_OPTION_NAME] ||\n      typeof app.options[SENDER_ID_OPTION_NAME] !== 'string'\n    ) {\n      throw this.errorFactory_.create(Errors.codes.BAD_SENDER_ID);\n    }\n\n    this.messagingSenderId_ = app.options[SENDER_ID_OPTION_NAME];\n\n    this.tokenManager_ = new TokenManager();\n\n    this.app = app;\n    this.INTERNAL = {};\n    this.INTERNAL.delete = () => this.delete;\n  }\n\n  /**\n   * @export\n   * @return {Promise<string> | Promise<null>} Returns a promise that\n   * resolves to an FCM token.\n   */\n  getToken() {\n    // Check with permissions\n    const currentPermission = this.getNotificationPermission_();\n    if (currentPermission !== NOTIFICATION_PERMISSION.granted) {\n      if (currentPermission === NOTIFICATION_PERMISSION.denied) {\n        return Promise.reject(\n          this.errorFactory_.create(Errors.codes.NOTIFICATIONS_BLOCKED)\n        );\n      }\n\n      // We must wait for permission to be granted\n      return Promise.resolve(null);\n    }\n\n    return this.getSWRegistration_().then(registration => {\n      return this.tokenManager_\n        .getSavedToken(this.messagingSenderId_, registration)\n        .then(token => {\n          if (token) {\n            return token;\n          }\n\n          return this.tokenManager_.createToken(\n            this.messagingSenderId_,\n            registration\n          );\n        });\n    });\n  }\n\n  /**\n   * This method deletes tokens that the token manager looks after and then\n   * unregisters the push subscription if it exists.\n   * @export\n   * @param {string} token\n   * @return {Promise<void>}\n   */\n  deleteToken(token) {\n    return this.tokenManager_.deleteToken(token).then(() => {\n      return this.getSWRegistration_()\n        .then(registration => {\n          if (registration) {\n            return registration.pushManager.getSubscription();\n          }\n        })\n        .then(subscription => {\n          if (subscription) {\n            return subscription.unsubscribe();\n          }\n        });\n    });\n  }\n\n  getSWRegistration_(): Promise<ServiceWorkerRegistration> {\n    throw this.errorFactory_.create(Errors.codes.SHOULD_BE_INHERITED);\n  }\n\n  //\n  // The following methods should only be available in the window.\n  //\n\n  requestPermission() {\n    throw this.errorFactory_.create(Errors.codes.AVAILABLE_IN_WINDOW);\n  }\n\n  /**\n   * @export\n   * @param {!ServiceWorkerRegistration} registration\n   */\n  useServiceWorker(registration) {\n    throw this.errorFactory_.create(Errors.codes.AVAILABLE_IN_WINDOW);\n  }\n\n  /**\n   * @export\n   * @param {!firebase.Observer|function(*)} nextOrObserver\n   * @param {function(!Error)=} optError\n   * @param {function()=} optCompleted\n   * @return {!function()}\n   */\n  onMessage(nextOrObserver, optError, optCompleted) {\n    throw this.errorFactory_.create(Errors.codes.AVAILABLE_IN_WINDOW);\n  }\n\n  /**\n   * @export\n   * @param {!firebase.Observer|function()} nextOrObserver An observer object\n   * or a function triggered on token refresh.\n   * @param {function(!Error)=} optError Optional A function\n   * triggered on token refresh error.\n   * @param {function()=} optCompleted Optional function triggered when the\n   * observer is removed.\n   * @return {!function()} The unsubscribe function for the observer.\n   */\n  onTokenRefresh(nextOrObserver, optError, optCompleted) {\n    throw this.errorFactory_.create(Errors.codes.AVAILABLE_IN_WINDOW);\n  }\n\n  //\n  // The following methods are used by the service worker only.\n  //\n\n  /**\n   * @export\n   * @param {function(Object)} callback\n   */\n  setBackgroundMessageHandler(callback) {\n    throw this.errorFactory_.create(Errors.codes.AVAILABLE_IN_SW);\n  }\n\n  //\n  // The following methods are used by the service themselves and not exposed\n  // publicly or not expected to be used by developers.\n  //\n\n  /**\n   * This method is required to adhere to the Firebase interface.\n   * It closes any currently open indexdb database connections.\n   */\n  delete() {\n    return this.tokenManager_.closeDatabase();\n  }\n\n  /**\n   * Returns the current Notification Permission state.\n   * @private\n   * @return {string} The currenct permission state.\n   */\n  getNotificationPermission_() {\n    return (Notification as any).permission;\n  }\n\n  /**\n   * @protected\n   * @returns {TokenManager}\n   */\n  getTokenManager() {\n    return this.tokenManager_;\n  }\n}\n"]},"metadata":{},"sourceType":"module"}