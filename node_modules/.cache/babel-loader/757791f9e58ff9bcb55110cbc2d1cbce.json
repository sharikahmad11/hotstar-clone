{"ast":null,"code":"/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n'use strict';\n\nvar __extends = this && this.__extends || function () {\n  var extendStatics = Object.setPrototypeOf || {\n    __proto__: []\n  } instanceof Array && function (d, b) {\n    d.__proto__ = b;\n  } || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n  };\n\n  return function (d, b) {\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nimport ControllerInterface from './controller-interface';\nimport Errors from '../models/errors';\nimport WorkerPageMessage from '../models/worker-page-message';\nimport DefaultSW from '../models/default-sw';\nimport NOTIFICATION_PERMISSION from '../models/notification-permission';\nimport { createSubscribe } from '@firebase/util';\n\nvar WindowController =\n/** @class */\nfunction (_super) {\n  __extends(WindowController, _super);\n  /**\n   * A service that provides a MessagingService instance.\n   * @param {!firebase.app.App} app\n   */\n\n\n  function WindowController(app) {\n    var _this = _super.call(this, app) || this;\n    /**\n     * @private\n     * @type {ServiceWorkerRegistration}\n     */\n\n\n    _this.registrationToUse_;\n    /**\n     * @private\n     * @type {Promise}\n     */\n\n    _this.manifestCheckPromise_;\n    /**\n     * @private\n     * @type {firebase.Observer}\n     */\n\n    _this.messageObserver_ = null;\n    /**\n     * @private {!firebase.Subscribe} The subscribe function to the onMessage\n     * observer.\n     */\n\n    _this.onMessage_ = createSubscribe(function (observer) {\n      _this.messageObserver_ = observer;\n    });\n    /**\n     * @private\n     * @type {firebase.Observer}\n     */\n\n    _this.tokenRefreshObserver_ = null;\n    _this.onTokenRefresh_ = createSubscribe(function (observer) {\n      _this.tokenRefreshObserver_ = observer;\n    });\n\n    _this.setupSWMessageListener_();\n\n    return _this;\n  }\n  /**\n   * This method returns an FCM token if it can be generated.\n   * The return promise will reject if the browser doesn't support\n   * FCM, if permission is denied for notifications or it's not\n   * possible to generate a token.\n   * @export\n   * @return {Promise<string> | Promise<null>} Returns a promise the\n   * resolves to an FCM token or null if permission isn't granted.\n   */\n\n\n  WindowController.prototype.getToken = function () {\n    var _this = this; // Check that the required API's are available\n\n\n    if (!this.isSupported_()) {\n      return Promise.reject(this.errorFactory_.create(Errors.codes.UNSUPPORTED_BROWSER));\n    }\n\n    return this.manifestCheck_().then(function () {\n      return _super.prototype.getToken.call(_this);\n    });\n  };\n  /**\n   * The method checks that a manifest is defined and has the correct GCM\n   * sender ID.\n   * @private\n   * @return {Promise} Returns a promise that resolves if the manifest matches\n   * our required sender ID\n   */\n\n\n  WindowController.prototype.manifestCheck_ = function () {\n    var _this = this;\n\n    if (this.manifestCheckPromise_) {\n      return this.manifestCheckPromise_;\n    }\n\n    var manifestTag = document.querySelector('link[rel=\"manifest\"]');\n\n    if (!manifestTag) {\n      this.manifestCheckPromise_ = Promise.resolve();\n    } else {\n      this.manifestCheckPromise_ = fetch(manifestTag.href).then(function (response) {\n        return response.json();\n      }).catch(function () {\n        // If the download or parsing fails allow check.\n        // We only want to error if we KNOW that the gcm_sender_id is incorrect.\n        return Promise.resolve();\n      }).then(function (manifestContent) {\n        if (!manifestContent) {\n          return;\n        }\n\n        if (!manifestContent['gcm_sender_id']) {\n          return;\n        }\n\n        if (manifestContent['gcm_sender_id'] !== '103953800507') {\n          throw _this.errorFactory_.create(Errors.codes.INCORRECT_GCM_SENDER_ID);\n        }\n      });\n    }\n\n    return this.manifestCheckPromise_;\n  };\n  /**\n   * Request permission if it is not currently granted\n   * @export\n   * @returns {Promise} Resolves if the permission was granted, otherwise\n   * rejects\n   */\n\n\n  WindowController.prototype.requestPermission = function () {\n    var _this = this;\n\n    if (Notification.permission === NOTIFICATION_PERMISSION.granted) {\n      return Promise.resolve();\n    }\n\n    return new Promise(function (resolve, reject) {\n      var managePermissionResult = function (result) {\n        if (result === NOTIFICATION_PERMISSION.granted) {\n          return resolve();\n        } else if (result === NOTIFICATION_PERMISSION.denied) {\n          return reject(_this.errorFactory_.create(Errors.codes.PERMISSION_BLOCKED));\n        } else {\n          return reject(_this.errorFactory_.create(Errors.codes.PERMISSION_DEFAULT));\n        }\n      }; // The Notification.requestPermission API was changed to\n      // return a promise so now have to handle both in case\n      // browsers stop support callbacks for promised version\n\n\n      var permissionPromise = Notification.requestPermission(function (result) {\n        if (permissionPromise) {\n          // Let the promise manage this\n          return;\n        }\n\n        managePermissionResult(result);\n      });\n\n      if (permissionPromise) {\n        // Prefer the promise version as it's the future API.\n        permissionPromise.then(managePermissionResult);\n      }\n    });\n  };\n  /**\n   * This method allows a developer to override the default service worker and\n   * instead use a custom service worker.\n   * @export\n   * @param {!ServiceWorkerRegistration} registration The service worker\n   * registration that should be used to receive the push messages.\n   */\n\n\n  WindowController.prototype.useServiceWorker = function (registration) {\n    if (!(registration instanceof ServiceWorkerRegistration)) {\n      throw this.errorFactory_.create(Errors.codes.SW_REGISTRATION_EXPECTED);\n    }\n\n    if (typeof this.registrationToUse_ !== 'undefined') {\n      throw this.errorFactory_.create(Errors.codes.USE_SW_BEFORE_GET_TOKEN);\n    }\n\n    this.registrationToUse_ = registration;\n  };\n  /**\n   * @export\n   * @param {!firebase.Observer|function(*)} nextOrObserver An observer object\n   * or a function triggered on message.\n   * @param {function(!Error)=} optError Optional A function triggered on\n   * message error.\n   * @param {function()=} optCompleted Optional function triggered when the\n   * observer is removed.\n   * @return {!function()} The unsubscribe function for the observer.\n   */\n\n\n  WindowController.prototype.onMessage = function (nextOrObserver, optError, optCompleted) {\n    return this.onMessage_(nextOrObserver, optError, optCompleted);\n  };\n  /**\n   * @export\n   * @param {!firebase.Observer|function()} nextOrObserver An observer object\n   * or a function triggered on token refresh.\n   * @param {function(!Error)=} optError Optional A function\n   * triggered on token refresh error.\n   * @param {function()=} optCompleted Optional function triggered when the\n   * observer is removed.\n   * @return {!function()} The unsubscribe function for the observer.\n   */\n\n\n  WindowController.prototype.onTokenRefresh = function (nextOrObserver, optError, optCompleted) {\n    return this.onTokenRefresh_(nextOrObserver, optError, optCompleted);\n  };\n  /**\n   * Given a registration, wait for the service worker it relates to\n   * become activer\n   * @private\n   * @param  {ServiceWorkerRegistration} registration Registration to wait\n   * for service worker to become active\n   * @return {Promise<!ServiceWorkerRegistration>} Wait for service worker\n   * registration to become active\n   */\n\n\n  WindowController.prototype.waitForRegistrationToActivate_ = function (registration) {\n    var _this = this;\n\n    var serviceWorker = registration.installing || registration.waiting || registration.active;\n    return new Promise(function (resolve, reject) {\n      if (!serviceWorker) {\n        // This is a rare scenario but has occured in firefox\n        reject(_this.errorFactory_.create(Errors.codes.NO_SW_IN_REG));\n        return;\n      } // Because the Promise function is called on next tick there is a\n      // small chance that the worker became active or redundant already.\n\n\n      if (serviceWorker.state === 'activated') {\n        resolve(registration);\n        return;\n      }\n\n      if (serviceWorker.state === 'redundant') {\n        reject(_this.errorFactory_.create(Errors.codes.SW_REG_REDUNDANT));\n        return;\n      }\n\n      var stateChangeListener = function () {\n        if (serviceWorker.state === 'activated') {\n          resolve(registration);\n        } else if (serviceWorker.state === 'redundant') {\n          reject(_this.errorFactory_.create(Errors.codes.SW_REG_REDUNDANT));\n        } else {\n          // Return early and wait to next state change\n          return;\n        }\n\n        serviceWorker.removeEventListener('statechange', stateChangeListener);\n      };\n\n      serviceWorker.addEventListener('statechange', stateChangeListener);\n    });\n  };\n  /**\n   * This will regiater the default service worker and return the registration\n   * @private\n   * @return {Promise<!ServiceWorkerRegistration>} The service worker\n   * registration to be used for the push service.\n   */\n\n\n  WindowController.prototype.getSWRegistration_ = function () {\n    var _this = this;\n\n    if (this.registrationToUse_) {\n      return this.waitForRegistrationToActivate_(this.registrationToUse_);\n    } // Make the registration null so we know useServiceWorker will not\n    // use a new service worker as registrationToUse_ is no longer undefined\n\n\n    this.registrationToUse_ = null;\n    return navigator.serviceWorker.register(DefaultSW.path, {\n      scope: DefaultSW.scope\n    }).catch(function (err) {\n      throw _this.errorFactory_.create(Errors.codes.FAILED_DEFAULT_REGISTRATION, {\n        browserErrorMessage: err.message\n      });\n    }).then(function (registration) {\n      return _this.waitForRegistrationToActivate_(registration).then(function () {\n        _this.registrationToUse_ = registration; // We update after activation due to an issue with Firefox v49 where\n        // a race condition occassionally causes the service work to not\n        // install\n\n        registration.update();\n        return registration;\n      });\n    });\n  };\n  /**\n   * This method will set up a message listener to handle\n   * events from the service worker that should trigger\n   * events in the page.\n   *\n   * @private\n   */\n\n\n  WindowController.prototype.setupSWMessageListener_ = function () {\n    var _this = this;\n\n    if (!('serviceWorker' in navigator)) {\n      return;\n    }\n\n    navigator.serviceWorker.addEventListener('message', function (event) {\n      if (!event.data || !event.data[WorkerPageMessage.PARAMS.TYPE_OF_MSG]) {\n        // Not a message from FCM\n        return;\n      }\n\n      var workerPageMessage = event.data;\n\n      switch (workerPageMessage[WorkerPageMessage.PARAMS.TYPE_OF_MSG]) {\n        case WorkerPageMessage.TYPES_OF_MSG.PUSH_MSG_RECEIVED:\n        case WorkerPageMessage.TYPES_OF_MSG.NOTIFICATION_CLICKED:\n          var pushMessage = workerPageMessage[WorkerPageMessage.PARAMS.DATA];\n\n          _this.messageObserver_.next(pushMessage);\n\n          break;\n\n        default:\n          // Noop.\n          break;\n      }\n    }, false);\n  };\n  /**\n   * Checks to see if the required API's are valid or not.\n   * @private\n   * @return {boolean} Returns true if the desired APIs are available.\n   */\n\n\n  WindowController.prototype.isSupported_ = function () {\n    return 'serviceWorker' in navigator && 'PushManager' in window && 'Notification' in window && 'fetch' in window && ServiceWorkerRegistration.prototype.hasOwnProperty('showNotification') && PushSubscription.prototype.hasOwnProperty('getKey');\n  };\n\n  return WindowController;\n}(ControllerInterface);\n\nexport default WindowController;","map":{"version":3,"sources":["../src/controllers/window-controller.ts"],"names":[],"mappings":"AAAA;;;;;;;;;;;;;;AAcG;AACH;;;;;;;;;;;;;;;;;;;;;;AAEA,OAAO,mBAAP,MAAgC,wBAAhC;AACA,OAAO,MAAP,MAAmB,kBAAnB;AACA,OAAO,iBAAP,MAA8B,+BAA9B;AACA,OAAO,SAAP,MAAsB,sBAAtB;AACA,OAAO,uBAAP,MAAoC,mCAApC;AACA,SAAS,eAAT,QAAgC,gBAAhC;;AAIA,IAAA,gBAAA;AAAA;AAAA,UAAA,MAAA,EAAA;AAA8C,EAAA,SAAA,CAAA,gBAAA,EAAA,MAAA,CAAA;AAQ5C;;;AAGG;;;AACH,WAAA,gBAAA,CAAY,GAAZ,EAAe;AAAf,QAAA,KAAA,GACE,MAAA,CAAA,IAAA,CAAA,IAAA,EAAM,GAAN,KAAU,IADZ;AAGE;;;AAGG;;;AACH,IAAA,KAAI,CAAC,kBAAL;AAEA;;;AAGG;;AACH,IAAA,KAAI,CAAC,qBAAL;AAEA;;;AAGG;;AACH,IAAA,KAAI,CAAC,gBAAL,GAAwB,IAAxB;AACA;;;AAGG;;AACH,IAAA,KAAI,CAAC,UAAL,GAAkB,eAAe,CAAC,UAAA,QAAA,EAAQ;AACxC,MAAA,KAAI,CAAC,gBAAL,GAAwB,QAAxB;AACD,KAFgC,CAAjC;AAIA;;;AAGG;;AACH,IAAA,KAAI,CAAC,qBAAL,GAA6B,IAA7B;AACA,IAAA,KAAI,CAAC,eAAL,GAAuB,eAAe,CAAC,UAAA,QAAA,EAAQ;AAC7C,MAAA,KAAI,CAAC,qBAAL,GAA6B,QAA7B;AACD,KAFqC,CAAtC;;AAIA,IAAA,KAAI,CAAC,uBAAL;;;AACD;AAED;;;;;;;;AAQG;;;AACH,EAAA,gBAAA,CAAA,SAAA,CAAA,QAAA,GAAA,YAAA;AAAA,QAAA,KAAA,GAAA,IAAA,CAAA,CACE;;;AACA,QAAI,CAAC,KAAK,YAAL,EAAL,EAA0B;AACxB,aAAO,OAAO,CAAC,MAAR,CACL,KAAK,aAAL,CAAmB,MAAnB,CAA0B,MAAM,CAAC,KAAP,CAAa,mBAAvC,CADK,CAAP;AAGD;;AAED,WAAO,KAAK,cAAL,GAAsB,IAAtB,CAA2B,YAAA;AAChC,aAAO,MAAA,CAAA,SAAA,CAAM,QAAN,CAAc,IAAd,CAAc,KAAd,CAAP;AACD,KAFM,CAAP;AAGD,GAXD;AAaA;;;;;;AAMG;;;AACH,EAAA,gBAAA,CAAA,SAAA,CAAA,cAAA,GAAA,YAAA;AAAA,QAAA,KAAA,GAAA,IAAA;;AACE,QAAI,KAAK,qBAAT,EAAgC;AAC9B,aAAO,KAAK,qBAAZ;AACD;;AAED,QAAM,WAAW,GAAsB,QAAQ,CAAC,aAAT,CACrC,sBADqC,CAAvC;;AAGA,QAAI,CAAC,WAAL,EAAkB;AAChB,WAAK,qBAAL,GAA6B,OAAO,CAAC,OAAR,EAA7B;AACD,KAFD,MAEO;AACL,WAAK,qBAAL,GAA6B,KAAK,CAAC,WAAW,CAAC,IAAb,CAAL,CAC1B,IAD0B,CACrB,UAAA,QAAA,EAAQ;AACZ,eAAO,QAAQ,CAAC,IAAT,EAAP;AACD,OAH0B,EAI1B,KAJ0B,CAIpB,YAAA;AACL;AACA;AACA,eAAO,OAAO,CAAC,OAAR,EAAP;AACD,OAR0B,EAS1B,IAT0B,CASrB,UAAA,eAAA,EAAe;AACnB,YAAI,CAAC,eAAL,EAAsB;AACpB;AACD;;AAED,YAAI,CAAC,eAAe,CAAC,eAAD,CAApB,EAAuC;AACrC;AACD;;AAED,YAAI,eAAe,CAAC,eAAD,CAAf,KAAqC,cAAzC,EAAyD;AACvD,gBAAM,KAAI,CAAC,aAAL,CAAmB,MAAnB,CACJ,MAAM,CAAC,KAAP,CAAa,uBADT,CAAN;AAGD;AACF,OAvB0B,CAA7B;AAwBD;;AAED,WAAO,KAAK,qBAAZ;AACD,GAtCD;AAwCA;;;;;AAKG;;;AACH,EAAA,gBAAA,CAAA,SAAA,CAAA,iBAAA,GAAA,YAAA;AAAA,QAAA,KAAA,GAAA,IAAA;;AACE,QAAK,YAAoB,CAAC,UAArB,KAAoC,uBAAuB,CAAC,OAAjE,EAA0E;AACxE,aAAO,OAAO,CAAC,OAAR,EAAP;AACD;;AAED,WAAO,IAAI,OAAJ,CAAY,UAAC,OAAD,EAAU,MAAV,EAAgB;AACjC,UAAM,sBAAsB,GAAG,UAAA,MAAA,EAAM;AACnC,YAAI,MAAM,KAAK,uBAAuB,CAAC,OAAvC,EAAgD;AAC9C,iBAAO,OAAO,EAAd;AACD,SAFD,MAEO,IAAI,MAAM,KAAK,uBAAuB,CAAC,MAAvC,EAA+C;AACpD,iBAAO,MAAM,CACX,KAAI,CAAC,aAAL,CAAmB,MAAnB,CAA0B,MAAM,CAAC,KAAP,CAAa,kBAAvC,CADW,CAAb;AAGD,SAJM,MAIA;AACL,iBAAO,MAAM,CACX,KAAI,CAAC,aAAL,CAAmB,MAAnB,CAA0B,MAAM,CAAC,KAAP,CAAa,kBAAvC,CADW,CAAb;AAGD;AACF,OAZD,CADiC,CAejC;AACA;AACA;;;AACA,UAAM,iBAAiB,GAAG,YAAY,CAAC,iBAAb,CAA+B,UAAA,MAAA,EAAM;AAC7D,YAAI,iBAAJ,EAAuB;AACrB;AACA;AACD;;AAED,QAAA,sBAAsB,CAAC,MAAD,CAAtB;AACD,OAPyB,CAA1B;;AASA,UAAI,iBAAJ,EAAuB;AACrB;AACA,QAAA,iBAAiB,CAAC,IAAlB,CAAuB,sBAAvB;AACD;AACF,KA/BM,CAAP;AAgCD,GArCD;AAuCA;;;;;;AAMG;;;AACH,EAAA,gBAAA,CAAA,SAAA,CAAA,gBAAA,GAAA,UAAiB,YAAjB,EAA6B;AAC3B,QAAI,EAAE,YAAY,YAAY,yBAA1B,CAAJ,EAA0D;AACxD,YAAM,KAAK,aAAL,CAAmB,MAAnB,CAA0B,MAAM,CAAC,KAAP,CAAa,wBAAvC,CAAN;AACD;;AAED,QAAI,OAAO,KAAK,kBAAZ,KAAmC,WAAvC,EAAoD;AAClD,YAAM,KAAK,aAAL,CAAmB,MAAnB,CAA0B,MAAM,CAAC,KAAP,CAAa,uBAAvC,CAAN;AACD;;AAED,SAAK,kBAAL,GAA0B,YAA1B;AACD,GAVD;AAYA;;;;;;;;;AASG;;;AACH,EAAA,gBAAA,CAAA,SAAA,CAAA,SAAA,GAAA,UAAU,cAAV,EAA0B,QAA1B,EAAoC,YAApC,EAAgD;AAC9C,WAAO,KAAK,UAAL,CAAgB,cAAhB,EAAgC,QAAhC,EAA0C,YAA1C,CAAP;AACD,GAFD;AAIA;;;;;;;;;AASG;;;AACH,EAAA,gBAAA,CAAA,SAAA,CAAA,cAAA,GAAA,UAAe,cAAf,EAA+B,QAA/B,EAAyC,YAAzC,EAAqD;AACnD,WAAO,KAAK,eAAL,CAAqB,cAArB,EAAqC,QAArC,EAA+C,YAA/C,CAAP;AACD,GAFD;AAIA;;;;;;;;AAQG;;;AACH,EAAA,gBAAA,CAAA,SAAA,CAAA,8BAAA,GAAA,UAA+B,YAA/B,EAA2C;AAA3C,QAAA,KAAA,GAAA,IAAA;;AACE,QAAM,aAAa,GACjB,YAAY,CAAC,UAAb,IAA2B,YAAY,CAAC,OAAxC,IAAmD,YAAY,CAAC,MADlE;AAGA,WAAO,IAAI,OAAJ,CAAuC,UAAC,OAAD,EAAU,MAAV,EAAgB;AAC5D,UAAI,CAAC,aAAL,EAAoB;AAClB;AACA,QAAA,MAAM,CAAC,KAAI,CAAC,aAAL,CAAmB,MAAnB,CAA0B,MAAM,CAAC,KAAP,CAAa,YAAvC,CAAD,CAAN;AACA;AACD,OAL2D,CAM5D;AACA;;;AACA,UAAI,aAAa,CAAC,KAAd,KAAwB,WAA5B,EAAyC;AACvC,QAAA,OAAO,CAAC,YAAD,CAAP;AACA;AACD;;AAED,UAAI,aAAa,CAAC,KAAd,KAAwB,WAA5B,EAAyC;AACvC,QAAA,MAAM,CAAC,KAAI,CAAC,aAAL,CAAmB,MAAnB,CAA0B,MAAM,CAAC,KAAP,CAAa,gBAAvC,CAAD,CAAN;AACA;AACD;;AAED,UAAI,mBAAmB,GAAG,YAAA;AACxB,YAAI,aAAa,CAAC,KAAd,KAAwB,WAA5B,EAAyC;AACvC,UAAA,OAAO,CAAC,YAAD,CAAP;AACD,SAFD,MAEO,IAAI,aAAa,CAAC,KAAd,KAAwB,WAA5B,EAAyC;AAC9C,UAAA,MAAM,CAAC,KAAI,CAAC,aAAL,CAAmB,MAAnB,CAA0B,MAAM,CAAC,KAAP,CAAa,gBAAvC,CAAD,CAAN;AACD,SAFM,MAEA;AACL;AACA;AACD;;AACD,QAAA,aAAa,CAAC,mBAAd,CAAkC,aAAlC,EAAiD,mBAAjD;AACD,OAVD;;AAWA,MAAA,aAAa,CAAC,gBAAd,CAA+B,aAA/B,EAA8C,mBAA9C;AACD,KA9BM,CAAP;AA+BD,GAnCD;AAqCA;;;;;AAKG;;;AACH,EAAA,gBAAA,CAAA,SAAA,CAAA,kBAAA,GAAA,YAAA;AAAA,QAAA,KAAA,GAAA,IAAA;;AACE,QAAI,KAAK,kBAAT,EAA6B;AAC3B,aAAO,KAAK,8BAAL,CAAoC,KAAK,kBAAzC,CAAP;AACD,KAHH,CAKE;AACA;;;AACA,SAAK,kBAAL,GAA0B,IAA1B;AAEA,WAAO,SAAS,CAAC,aAAV,CACJ,QADI,CACK,SAAS,CAAC,IADf,EACqB;AACxB,MAAA,KAAK,EAAE,SAAS,CAAC;AADO,KADrB,EAIJ,KAJI,CAIE,UAAA,GAAA,EAAG;AACR,YAAM,KAAI,CAAC,aAAL,CAAmB,MAAnB,CACJ,MAAM,CAAC,KAAP,CAAa,2BADT,EAEJ;AACE,QAAA,mBAAmB,EAAE,GAAG,CAAC;AAD3B,OAFI,CAAN;AAMD,KAXI,EAYJ,IAZI,CAYC,UAAA,YAAA,EAAY;AAChB,aAAO,KAAI,CAAC,8BAAL,CAAoC,YAApC,EAAkD,IAAlD,CAAuD,YAAA;AAC5D,QAAA,KAAI,CAAC,kBAAL,GAA0B,YAA1B,CAD4D,CAG5D;AACA;AACA;;AACA,QAAA,YAAY,CAAC,MAAb;AAEA,eAAO,YAAP;AACD,OATM,CAAP;AAUD,KAvBI,CAAP;AAwBD,GAjCD;AAmCA;;;;;;AAMG;;;AACH,EAAA,gBAAA,CAAA,SAAA,CAAA,uBAAA,GAAA,YAAA;AAAA,QAAA,KAAA,GAAA,IAAA;;AACE,QAAI,EAAE,mBAAmB,SAArB,CAAJ,EAAqC;AACnC;AACD;;AAED,IAAA,SAAS,CAAC,aAAV,CAAwB,gBAAxB,CACE,SADF,EAEE,UAAA,KAAA,EAAK;AACH,UAAI,CAAC,KAAK,CAAC,IAAP,IAAe,CAAC,KAAK,CAAC,IAAN,CAAW,iBAAiB,CAAC,MAAlB,CAAyB,WAApC,CAApB,EAAsE;AACpE;AACA;AACD;;AAED,UAAM,iBAAiB,GAAG,KAAK,CAAC,IAAhC;;AACA,cAAQ,iBAAiB,CAAC,iBAAiB,CAAC,MAAlB,CAAyB,WAA1B,CAAzB;AACE,aAAK,iBAAiB,CAAC,YAAlB,CAA+B,iBAApC;AACA,aAAK,iBAAiB,CAAC,YAAlB,CAA+B,oBAApC;AACE,cAAM,WAAW,GACf,iBAAiB,CAAC,iBAAiB,CAAC,MAAlB,CAAyB,IAA1B,CADnB;;AAEA,UAAA,KAAI,CAAC,gBAAL,CAAsB,IAAtB,CAA2B,WAA3B;;AACA;;AACF;AACE;AACA;AATJ;AAWD,KApBH,EAqBE,KArBF;AAuBD,GA5BD;AA8BA;;;;AAIG;;;AACH,EAAA,gBAAA,CAAA,SAAA,CAAA,YAAA,GAAA,YAAA;AACE,WACE,mBAAmB,SAAnB,IACA,iBAAiB,MADjB,IAEA,kBAAkB,MAFlB,IAGA,WAAW,MAHX,IAIA,yBAAyB,CAAC,SAA1B,CAAoC,cAApC,CAAmD,kBAAnD,CAJA,IAKA,gBAAgB,CAAC,SAAjB,CAA2B,cAA3B,CAA0C,QAA1C,CANF;AAQD,GATD;;AAUF,SAAA,gBAAA;AAAC,CAhWD,CAA8C,mBAA9C,CAAA","sourcesContent":["/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n'use strict';\n\nimport ControllerInterface from './controller-interface';\nimport Errors from '../models/errors';\nimport WorkerPageMessage from '../models/worker-page-message';\nimport DefaultSW from '../models/default-sw';\nimport NOTIFICATION_PERMISSION from '../models/notification-permission';\nimport { createSubscribe } from '@firebase/util';\n\ndeclare const firebase: any;\n\nexport default class WindowController extends ControllerInterface {\n  private registrationToUse_;\n  private manifestCheckPromise_;\n  private messageObserver_;\n  private onMessage_;\n  private tokenRefreshObserver_;\n  private onTokenRefresh_;\n\n  /**\n   * A service that provides a MessagingService instance.\n   * @param {!firebase.app.App} app\n   */\n  constructor(app) {\n    super(app);\n\n    /**\n     * @private\n     * @type {ServiceWorkerRegistration}\n     */\n    this.registrationToUse_;\n\n    /**\n     * @private\n     * @type {Promise}\n     */\n    this.manifestCheckPromise_;\n\n    /**\n     * @private\n     * @type {firebase.Observer}\n     */\n    this.messageObserver_ = null;\n    /**\n     * @private {!firebase.Subscribe} The subscribe function to the onMessage\n     * observer.\n     */\n    this.onMessage_ = createSubscribe(observer => {\n      this.messageObserver_ = observer;\n    });\n\n    /**\n     * @private\n     * @type {firebase.Observer}\n     */\n    this.tokenRefreshObserver_ = null;\n    this.onTokenRefresh_ = createSubscribe(observer => {\n      this.tokenRefreshObserver_ = observer;\n    });\n\n    this.setupSWMessageListener_();\n  }\n\n  /**\n   * This method returns an FCM token if it can be generated.\n   * The return promise will reject if the browser doesn't support\n   * FCM, if permission is denied for notifications or it's not\n   * possible to generate a token.\n   * @export\n   * @return {Promise<string> | Promise<null>} Returns a promise the\n   * resolves to an FCM token or null if permission isn't granted.\n   */\n  getToken() {\n    // Check that the required API's are available\n    if (!this.isSupported_()) {\n      return Promise.reject(\n        this.errorFactory_.create(Errors.codes.UNSUPPORTED_BROWSER)\n      );\n    }\n\n    return this.manifestCheck_().then(() => {\n      return super.getToken();\n    });\n  }\n\n  /**\n   * The method checks that a manifest is defined and has the correct GCM\n   * sender ID.\n   * @private\n   * @return {Promise} Returns a promise that resolves if the manifest matches\n   * our required sender ID\n   */\n  manifestCheck_() {\n    if (this.manifestCheckPromise_) {\n      return this.manifestCheckPromise_;\n    }\n\n    const manifestTag = <HTMLAnchorElement>document.querySelector(\n      'link[rel=\"manifest\"]'\n    );\n    if (!manifestTag) {\n      this.manifestCheckPromise_ = Promise.resolve();\n    } else {\n      this.manifestCheckPromise_ = fetch(manifestTag.href)\n        .then(response => {\n          return response.json();\n        })\n        .catch(() => {\n          // If the download or parsing fails allow check.\n          // We only want to error if we KNOW that the gcm_sender_id is incorrect.\n          return Promise.resolve();\n        })\n        .then(manifestContent => {\n          if (!manifestContent) {\n            return;\n          }\n\n          if (!manifestContent['gcm_sender_id']) {\n            return;\n          }\n\n          if (manifestContent['gcm_sender_id'] !== '103953800507') {\n            throw this.errorFactory_.create(\n              Errors.codes.INCORRECT_GCM_SENDER_ID\n            );\n          }\n        });\n    }\n\n    return this.manifestCheckPromise_;\n  }\n\n  /**\n   * Request permission if it is not currently granted\n   * @export\n   * @returns {Promise} Resolves if the permission was granted, otherwise\n   * rejects\n   */\n  requestPermission() {\n    if ((Notification as any).permission === NOTIFICATION_PERMISSION.granted) {\n      return Promise.resolve();\n    }\n\n    return new Promise((resolve, reject) => {\n      const managePermissionResult = result => {\n        if (result === NOTIFICATION_PERMISSION.granted) {\n          return resolve();\n        } else if (result === NOTIFICATION_PERMISSION.denied) {\n          return reject(\n            this.errorFactory_.create(Errors.codes.PERMISSION_BLOCKED)\n          );\n        } else {\n          return reject(\n            this.errorFactory_.create(Errors.codes.PERMISSION_DEFAULT)\n          );\n        }\n      };\n\n      // The Notification.requestPermission API was changed to\n      // return a promise so now have to handle both in case\n      // browsers stop support callbacks for promised version\n      const permissionPromise = Notification.requestPermission(result => {\n        if (permissionPromise) {\n          // Let the promise manage this\n          return;\n        }\n\n        managePermissionResult(result);\n      });\n\n      if (permissionPromise) {\n        // Prefer the promise version as it's the future API.\n        permissionPromise.then(managePermissionResult);\n      }\n    });\n  }\n\n  /**\n   * This method allows a developer to override the default service worker and\n   * instead use a custom service worker.\n   * @export\n   * @param {!ServiceWorkerRegistration} registration The service worker\n   * registration that should be used to receive the push messages.\n   */\n  useServiceWorker(registration) {\n    if (!(registration instanceof ServiceWorkerRegistration)) {\n      throw this.errorFactory_.create(Errors.codes.SW_REGISTRATION_EXPECTED);\n    }\n\n    if (typeof this.registrationToUse_ !== 'undefined') {\n      throw this.errorFactory_.create(Errors.codes.USE_SW_BEFORE_GET_TOKEN);\n    }\n\n    this.registrationToUse_ = registration;\n  }\n\n  /**\n   * @export\n   * @param {!firebase.Observer|function(*)} nextOrObserver An observer object\n   * or a function triggered on message.\n   * @param {function(!Error)=} optError Optional A function triggered on\n   * message error.\n   * @param {function()=} optCompleted Optional function triggered when the\n   * observer is removed.\n   * @return {!function()} The unsubscribe function for the observer.\n   */\n  onMessage(nextOrObserver, optError, optCompleted) {\n    return this.onMessage_(nextOrObserver, optError, optCompleted);\n  }\n\n  /**\n   * @export\n   * @param {!firebase.Observer|function()} nextOrObserver An observer object\n   * or a function triggered on token refresh.\n   * @param {function(!Error)=} optError Optional A function\n   * triggered on token refresh error.\n   * @param {function()=} optCompleted Optional function triggered when the\n   * observer is removed.\n   * @return {!function()} The unsubscribe function for the observer.\n   */\n  onTokenRefresh(nextOrObserver, optError, optCompleted) {\n    return this.onTokenRefresh_(nextOrObserver, optError, optCompleted);\n  }\n\n  /**\n   * Given a registration, wait for the service worker it relates to\n   * become activer\n   * @private\n   * @param  {ServiceWorkerRegistration} registration Registration to wait\n   * for service worker to become active\n   * @return {Promise<!ServiceWorkerRegistration>} Wait for service worker\n   * registration to become active\n   */\n  waitForRegistrationToActivate_(registration) {\n    const serviceWorker =\n      registration.installing || registration.waiting || registration.active;\n\n    return new Promise<ServiceWorkerRegistration>((resolve, reject) => {\n      if (!serviceWorker) {\n        // This is a rare scenario but has occured in firefox\n        reject(this.errorFactory_.create(Errors.codes.NO_SW_IN_REG));\n        return;\n      }\n      // Because the Promise function is called on next tick there is a\n      // small chance that the worker became active or redundant already.\n      if (serviceWorker.state === 'activated') {\n        resolve(registration);\n        return;\n      }\n\n      if (serviceWorker.state === 'redundant') {\n        reject(this.errorFactory_.create(Errors.codes.SW_REG_REDUNDANT));\n        return;\n      }\n\n      let stateChangeListener = () => {\n        if (serviceWorker.state === 'activated') {\n          resolve(registration);\n        } else if (serviceWorker.state === 'redundant') {\n          reject(this.errorFactory_.create(Errors.codes.SW_REG_REDUNDANT));\n        } else {\n          // Return early and wait to next state change\n          return;\n        }\n        serviceWorker.removeEventListener('statechange', stateChangeListener);\n      };\n      serviceWorker.addEventListener('statechange', stateChangeListener);\n    });\n  }\n\n  /**\n   * This will regiater the default service worker and return the registration\n   * @private\n   * @return {Promise<!ServiceWorkerRegistration>} The service worker\n   * registration to be used for the push service.\n   */\n  getSWRegistration_() {\n    if (this.registrationToUse_) {\n      return this.waitForRegistrationToActivate_(this.registrationToUse_);\n    }\n\n    // Make the registration null so we know useServiceWorker will not\n    // use a new service worker as registrationToUse_ is no longer undefined\n    this.registrationToUse_ = null;\n\n    return navigator.serviceWorker\n      .register(DefaultSW.path, {\n        scope: DefaultSW.scope\n      })\n      .catch(err => {\n        throw this.errorFactory_.create(\n          Errors.codes.FAILED_DEFAULT_REGISTRATION,\n          {\n            browserErrorMessage: err.message\n          }\n        );\n      })\n      .then(registration => {\n        return this.waitForRegistrationToActivate_(registration).then(() => {\n          this.registrationToUse_ = registration;\n\n          // We update after activation due to an issue with Firefox v49 where\n          // a race condition occassionally causes the service work to not\n          // install\n          registration.update();\n\n          return registration;\n        });\n      });\n  }\n\n  /**\n   * This method will set up a message listener to handle\n   * events from the service worker that should trigger\n   * events in the page.\n   *\n   * @private\n   */\n  setupSWMessageListener_() {\n    if (!('serviceWorker' in navigator)) {\n      return;\n    }\n\n    navigator.serviceWorker.addEventListener(\n      'message',\n      event => {\n        if (!event.data || !event.data[WorkerPageMessage.PARAMS.TYPE_OF_MSG]) {\n          // Not a message from FCM\n          return;\n        }\n\n        const workerPageMessage = event.data;\n        switch (workerPageMessage[WorkerPageMessage.PARAMS.TYPE_OF_MSG]) {\n          case WorkerPageMessage.TYPES_OF_MSG.PUSH_MSG_RECEIVED:\n          case WorkerPageMessage.TYPES_OF_MSG.NOTIFICATION_CLICKED:\n            const pushMessage =\n              workerPageMessage[WorkerPageMessage.PARAMS.DATA];\n            this.messageObserver_.next(pushMessage);\n            break;\n          default:\n            // Noop.\n            break;\n        }\n      },\n      false\n    );\n  }\n\n  /**\n   * Checks to see if the required API's are valid or not.\n   * @private\n   * @return {boolean} Returns true if the desired APIs are available.\n   */\n  isSupported_() {\n    return (\n      'serviceWorker' in navigator &&\n      'PushManager' in window &&\n      'Notification' in window &&\n      'fetch' in window &&\n      ServiceWorkerRegistration.prototype.hasOwnProperty('showNotification') &&\n      PushSubscription.prototype.hasOwnProperty('getKey')\n    );\n  }\n}\n"]},"metadata":{},"sourceType":"module"}